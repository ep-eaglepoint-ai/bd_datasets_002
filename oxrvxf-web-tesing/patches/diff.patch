diff --git a/oxrvxf-web-tesing/repository_after/kanban/index.html b/oxrvxf-web-tesing/repository_after/kanban/index.html
index 6c26873e..4b15d1ae 100644
--- a/oxrvxf-web-tesing/repository_after/kanban/index.html
+++ b/oxrvxf-web-tesing/repository_after/kanban/index.html
@@ -81,6 +81,6 @@
     </div>
   </div>
 
-  <script type="module" src="js/app.js"></script>
+  <script src="app.js"></script>
 </body>
 </html>
diff --git a/oxrvxf-web-tesing/repository_after/kanban/js/app.js b/oxrvxf-web-tesing/repository_after/kanban/js/app.js
deleted file mode 100644
index 6ce45885..00000000
--- a/oxrvxf-web-tesing/repository_after/kanban/js/app.js
+++ /dev/null
@@ -1,105 +0,0 @@
-// Kanban Board Application - Main Entry Point
-// ========================
-
-import { loadState, tasks, setTasks, getActiveColumn, setActiveColumn } from './state.js';
-import { createTask, deleteTask, getTasksByColumn, updateTask, moveTask } from './taskOperations.js';
-import { renderAllTasks, renderColumn, setSetupTaskEvents, updateAllCounts } from './renderer.js';
-import { openModal, closeModal, setupModalListeners } from './modal.js';
-import { setupDragDropListeners, handleDragStart, handleDragEnd } from './dragDrop.js';
-import { startEditing, finishEditing, cancelEditing, getColumnFromElement } from './taskEditing.js';
-import { saveState, generateId, STORAGE_KEY } from './state.js';
-
-// DOM Elements
-const board = document.getElementById('board');
-
-// Initialize
-document.addEventListener('DOMContentLoaded', () => {
-  loadState();
-  renderAllTasks();
-  setupEventListeners();
-});
-
-// ==================
-// Event Listeners Setup
-// ==================
-
-function setupEventListeners() {
-  // Add task buttons
-  document.querySelectorAll('.add-task-btn').forEach(btn => {
-    btn.addEventListener('click', () => {
-      const column = btn.dataset.column;
-      setActiveColumn(column);
-      openModal(column);
-    });
-  });
-
-  // Modal events
-  setupModalListeners();
-
-  // Drag and drop events
-  setupDragDropListeners();
-
-  // Setup task event handlers
-  setSetupTaskEvents(setupTaskEventsHandler);
-}
-
-function setupTaskEventsHandler(taskEl) {
-  const taskId = taskEl.dataset.id;
-  
-  // Drag events
-  taskEl.addEventListener('dragstart', handleDragStart);
-  taskEl.addEventListener('dragend', handleDragEnd);
-  
-  // Delete button
-  taskEl.querySelector('.task-delete').addEventListener('click', () => {
-    taskEl.style.transform = 'scale(0.9)';
-    taskEl.style.opacity = '0';
-    setTimeout(() => {
-      deleteTask(taskId);
-      const column = tasks.find(t => t.id === taskId)?.column || getColumnFromElement(taskEl);
-      renderColumn(column);
-      updateAllCounts();
-    }, 150);
-  });
-  
-  // Double click to edit
-  taskEl.addEventListener('dblclick', () => startEditing(taskEl));
-  
-  // Edit input events
-  const input = taskEl.querySelector('.task-edit-input');
-  input.addEventListener('blur', () => finishEditing(taskEl, input.value));
-  input.addEventListener('keydown', (e) => {
-    if (e.key === 'Enter') {
-      e.preventDefault();
-      finishEditing(taskEl, input.value);
-    }
-    if (e.key === 'Escape') {
-      cancelEditing(taskEl);
-    }
-  });
-}
-
-// ==================
-// Expose functions to window for Playwright testing
-// ==================
-if (typeof window !== 'undefined') {
-  window.createTask = createTask;
-  window.deleteTask = deleteTask;
-  window.updateTask = updateTask;
-  window.moveTask = moveTask;
-  window.getTasksByColumn = getTasksByColumn;
-  window.loadState = loadState;
-  window.saveState = saveState;
-  window.generateId = generateId;
-  window.renderAllTasks = renderAllTasks;
-  window.renderColumn = renderColumn;
-  window.openModal = openModal;
-  window.closeModal = closeModal;
-  window.STORAGE_KEY = STORAGE_KEY;
-  
-  // Expose tasks array via getter/setter for state inspection
-  Object.defineProperty(window, 'tasks', {
-    get: () => tasks,
-    set: (value) => { setTasks(value); }
-  });
-}
diff --git a/oxrvxf-web-tesing/repository_after/kanban/js/dragDrop.js b/oxrvxf-web-tesing/repository_after/kanban/js/dragDrop.js
deleted file mode 100644
index c83747db..00000000
--- a/oxrvxf-web-tesing/repository_after/kanban/js/dragDrop.js
+++ /dev/null
@@ -1,124 +0,0 @@
-// Drag and Drop
-// ==================
-
-import { setDraggedTask, getDraggedTask } from './state.js';
-import { moveTask } from './taskOperations.js';
-import { renderAllTasks } from './renderer.js';
-
-export function handleDragStart(e) {
-  const taskEl = e.target.closest('.task');
-  if (!taskEl) return;
-  
-  setDraggedTask(taskEl);
-  taskEl.classList.add('dragging');
-  
-  // Set drag data
-  e.dataTransfer.effectAllowed = 'move';
-  e.dataTransfer.setData('text/plain', taskEl.dataset.id);
-  
-  // Add slight delay for visual feedback
-  setTimeout(() => {
-    const currentDragged = getDraggedTask();
-    if (currentDragged) currentDragged.style.opacity = '0.4';
-  }, 0);
-}
-
-export function handleDragEnd(e) {
-  const currentDragged = getDraggedTask();
-  if (currentDragged) {
-    currentDragged.classList.remove('dragging');
-    currentDragged.style.opacity = '';
-  }
-  setDraggedTask(null);
-  
-  // Remove all drag-over states
-  document.querySelectorAll('.column').forEach(col => {
-    col.classList.remove('drag-over');
-  });
-}
-
-export function handleDragOver(e) {
-  e.preventDefault();
-  e.dataTransfer.dropEffect = 'move';
-  
-  const column = e.currentTarget.closest('.column');
-  column.classList.add('drag-over');
-  
-  // Get the task we're hovering over for insertion point
-  const afterElement = getDragAfterElement(e.currentTarget, e.clientY);
-  const draggingEl = document.querySelector('.dragging');
-  
-  if (draggingEl && e.currentTarget.contains(draggingEl) === false) {
-    // Moving to a different column
-    if (afterElement) {
-      e.currentTarget.insertBefore(draggingEl, afterElement);
-    } else {
-      // Remove empty state if present
-      const emptyState = e.currentTarget.querySelector('.empty-state');
-      if (emptyState) emptyState.remove();
-      e.currentTarget.appendChild(draggingEl);
-    }
-  } else if (draggingEl) {
-    // Reordering within same column
-    if (afterElement && afterElement !== draggingEl) {
-      e.currentTarget.insertBefore(draggingEl, afterElement);
-    } else if (!afterElement) {
-      e.currentTarget.appendChild(draggingEl);
-    }
-  }
-}
-
-export function handleDragLeave(e) {
-  // Only remove drag-over if we're actually leaving the column
-  const column = e.currentTarget.closest('.column');
-  const relatedTarget = e.relatedTarget;
-  
-  if (!column.contains(relatedTarget)) {
-    column.classList.remove('drag-over');
-  }
-}
-
-export function handleDrop(e) {
-  e.preventDefault();
-  
-  const column = e.currentTarget.closest('.column');
-  column.classList.remove('drag-over');
-  
-  const taskId = e.dataTransfer.getData('text/plain');
-  const newColumn = e.currentTarget.dataset.column;
-  
-  if (!taskId || !newColumn) return;
-  
-  // Find the task we're inserting before (if any)
-  const afterElement = getDragAfterElement(e.currentTarget, e.clientY);
-  const insertBeforeId = afterElement?.dataset.id || null;
-  
-  moveTask(taskId, newColumn, insertBeforeId);
-  
-  // Re-render all columns to ensure proper state
-  renderAllTasks();
-}
-
-function getDragAfterElement(container, y) {
-  const draggableElements = [...container.querySelectorAll('.task:not(.dragging)')];
-  
-  return draggableElements.reduce((closest, child) => {
-    const box = child.getBoundingClientRect();
-    const offset = y - box.top - box.height / 2;
-    
-    if (offset < 0 && offset > closest.offset) {
-      return { offset, element: child };
-    }
-    return closest;
-  }, { offset: Number.NEGATIVE_INFINITY }).element;
-}
-
-// Setup drag and drop listeners
-export function setupDragDropListeners() {
-  // Column drag events
-  document.querySelectorAll('.tasks').forEach(container => {
-    container.addEventListener('dragover', handleDragOver);
-    container.addEventListener('dragleave', handleDragLeave);
-    container.addEventListener('drop', handleDrop);
-  });
-}
diff --git a/oxrvxf-web-tesing/repository_after/kanban/js/modal.js b/oxrvxf-web-tesing/repository_after/kanban/js/modal.js
deleted file mode 100644
index 16ea5aec..00000000
--- a/oxrvxf-web-tesing/repository_after/kanban/js/modal.js
+++ /dev/null
@@ -1,51 +0,0 @@
-// Modal Handling
-// ==================
-
-import { setActiveColumn, getActiveColumn } from './state.js';
-import { createTask } from './taskOperations.js';
-import { renderColumn, updateAllCounts } from './renderer.js';
-
-const modalOverlay = document.getElementById('modal-overlay');
-const taskForm = document.getElementById('task-form');
-const taskInput = document.getElementById('task-input');
-const cancelBtn = document.getElementById('cancel-btn');
-
-export function openModal(column) {
-  setActiveColumn(column);
-  modalOverlay.classList.add('active');
-  taskInput.value = '';
-  setTimeout(() => taskInput.focus(), 100);
-}
-
-export function closeModal() {
-  modalOverlay.classList.remove('active');
-  setActiveColumn(null);
-  taskInput.value = '';
-}
-
-export function handleFormSubmit(e) {
-  e.preventDefault();
-  const title = taskInput.value.trim();
-  const column = getActiveColumn();
-  
-  if (!title || !column) return;
-  
-  createTask(title, column);
-  renderColumn(column);
-  updateAllCounts();
-  closeModal();
-}
-
-// Setup modal event listeners
-export function setupModalListeners() {
-  taskForm.addEventListener('submit', handleFormSubmit);
-  cancelBtn.addEventListener('click', closeModal);
-  modalOverlay.addEventListener('click', (e) => {
-    if (e.target === modalOverlay) closeModal();
-  });
-
-  // Keyboard shortcuts
-  document.addEventListener('keydown', (e) => {
-    if (e.key === 'Escape') closeModal();
-  });
-}
diff --git a/oxrvxf-web-tesing/repository_after/kanban/js/renderer.js b/oxrvxf-web-tesing/repository_after/kanban/js/renderer.js
deleted file mode 100644
index 71dfadb8..00000000
--- a/oxrvxf-web-tesing/repository_after/kanban/js/renderer.js
+++ /dev/null
@@ -1,62 +0,0 @@
-// Rendering
-// ==================
-
-import { getTasksByColumn } from './taskOperations.js';
-
-export function renderAllTasks() {
-  ['todo', 'progress', 'done'].forEach(column => {
-    renderColumn(column);
-  });
-  updateAllCounts();
-}
-
-export function renderColumn(column) {
-  const container = document.getElementById(`${column}-tasks`);
-  const columnTasks = getTasksByColumn(column);
-  
-  container.innerHTML = columnTasks.length === 0 
-    ? '<div class="empty-state">No tasks yet</div>'
-    : columnTasks.map(task => createTaskHTML(task)).join('');
-  
-  // Attach event listeners to new task elements
-  container.querySelectorAll('.task').forEach(taskEl => {
-    if (typeof setupTaskEvents === 'function') {
-      setupTaskEvents(taskEl);
-    }
-  });
-}
-
-function createTaskHTML(task) {
-  return `
-    <div class="task" draggable="true" data-id="${task.id}">
-      <div class="task-content">
-        <span class="task-title">${escapeHtml(task.title)}</span>
-        <input type="text" class="task-edit-input" value="${escapeHtml(task.title)}" maxlength="100">
-        <button class="task-delete" aria-label="Delete task">Ã—</button>
-      </div>
-    </div>
-  `;
-}
-
-function escapeHtml(text) {
-  const div = document.createElement('div');
-  div.textContent = text;
-  return div.innerHTML;
-}
-
-export function updateAllCounts() {
-  ['todo', 'progress', 'done'].forEach(column => {
-    const count = getTasksByColumn(column).length;
-    const countElement = document.querySelector(`[data-count="${column}"]`);
-    if (countElement) {
-      countElement.textContent = count;
-    }
-  });
-}
-
-// Export setupTaskEvents for use in app.js
-export let setupTaskEvents = null;
-
-export function setSetupTaskEvents(fn) {
-  setupTaskEvents = fn;
-}
diff --git a/oxrvxf-web-tesing/repository_after/kanban/js/state.js b/oxrvxf-web-tesing/repository_after/kanban/js/state.js
deleted file mode 100644
index 480064b0..00000000
--- a/oxrvxf-web-tesing/repository_after/kanban/js/state.js
+++ /dev/null
@@ -1,61 +0,0 @@
-// State Management
-// ==================
-
-export const STORAGE_KEY = 'kanban-board-state';
-
-// State
-export let tasks = [];
-export let activeColumn = null;
-export let draggedTask = null;
-
-export function setTasks(newTasks) {
-  tasks = newTasks;
-}
-
-export function setActiveColumn(column) {
-  activeColumn = column;
-}
-
-export function getActiveColumn() {
-  return activeColumn;
-}
-
-export function setDraggedTask(task) {
-  draggedTask = task;
-}
-
-export function getDraggedTask() {
-  return draggedTask;
-}
-
-export function loadState() {
-  try {
-    const saved = localStorage.getItem(STORAGE_KEY);
-    if (saved) {
-      tasks = JSON.parse(saved);
-    } else {
-      // Default sample tasks
-      tasks = [
-        { id: generateId(), title: 'Design the landing page', column: 'todo' },
-        { id: generateId(), title: 'Set up project repository', column: 'progress' },
-        { id: generateId(), title: 'Create initial wireframes', column: 'done' },
-      ];
-      saveState();
-    }
-  } catch (e) {
-    console.error('Failed to load state:', e);
-    tasks = [];
-  }
-}
-
-export function saveState() {
-  try {
-    localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
-  } catch (e) {
-    console.error('Failed to save state:', e);
-  }
-}
-
-export function generateId() {
-  return `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
-}
diff --git a/oxrvxf-web-tesing/repository_after/kanban/js/taskEditing.js b/oxrvxf-web-tesing/repository_after/kanban/js/taskEditing.js
deleted file mode 100644
index 6644ea59..00000000
--- a/oxrvxf-web-tesing/repository_after/kanban/js/taskEditing.js
+++ /dev/null
@@ -1,40 +0,0 @@
-// Task Editing
-// ==================
-
-import { tasks } from './state.js';
-import { updateTask } from './taskOperations.js';
-
-export function startEditing(taskEl) {
-  taskEl.classList.add('editing');
-  const input = taskEl.querySelector('.task-edit-input');
-  const title = taskEl.querySelector('.task-title');
-  input.value = title.textContent;
-  input.focus();
-  input.select();
-}
-
-export function finishEditing(taskEl, newTitle) {
-  if (!taskEl.classList.contains('editing')) return;
-  
-  const taskId = taskEl.dataset.id;
-  const trimmed = newTitle.trim();
-  
-  if (trimmed) {
-    updateTask(taskId, trimmed);
-    taskEl.querySelector('.task-title').textContent = trimmed;
-  }
-  
-  taskEl.classList.remove('editing');
-}
-
-export function cancelEditing(taskEl) {
-  const task = tasks.find(t => t.id === taskEl.dataset.id);
-  if (task) {
-    taskEl.querySelector('.task-edit-input').value = task.title;
-  }
-  taskEl.classList.remove('editing');
-}
-
-export function getColumnFromElement(taskEl) {
-  return taskEl.closest('.tasks')?.dataset.column || 'todo';
-}
diff --git a/oxrvxf-web-tesing/repository_after/kanban/js/taskOperations.js b/oxrvxf-web-tesing/repository_after/kanban/js/taskOperations.js
deleted file mode 100644
index 721856b9..00000000
--- a/oxrvxf-web-tesing/repository_after/kanban/js/taskOperations.js
+++ /dev/null
@@ -1,57 +0,0 @@
-// Task Operations
-// ==================
-
-import { tasks, setTasks, saveState, generateId } from './state.js';
-
-export function createTask(title, column) {
-  const task = {
-    id: generateId(),
-    title: title.trim(),
-    column
-  };
-  const newTasks = [...tasks, task];
-  setTasks(newTasks);
-  saveState();
-  return task;
-}
-
-export function deleteTask(taskId) {
-  const newTasks = tasks.filter(t => t.id !== taskId);
-  setTasks(newTasks);
-  saveState();
-}
-
-export function updateTask(taskId, newTitle) {
-  const task = tasks.find(t => t.id === taskId);
-  if (task && newTitle.trim()) {
-    task.title = newTitle.trim();
-    saveState();
-  }
-}
-
-export function moveTask(taskId, newColumn, insertBeforeId = null) {
-  const task = tasks.find(t => t.id === taskId);
-  if (!task) return;
-
-  task.column = newColumn;
-  
-  // Reorder if inserting before another task
-  if (insertBeforeId) {
-    const taskIndex = tasks.findIndex(t => t.id === taskId);
-    const beforeIndex = tasks.findIndex(t => t.id === insertBeforeId);
-    
-    if (taskIndex !== -1 && beforeIndex !== -1) {
-      const newTasks = [...tasks];
-      newTasks.splice(taskIndex, 1);
-      const newBeforeIndex = newTasks.findIndex(t => t.id === insertBeforeId);
-      newTasks.splice(newBeforeIndex, 0, task);
-      setTasks(newTasks);
-    }
-  }
-  
-  saveState();
-}
-
-export function getTasksByColumn(column) {
-  return tasks.filter(t => t.column === column);
-}
diff --git a/oxrvxf-web-tesing/repository_after/tests/edge-cases.spec.js b/oxrvxf-web-tesing/repository_after/tests/edge-cases.spec.js
index bf7a401e..f9904b16 100644
--- a/oxrvxf-web-tesing/repository_after/tests/edge-cases.spec.js
+++ b/oxrvxf-web-tesing/repository_after/tests/edge-cases.spec.js
@@ -34,7 +34,8 @@ test.describe('Edge Cases', () => {
 
   test('should escape special HTML characters in task titles', async ({ page }) => {
     // Must verify using page.evaluate() that task titles containing special HTML characters like angle brackets and ampersands are escaped
-    const specialTitle = 'Task with "quotes" & <tags> and Ã©mojis ðŸŽ‰';
+    // and rendered as text not HTML by checking element.textContent versus element.innerHTML
+    const specialTitle = 'Task with <angle> brackets & ampersands';
     const task = await page.evaluate(({ title, column }) => {
       return window.createTask(title, column);
     }, { title: specialTitle, column: 'todo' });
@@ -50,18 +51,40 @@ test.describe('Edge Cases', () => {
     const taskTitle = page.locator('.task-title').first();
     
     // Must verify by checking element.textContent versus element.innerHTML
-    const textContent = await taskTitle.textContent();
-    const innerHTML = await taskTitle.innerHTML();
+    const textContent = await page.evaluate((selector) => {
+      const el = document.querySelector(selector);
+      return el ? el.textContent : null;
+    }, '.task-title');
     
-    // textContent should contain the text
-    expect(textContent).toContain('quotes');
-    expect(textContent).toContain('tags');
+    const innerHTML = await page.evaluate((selector) => {
+      const el = document.querySelector(selector);
+      return el ? el.innerHTML : null;
+    }, '.task-title');
     
-    // innerHTML should be escaped (not contain raw HTML tags)
+    // textContent should contain the literal text as the user sees it
+    expect(textContent).toBe('Task with <angle> brackets & ampersands');
+    expect(textContent).toContain('<angle>');
+    expect(textContent).toContain('&');
+    
+    // innerHTML should be escaped - raw HTML tags should NOT appear
+    // The innerHTML should contain escaped entities, not raw <angle>
+    expect(innerHTML).not.toContain('<angle>');
     expect(innerHTML).not.toContain('<tags>');
     expect(innerHTML).not.toContain('<script>');
-    // But should contain escaped versions
+    
+    // Should contain escaped versions of angle brackets
     expect(innerHTML).toContain('&lt;');
+    expect(innerHTML).toContain('&gt;');
+    
+    // Ampersand should be escaped as &amp; in innerHTML
+    // But textContent shows the literal & character
+    expect(innerHTML).toContain('&amp;');
+    expect(textContent).toContain('&');
+    
+    // Verify innerHTML does not contain unescaped angle brackets that could be interpreted as HTML
+    // This ensures the content is rendered as text, not HTML
+    const hasUnescapedAngleBrackets = /<[^&]/.test(innerHTML) && !innerHTML.includes('&lt;');
+    expect(hasUnescapedAngleBrackets).toBe(false);
   });
 
   test('should handle rapid task creation', async ({ page }) => {
@@ -113,35 +136,50 @@ test.describe('Edge Cases', () => {
 
   test('should handle localStorage quota exceeded gracefully', async ({ page }) => {
     // Must use page.evaluate() to fill localStorage near its quota then test that the application handles the storage full condition gracefully
-    await page.evaluate(() => {
+    const quotaExceeded = await page.evaluate(() => {
       localStorage.clear();
       // Try to fill localStorage near quota
-      const largeData = 'x'.repeat(5 * 1024 * 1024); // 5MB
+      const largeData = 'x'.repeat(5 * 1024 * 1024); // 5MB chunks
+      let quotaExceeded = false;
       try {
-        for (let i = 0; i < 10; i++) {
+        for (let i = 0; i < 20; i++) {
           localStorage.setItem(`test-${i}`, largeData);
         }
       } catch (e) {
         // Quota exceeded, that's expected
+        quotaExceeded = true;
       }
+      return quotaExceeded;
     });
 
-    // App should still function - try to create a task
-    try {
-      const task = await page.evaluate(({ title, column }) => {
+    // App should still function and render - verify page still renders
+    const board = page.locator('#board');
+    await expect(board).toBeVisible();
+    
+    // Try to create a task - app should handle storage full condition gracefully
+    // The app should not crash even if localStorage.setItem fails
+    const task = await page.evaluate(({ title, column }) => {
+      try {
         return window.createTask(title, column);
-      }, { title: 'Test task', column: 'todo' });
-      
-      // If task was created, verify app still works
-      if (task) {
-        const tasks = await page.evaluate(() => window.tasks);
-        expect(Array.isArray(tasks)).toBe(true);
+      } catch (e) {
+        // If storage fails, app should handle gracefully
+        return null;
       }
-    } catch (e) {
-      // If storage is full, app should handle gracefully without crashing
-      const board = page.locator('#board');
-      await expect(board).toBeVisible();
-    }
+    }, { title: 'Test task', column: 'todo' });
+    
+    // Verify app still functions - tasks array should exist
+    const tasks = await page.evaluate(() => {
+      return Array.isArray(window.tasks);
+    });
+    expect(tasks).toBe(true);
+    
+    // Verify the page is still functional - can interact with UI
+    const addButton = page.locator('[data-column="todo"] .add-task-btn');
+    await expect(addButton).toBeVisible();
+    
+    // Verify app handles the error gracefully without crashing
+    // The board should still be visible and functional
+    await expect(board).toBeVisible();
   });
 
   test('should handle invalid column names', async ({ page }) => {
@@ -215,4 +253,114 @@ test.describe('Edge Cases', () => {
     await expect(taskElement).toBeVisible();
   });
 
+  test('should handle Promise.all() with multiple rapid sequential drag operations without state corruption', async ({ page }) => {
+    // Must use Promise.all() with multiple rapid sequential drag operations to verify the application handles race conditions without corrupting state
+    // Create multiple tasks in different columns
+    const tasks = await Promise.all([
+      page.evaluate(({ title, column }) => {
+        return window.createTask(title, column);
+      }, { title: 'Task 1', column: 'todo' }),
+      page.evaluate(({ title, column }) => {
+        return window.createTask(title, column);
+      }, { title: 'Task 2', column: 'todo' }),
+      page.evaluate(({ title, column }) => {
+        return window.createTask(title, column);
+      }, { title: 'Task 3', column: 'progress' }),
+      page.evaluate(({ title, column }) => {
+        return window.createTask(title, column);
+      }, { title: 'Task 4', column: 'progress' }),
+    ]);
+
+    // Render all tasks
+    await page.evaluate(() => {
+      window.renderAllTasks();
+    });
+    await page.waitForSelector('.task', { timeout: 5000 });
+
+    // Get initial state
+    const initialTasks = await page.evaluate(() => window.tasks);
+    const initialTaskIds = initialTasks.map(t => t.id);
+    expect(initialTasks).toHaveLength(4);
+
+    // Get column locators
+    const todoColumn = page.locator('#todo-tasks');
+    const progressColumn = page.locator('#progress-tasks');
+    const doneColumn = page.locator('#done-tasks');
+
+    // Must use Promise.all() with multiple rapid sequential drag operations
+    const dragPromises = [];
+    
+    // Drag task 1 from todo to progress
+    dragPromises.push(
+      page.locator(`[data-id="${tasks[0].id}"]`).dragTo(progressColumn)
+    );
+    
+    // Drag task 2 from todo to done
+    dragPromises.push(
+      page.locator(`[data-id="${tasks[1].id}"]`).dragTo(doneColumn)
+    );
+    
+    // Drag task 3 from progress to todo
+    dragPromises.push(
+      page.locator(`[data-id="${tasks[2].id}"]`).dragTo(todoColumn)
+    );
+    
+    // Drag task 4 from progress to done
+    dragPromises.push(
+      page.locator(`[data-id="${tasks[3].id}"]`).dragTo(doneColumn)
+    );
+
+    // Execute all drag operations concurrently using Promise.all()
+    await Promise.all(dragPromises);
+    
+    // Wait for state to settle
+    await page.waitForTimeout(500);
+
+    // Verify no state corruption - all tasks should still exist
+    const finalTasks = await page.evaluate(() => window.tasks);
+    expect(finalTasks).toHaveLength(4);
+    
+    // Verify all original task IDs are still present (no tasks lost)
+    const finalTaskIds = finalTasks.map(t => t.id);
+    for (const originalId of initialTaskIds) {
+      expect(finalTaskIds).toContain(originalId);
+    }
+    
+    // Verify no duplicate tasks (all IDs are unique)
+    const uniqueIds = new Set(finalTaskIds);
+    expect(uniqueIds.size).toBe(4);
+    
+    // Verify tasks are in correct columns after drag operations
+    const todoTasks = finalTasks.filter(t => t.column === 'todo');
+    const progressTasks = finalTasks.filter(t => t.column === 'progress');
+    const doneTasks = finalTasks.filter(t => t.column === 'done');
+    
+    // Task 1 should be in progress
+    expect(finalTasks.find(t => t.id === tasks[0].id)?.column).toBe('progress');
+    // Task 2 should be in done
+    expect(finalTasks.find(t => t.id === tasks[1].id)?.column).toBe('done');
+    // Task 3 should be in todo
+    expect(finalTasks.find(t => t.id === tasks[2].id)?.column).toBe('todo');
+    // Task 4 should be in done
+    expect(finalTasks.find(t => t.id === tasks[3].id)?.column).toBe('done');
+    
+    // Verify task properties are intact (no corruption)
+    for (const originalTask of tasks) {
+      const finalTask = finalTasks.find(t => t.id === originalTask.id);
+      expect(finalTask).toBeDefined();
+      expect(finalTask.title).toBe(originalTask.title);
+      expect(typeof finalTask.id).toBe('string');
+      expect(finalTask.id).toMatch(/^task-\d+-[a-z0-9]+$/);
+    }
+    
+    // Verify localStorage contains valid state
+    const storageData = await page.evaluate((key) => {
+      return localStorage.getItem(key);
+    }, 'kanban-board-state');
+    expect(storageData).toBeTruthy();
+    const parsedStorage = JSON.parse(storageData);
+    expect(parsedStorage).toHaveLength(4);
+    expect(Array.isArray(parsedStorage)).toBe(true);
+  });
+
 });
