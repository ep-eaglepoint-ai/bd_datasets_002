# Z14UL0 - Expense Tracking and Reimbursement System with Approval Workflow and Receipt Management

**Category:** sft

## Overview
- Task ID: Z14UL0
- Title: Expense Tracking and Reimbursement System with Approval Workflow and Receipt Management
- Category: sft
- Repository: ep-eaglepoint-ai/bd_datasets_002
- Branch: z14ul0-expense-tracking-and-reimbursement-system-with-approval-workflow-and-receipt-management

## Requirements
- 1. Expense Submission with Receipt Upload - The POST /api/expenses endpoint must accept: {amount (decimal), currency (USD|EUR|GBP), category_id (int), description (string), expense_date (YYYY-MM-DD), receipt_file (multipart/form-data)}. - Receipt upload must validate: (1) file type (image/jpeg, image/png, application/pdf), (2) file size < 10MB, (3) file not corrupted. - When amount > $25, receipt_file is required: if missing, reject with HTTP 400: "Receipt required for expenses over $25". - When amount <= $25, receipt_file is optional (small expense exemption). - Receipt files must be stored in MinIO with key format: receipts/{user_id}/{expense_id}/{filename} and return a signed URL valid for 7 days. - Expense submission must validate expense_date: if expense_date < now - 90 days, reject with HTTP 400: "Cannot submit expenses older than 90 days". - Expense submission must validate category_id: if category does not exist, reject with HTTP 404: "Category not found". - Newly created expenses must have status = 'draft' until explicitly submitted via POST /api/expenses/:id/submit. - Expense creation must complete in < 2 seconds including file upload to MinIO.  ### 2. Expense Submission and Status Workflow - The POST /api/expenses/:id/submit endpoint must transition expense from 'draft' to 'pending_manager_approval'. - Submission validation: (1) expense must be in 'draft' status, (2) all required fields must be filled, (3) receipt must be uploaded if amount > $25. - When an expense is submitted, the system must send an email notification to the employee's manager: "New expense submission from {employee_name}: ${amount} for {category}. Please review." - Expense status workflow: draft → pending_manager_approval → pending_finance_approval → approved → paid. - Status transitions must be atomic: use database transactions to update status and create approval record simultaneously. - The GET /api/expenses endpoint must support filtering by status: ?status=pending_manager_approval&user_id=5. - The GET /api/expenses/:id endpoint must return expense details including: user (name, email), category (name), receipt_url (signed URL), status, approval_history [{approver, status, comment, timestamp}].
- Manager Approval Workflow - The POST /api/expenses/:id/approve endpoint must be accessible only to users with role='manager' or role='finance'. - Manager approval validation: (1) expense must be in 'pending_manager_approval' status, (2) approver must be the employee's manager (user.manager_id = approver.id), (3) manager cannot approve their own expenses. - When a manager attempts to approve their own expense, reject with HTTP 403: "Managers cannot approve their own expenses". - When a manager approves an expense, the system must: (1) update status to 'pending_finance_approval', (2) create approval record with approver_id, status='approved', comment, timestamp, (3) send email to finance team. - The POST /api/expenses/:id/reject endpoint must allow managers to reject expenses with a required comment explaining the reason. - When a manager rejects an expense, the system must: (1) update status to 'rejected', (2) create approval record with status='rejected', (3) send email to employee with rejection reason. - Approval/rejection must complete in < 500ms including database writes and email notifications.  ### 4. Finance Review and Final Approval - Finance team members (role='finance') can only review expenses in 'pending_finance_approval' status (manager-approved expenses). - Finance approval validation: (1) expense must be in 'pending_finance_approval' status, (2) approver must have role='finance', (3) reimbursement amount must match submitted amount. - When finance approves an expense, the system must: (1) update status to 'approved', (2) create approval record, (3) send email to employee: "Your expense has been approved and will be reimbursed within 5 business days". - Finance can flag expenses for additional review: POST /api/expenses/:id/flag with {reason: string} sets status to 'flagged' and notifies the employee's manager. - When an expense is flagged, the employee must resubmit with additional documentation or clarification. - Finance cannot approve expenses that have not been manager-approved: if status != 'pending_finance_approval', reject with HTTP 400: "Expense must be manager-approved before finance review".
- 5. Reimbursement Processing and Payment Tracking - The POST /api/expenses/:id/pay endpoint must be accessible only to users with role='finance'. - Payment processing: (1) expense must be in 'approved' status, (2) payment_method (bank_transfer|check|payroll) and payment_date must be provided. - When an expense is marked as paid, the system must: (1) update status to 'paid', (2) create payment record with amount, payment_method, payment_date, (3) send email to employee: "Your reimbursement of ${amount} has been processed via {payment_method}". - Payment amount must match expense amount: if payment.amount != expense.amount, reject with HTTP 400: "Payment amount must match expense amount". - The system must track payment history: payments table with (id, expense_id, amount, payment_method, payment_date, processed_by, created_at). - Employees can view payment status in their expense list: GET /api/expenses returns payment_date and payment_method for paid expenses. - Payment processing must complete in < 1 second including database writes and email notifications.  ### 6. Receipt Storage and Retrieval with MinIO - Receipt files must be stored in MinIO (S3-compatible object storage) with bucket name: expense-receipts. - File upload process: (1) validate file type and size, (2) generate unique filename: {expense_id}_{timestamp}_{original_filename}, (3) upload to MinIO, (4) store object key in database. - Receipt URLs must be signed with 7-day expiration: when GET /api/expenses/:id is called, generate a signed URL using MinIO SDK. - Signed URL generation must complete in < 100ms to avoid blocking API responses. - When an expense is deleted (soft delete), the receipt file must remain in MinIO for audit purposes (do not delete from storage). - Receipt download: GET /api/expenses/:id/receipt must return a redirect (HTTP 302) to the signed MinIO URL. - MinIO connection must use connection pooling with max 50 concurrent connections to handle high throughput. - File upload must support concurrent uploads: 100 employees uploading receipts simultaneously must not cause timeouts or data loss.  ### 7. Expense Categories and Budget Limits - Categories must be predefined: Travel, Meals, Office Supplies, Client Entertainment, Software/Subscriptions, Training/Education, Other. - Each category must have a monthly budget limit per employee: categories table with (id, name, budget_limit_per_employee). - When an employee submits an expense, the system must check if total expenses in that category for the current month exceed the budget limit. - If budget limit is exceeded, the expense can still be submitted but must be flagged for manager review with warning: "Budget limit exceeded for {category}: ${total} / ${limit}". - The GET /api/categories endpoint must return all categories with: id, name, budget_limit_per_employee, current_month_total (for the logged-in user). - Budget calculations must be accurate: SUM(amount) WHERE user_id = ? AND category_id = ? AND expense_date >= first_day_of_month AND expense_date <= last_day_of_month AND status != 'rejected'.
- 8. Monthly Expense Reports and Analytics - The GET /api/reports/monthly?month=YYYY-MM endpoint must return aggregated expense data for the specified month. - Report structure: {month, total_expenses, total_reimbursed, pending_count, by_category: [{category, total, count}], by_employee: [{employee, total, count}]}. - Report queries must use database aggregation (GROUP BY) to minimize memory usage and improve performance. - Report generation must complete in < 2 seconds for 1,000 expenses per month. - The GET /api/reports/by-category?start_date=YYYY-MM-DD&end_date=YYYY-MM-DD endpoint must return expense totals grouped by category for a date range. - The GET /api/reports/by-employee?start_date=YYYY-MM-DD&end_date=YYYY-MM-DD endpoint must return expense totals grouped by employee for a date range. - Reports must support CSV export: GET /api/reports/monthly?month=YYYY-MM&format=csv returns a downloadable CSV file. - Report access control: employees can only view their own reports, managers can view reports for their direct reports, finance can view all reports.  ### 9. User Management and Role-Based Access Control - Users table schema: CREATE TABLE users (id SERIAL PRIMARY KEY, email VARCHAR(100) UNIQUE, password_hash VARCHAR(255), role VARCHAR(20) CHECK (role IN ('employee', 'manager', 'finance')), manager_id INT REFERENCES users(id), department VARCHAR(50), created_at TIMESTAMP). - Authentication must use JWT tokens with 24-hour expiration: POST /api/auth/login returns {token, user: {id, email, role}}. - Authorization middleware must check user role before allowing access to protected endpoints: managers can approve expenses, finance can process payments. - Manager hierarchy: employees have a manager_id pointing to their manager; managers can approve expenses for their direct reports only. - When a user logs in, the system must return their role and manager_id to enable frontend role-based UI rendering. - Password hashing must use bcrypt with cost factor 10: never store plaintext passwords.
- 11. API Endpoints and Request/Response Formats - POST /api/auth/login → Request: {email, password}, Response: {token, user: {id, email, role}}, Status: 200. - POST /api/expenses → Request: multipart/form-data {amount, currency, category_id, description, expense_date, receipt_file}, Response: {id, status: "draft"}, Status: 201. - POST /api/expenses/:id/submit → Response: {id, status: "pending_manager_approval"}, Status: 200. - GET /api/expenses?status=pending_manager_approval&page=1&limit=20 → Response: {expenses: [...], total, page, limit}, Status: 200. - GET /api/expenses/:id → Response: {id, user, category, amount, currency, description, expense_date, receipt_url, status, approval_history}, Status: 200. - POST /api/expenses/:id/approve → Request: {comment}, Response: {id, status: "pending_finance_approval"}, Status: 200. - POST /api/expenses/:id/reject → Request: {comment (required)}, Response: {id, status: "rejected"}, Status: 200. - POST /api/expenses/:id/pay → Request: {payment_method, payment_date}, Response: {id, status: "paid", payment}, Status: 200. - GET /api/reports/monthly?month=YYYY-MM → Response: {month, total_expenses, total_reimbursed, by_category, by_employee}, Status: 200.  ### 12. Frontend React Components and User Flows - ExpenseForm component: File upload with drag-and-drop, amount input with currency selector, category dropdown, date picker, description textarea, "Save Draft" and "Submit" buttons. - ExpenseList component: Table with columns (date, category, amount, status, actions), filters (status, date range), pagination, "View Details" and "Download Receipt" buttons. - ApprovalQueue component: List of pending expenses for managers/finance, "Approve" and "Reject" buttons with comment modal, expense details preview. - ReportsPage component: Month selector, category breakdown chart (pie chart), employee breakdown table, "Export CSV" button. - Expense submission flow: (1) Fill form → (2) Upload receipt → (3) Save as draft → (4) Review → (5) Submit for approval → (6) Track status. - Manager approval flow: (1) View pending expenses → (2) Click expense to see details → (3) Review receipt → (4) Approve or reject with comment. - The frontend must handle file upload progress: show progress bar during receipt upload, disable submit button until upload completes.
- 13. Docker Deployment and Environment Configuration - docker-compose.yml must define 4 services: (1) backend (Go Gin app), (2) frontend (React app), (3) postgres (PostgreSQL 14), (4) minio (MinIO object storage). - Backend Dockerfile: FROM golang:1.21, COPY go.mod go.sum, RUN go mod download, COPY cmd/ internal/, RUN go build -o server cmd/server/main.go, CMD ["./server"]. - Frontend Dockerfile: FROM node:18, COPY package.json, RUN npm install, COPY src/, RUN npm run build, CMD ["npm", "start"]. - MinIO must be configured with: MINIO_ROOT_USER=admin, MINIO_ROOT_PASSWORD=password123, default bucket expense-receipts created on startup. - PostgreSQL must use a volume for data persistence: volumes: - postgres_data:/var/lib/postgresql/data. - Environment variables: DATABASE_URL, MINIO_ENDPOINT, MINIO_ACCESS_KEY, MINIO_SECRET_KEY, JWT_SECRET, SMTP_HOST (for email notifications). - The system must run with a single command: docker-compose up --build, and be accessible at http://localhost:3000 (frontend) and http://localhost:8080 (backend).  ### 14. Stress Test and Validation Scenarios - Scenario 1: 100 concurrent expense submissions with receipt uploads → all succeed, no data loss, receipts stored correctly in MinIO. - Scenario 2: Manager attempts to approve their own expense → rejected with HTTP 403: "Managers cannot approve their own expenses". - Scenario 3: Submit expense > $25 without receipt → rejected with HTTP 400: "Receipt required for expenses over $25". - Scenario 4: Submit expense 91 days old → rejected with HTTP 400: "Cannot submit expenses older than 90 days". - Scenario 5: Finance attempts to approve expense in 'pending_manager_approval' status → rejected with HTTP 400: "Expense must be manager-approved before finance review". - Scenario 6: Upload receipt file > 10MB → rejected with HTTP 400: "File size exceeds 10MB limit". - Scenario 7: Approval workflow sequence enforced → expense transitions draft → pending_manager → pending_finance → approved → paid in correct order. - Scenario 8: Monthly report for 1,000 expenses → generated in < 2 seconds with accurate totals. - Scenario 9: Receipt signed URL expires after 7 days → accessing expired URL returns HTTP 403 from MinIO. - Scenario 10: Stress test with 100 employees submitting 10 expenses each (1,000 total) over 5 minutes → zero data corruption, all receipts retrievable, approval workflow intact.

## Metadata
- Programming Languages: Go, JavaScript
- Frameworks: (none)
- Libraries: (none)
- Databases: (none)
- Tools: (none)
- Best Practices: (none)
- Performance Metrics: (none)
- Security Standards: (none)

## Structure
- repository_before/: baseline code (`__init__.py`)
- repository_after/: optimized code (`__init__.py`)
- tests/: test suite (`__init__.py`)
- evaluation/: evaluation scripts (`evaluation.py`)
- instances/: sample/problem instances (JSON)
- patches/: patches for diffing
- trajectory/: notes or write-up (Markdown)

## Quick start
- Run tests locally: `python -m pytest -q tests`
- With Docker: `docker compose up --build --abort-on-container-exit`
- Add dependencies to `requirements.txt`

## Notes
- Keep commits focused and small.
- Open a PR when ready for review.
