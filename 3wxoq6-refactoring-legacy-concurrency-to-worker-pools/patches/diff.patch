diff --git a/repository_before/collector.go b/repository_after/collector.go
index 56fa88a..5c822a7 100644
--- a/repository_before/collector.go
+++ b/repository_after/collector.go
@@ -1,32 +1,113 @@
-package main
+package repository_after
 
 import (
-"fmt"
-"time"
+	"context"
+	"fmt"
+	"sync"
 )
 
-// Global state - BAD
-var metricsCache = make(map[string]int)
+// AsyncCollector manages log processing using worker pool pattern
+type AsyncCollector struct {
+	store      MetricStore
+	jobQueue   chan string
+	workers    int
+	wg         sync.WaitGroup
+}
 
-func ProcessIncomingLogs(logs []string) {
-for _, log := range logs {
-// Launching goroutine per log entry
-go func() {
-// Simulating processing logic
-region := parseRegion(log)
-// RACE CONDITION HERE
-metricsCache[region]++
-}()
+// NewAsyncCollector creates a new AsyncCollector with dependency injection
+func NewAsyncCollector(store MetricStore, bufferSize, workers int) *AsyncCollector {
+	return &AsyncCollector{
+		store:    store,
+		jobQueue: make(chan string, bufferSize),
+		workers:  workers,
+	}
 }
+
+// Start initializes the worker pool
+func (ac *AsyncCollector) Start(ctx context.Context) {
+	for i := 0; i < ac.workers; i++ {
+		ac.wg.Add(1)
+		go ac.worker(ctx)
+	}
 }
 
-func parseRegion(log string) string {
-// ... dummy implementation
-return "us-east-1"
+// worker processes jobs from the job queue
+func (ac *AsyncCollector) worker(ctx context.Context) {
+	defer ac.wg.Done()
+	
+	for {
+		select {
+		case log, ok := <-ac.jobQueue:
+			if !ok {
+				// Channel closed, exit worker
+				return
+			}
+			// Process the log entry
+			region := parseRegion(log)
+			ac.store.Inc(region)
+			
+		case <-ctx.Done():
+			// Context cancelled, finish remaining jobs then exit
+			// Drain remaining jobs from queue
+			for {
+				select {
+				case log, ok := <-ac.jobQueue:
+					if !ok {
+						return
+					}
+					region := parseRegion(log)
+					ac.store.Inc(region)
+				default:
+					return
+				}
+			}
+		}
+	}
+}
+
+// ProcessIncomingLogs sends logs to the job queue for processing
+func (ac *AsyncCollector) ProcessIncomingLogs(ctx context.Context, logs []string) {
+	for _, log := range logs {
+		select {
+		case ac.jobQueue <- log:
+			// Job successfully queued
+		case <-ctx.Done():
+			// Context cancelled, stop processing
+			return
+		}
+	}
+}
+
+// Shutdown gracefully shuts down the collector
+func (ac *AsyncCollector) Shutdown() {
+	close(ac.jobQueue)
+	ac.wg.Wait()
+}
+
+// GetStats returns current statistics from the store
+func (ac *AsyncCollector) GetStats() map[string]int {
+	stats := make(map[string]int)
+	// Since we don't have a way to iterate over all keys in the interface,
+	// we'll return known regions for this implementation
+	regions := []string{"us-east-1", "us-west-1", "eu-west-1", "ap-southeast-1"}
+	for _, region := range regions {
+		if count := ac.store.Get(region); count > 0 {
+			stats[region] = count
+		}
+	}
+	return stats
 }
 
-func PrintStats() {
-for k, v := range metricsCache {
-fmt.Printf("%s: %d\n", k, v)
+// PrintStats displays current statistics
+func (ac *AsyncCollector) PrintStats() {
+	stats := ac.GetStats()
+	for k, v := range stats {
+		fmt.Printf("%s: %d\n", k, v)
+	}
+}
+
+// parseRegion extracts region from log (dummy implementation)
+func parseRegion(log string) string {
+	// ... dummy implementation - in real scenario, parse from log
+	return "us-east-1"
 }
-}
\ No newline at end of file
diff --git a/repository_after/go.mod b/repository_after/go.mod
new file mode 100644
index 0000000..2fd1068
--- /dev/null
+++ b/repository_after/go.mod
@@ -0,0 +1,11 @@
+module repository_after
+
+go 1.20
+
+require github.com/stretchr/testify v1.8.4
+
+require (
+	github.com/davecgh/go-spew v1.1.1 // indirect
+	github.com/pmezard/go-difflib v1.0.0 // indirect
+	gopkg.in/yaml.v3 v3.0.1 // indirect
+)
diff --git a/repository_after/store.go b/repository_after/store.go
new file mode 100644
index 0000000..7a9710f
--- /dev/null
+++ b/repository_after/store.go
@@ -0,0 +1,36 @@
+package repository_after
+
+import "sync"
+
+// MetricStore defines the interface for metric storage operations
+type MetricStore interface {
+	Inc(key string)
+	Get(key string) int
+}
+
+// ConcurrentMetricStore implements MetricStore using sync.RWMutex for safe concurrent access
+type ConcurrentMetricStore struct {
+	mu     sync.RWMutex
+	store  map[string]int
+}
+
+// NewConcurrentMetricStore creates a new thread-safe metric store
+func NewConcurrentMetricStore() *ConcurrentMetricStore {
+	return &ConcurrentMetricStore{
+		store: make(map[string]int),
+	}
+}
+
+// Inc increments the counter for the given key
+func (c *ConcurrentMetricStore) Inc(key string) {
+	c.mu.Lock()
+	defer c.mu.Unlock()
+	c.store[key]++
+}
+
+// Get retrieves the current count for the given key
+func (c *ConcurrentMetricStore) Get(key string) int {
+	c.mu.RLock()
+	defer c.mu.RUnlock()
+	return c.store[key]
+}
