--- repository_before/components/category-form.tsx	2026-01-22 15:04:09
+++ repository_after/components/category-form.tsx	2026-01-27 20:33:44
@@ -1,15 +1,14 @@
-
 "use client";
 
 import * as z from "zod";
-import axios from "axios";
-import { useState } from "react";
+import { useState, useCallback, useRef, useEffect, useMemo } from "react";
 import { zodResolver } from "@hookform/resolvers/zod";
 import { useForm } from "react-hook-form";
 import { toast } from "react-hot-toast";
 import { Trash } from "lucide-react";
 import { Billboard, Category } from "@prisma/client";
 import { useParams, useRouter } from "next/navigation";
+import React from 'react';
 
 import { Input } from "@/components/ui/input";
 import { Button } from "@/components/ui/button";
@@ -45,7 +44,7 @@
     billboards: Billboard[];
 }
 
-export const CategoryForm: React.FC<CategoryFormProps> = ({
+export const CategoryForm: React.FC<CategoryFormProps> = React.memo(({
     initialData,
     billboards,
 }) => {
@@ -55,59 +54,188 @@
     const [open, setOpen] = useState(false);
     const [loading, setLoading] = useState(false);
 
-    const title = initialData ? "Edit category" : "Create category";
-    const description = initialData ? "Edit a category." : "Add a new category";
-    const toastMessage = initialData ? "Category updated." : "Category created.";
-    const action = initialData ? "Save changes" : "Create";
+    // Lifecycle controls
+    const isSubmitting = useRef(false);
+    const isMounted = useRef(false);
+    const abortControllerRef = useRef<AbortController | null>(null);
+    const requestIdRef = useRef(0);
+    const lockOwnerIdRef = useRef<number | null>(null); // Ownership-based lock
 
+    useEffect(() => {
+        isMounted.current = true;
+        return () => {
+            isMounted.current = false;
+            abortControllerRef.current?.abort();
+        };
+    }, []);
+
+    const uiText = useMemo(() => {
+        return initialData
+            ? {
+                title: "Edit category",
+                description: "Edit a category.",
+                action: "Save changes",
+                success: "Category updated.",
+            }
+            : {
+                title: "Create category",
+                description: "Add a new category",
+                action: "Create",
+                success: "Category created.",
+            };
+    }, [initialData]);
+
+    const defaultValues = useMemo(
+        () => initialData || { name: "", billboardId: "" },
+        [initialData]
+    );
+
     const form = useForm<CategoryFormValues>({
         resolver: zodResolver(formSchema),
-        defaultValues: initialData || {
-            name: "",
-            billboardId: "",
-        },
+        defaultValues,
     });
 
-    const onSubmit = async (data: CategoryFormValues) => {
-        try {
-            setLoading(true);
-            if (initialData) {
-                await axios.patch(
-                    `/api/${params.storeId}/categories/${params.categoryId}`,
-                    data
-                );
-            } else {
-                await axios.post(`/api/${params.storeId}/categories`, data);
-            }
-            router.refresh();
-            router.push(`/${params.storeId}/categories`);
-            toast.success(toastMessage);
-        } catch (error: any) {
-            toast.error("Something went wrong.");
-        } finally {
-            setLoading(false);
+    useEffect(() => {
+        // Always reset form when initialData changes (including when it becomes null)
+        if (initialData) {
+            form.reset({
+                name: initialData.name,
+                billboardId: initialData.billboardId,
+            });
+        } else {
+            // Reset to empty state when initialData is null
+            form.reset({ name: "", billboardId: "" });
         }
-    };
+    }, [initialData, form]);
 
-    const onDelete = async () => {
-        try {
+    const onSubmit = useCallback(
+        async (data: CategoryFormValues) => {
+            const currentRequestId = ++requestIdRef.current;
+            
+            // Prevent concurrent submissions
+            if (isSubmitting.current) return;
+            
+            // Prevent rapid sequential submits after success (UX protection only)
+            if (lockOwnerIdRef.current !== null && 
+                currentRequestId - lockOwnerIdRef.current <= 1) {
+                return;
+            }
+
+            // Take ownership of the lock
+            isSubmitting.current = true;
+            lockOwnerIdRef.current = currentRequestId;
             setLoading(true);
-            await axios.delete(
-                `/api/${params.storeId}/categories/${params.categoryId}`
-            );
-            router.refresh();
-            router.push(`/${params.storeId}/categories`);
-            toast.success("Category deleted.");
-        } catch (error: any) {
-            toast.error(
-                "Make sure you removed all products using this category first."
+
+            abortControllerRef.current?.abort();
+            const controller = new AbortController();
+            abortControllerRef.current = controller;
+
+            try {
+                const res = await fetch(
+                    initialData
+                        ? `/api/${params.storeId}/categories/${params.categoryId}`
+                        : `/api/${params.storeId}/categories`,
+                    {
+                        method: initialData ? "PATCH" : "POST",
+                        headers: { 
+                            "Content-Type": "application/json",
+                            "Idempotency-Key": `category-${currentRequestId}-${Date.now()}` // Client-side idempotency hint
+                        },
+                        body: JSON.stringify({
+                            ...data,
+                            _clientRequestId: currentRequestId, // For debugging only
+                        }),
+                        signal: controller.signal,
+                    }
+                );
+
+                if (!res.ok) throw new Error("Request failed");
+
+                if (!isMounted.current) return;
+
+                toast.success(uiText.success);
+                router.push(`/${params.storeId}/categories`);
+            } catch (err: any) {
+                if (err.name !== "AbortError" && isMounted.current) {
+                    toast.error(err?.message || "Something went wrong.");
+                }
+            } finally {
+                // Release lock ONLY if this request owns it (ownership-based invariant)
+                if (lockOwnerIdRef.current === currentRequestId) {
+                    isSubmitting.current = false;
+                    lockOwnerIdRef.current = null;
+                    setLoading(false);
+                }
+            }
+        },
+        [initialData, params.storeId, params.categoryId, router, uiText.success]
+    );
+
+    const onDelete = useCallback(async () => {
+        const currentRequestId = ++requestIdRef.current;
+        
+        // Prevent concurrent delete attempts
+        if (isSubmitting.current) return;
+        
+        // Prevent rapid sequential delete attempts (UX protection only)
+        if (lockOwnerIdRef.current !== null && 
+            currentRequestId - lockOwnerIdRef.current <= 1) {
+            return;
+        }
+
+        // Take ownership of the lock
+        isSubmitting.current = true;
+        lockOwnerIdRef.current = currentRequestId;
+        setLoading(true);
+
+        abortControllerRef.current?.abort();
+        const controller = new AbortController();
+        abortControllerRef.current = controller;
+
+        try {
+            const res = await fetch(
+                `/api/${params.storeId}/categories/${params.categoryId}`,
+                { 
+                    method: "DELETE", 
+                    headers: {
+                        "Idempotency-Key": `delete-${currentRequestId}-${Date.now()}` // Client-side idempotency hint
+                    },
+                    signal: controller.signal 
+                }
             );
+
+            if (!res.ok) throw new Error("Delete failed");
+
+            if (!isMounted.current) return;
+
+            toast.success("Category deleted.");
+            router.push(`/${params.storeId}/categories`);
+        } catch (err: any) {
+            if (err.name !== "AbortError" && isMounted.current) {
+                toast.error(
+                    "Make sure you removed all products using this category first."
+                );
+            }
         } finally {
-            setLoading(false);
-            setOpen(false);
+            // Release lock ONLY if this request owns it (ownership-based invariant)
+            if (lockOwnerIdRef.current === currentRequestId) {
+                isSubmitting.current = false;
+                lockOwnerIdRef.current = null;
+                setLoading(false);
+                setOpen(false);
+            }
         }
-    };
+    }, [params.storeId, params.categoryId, router]);
 
+    const billboardOptions = useMemo(() => {
+        if (!billboards?.length) return [];
+        return billboards.map((billboard) => (
+            <SelectItem key={billboard.id} value={billboard.id}>
+                {billboard.label}
+            </SelectItem>
+        ));
+    }, [billboards]);
+
     return (
         <>
             <AlertModal
@@ -117,7 +245,7 @@
                 loading={loading}
             />
             <div className="flex items-center justify-between">
-                <Heading title={title} description={description} />
+                <Heading title={uiText.title} description={uiText.description} />
                 {initialData && (
                     <Button
                         disabled={loading}
@@ -168,17 +296,12 @@
                                         <FormControl>
                                             <SelectTrigger>
                                                 <SelectValue
-                                                    defaultValue={field.value}
                                                     placeholder="Select a billboard"
                                                 />
                                             </SelectTrigger>
                                         </FormControl>
                                         <SelectContent>
-                                            {billboards.map((billboard) => (
-                                                <SelectItem key={billboard.id} value={billboard.id}>
-                                                    {billboard.label}
-                                                </SelectItem>
-                                            ))}
+                                            {billboardOptions}
                                         </SelectContent>
                                     </Select>
                                     <FormMessage />
@@ -187,11 +310,10 @@
                         />
                     </div>
                     <Button disabled={loading} className="ml-auto" type="submit">
-                        {action}
+                        {uiText.action}
                     </Button>
                 </form>
             </Form>
         </>
     );
-};
-
+});
