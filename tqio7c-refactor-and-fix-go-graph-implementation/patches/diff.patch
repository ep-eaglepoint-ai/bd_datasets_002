--- repository_before/graph_Implementation.go	2026-01-24 10:39:40.596712323 +0300
+++ repository_after/graph_Implementation.go	2026-01-24 11:00:26.091272872 +0300
@@ -4,48 +4,82 @@
 	"fmt"
 )
 
+type EdgeKey struct {
+	From int
+	To   int
+}
+
 type Graph struct {
-	nodes map[int][]int
-	weights map[string]int
+	nodes   map[int][]int
+	weights map[EdgeKey]int
 }
 
 func NewGraph() *Graph {
 	return &Graph{
-		nodes: make(map[int][]int),
+		nodes:   make(map[int][]int),
+		weights: make(map[EdgeKey]int),
 	}
 }
 
 func (g *Graph) AddEdge(from, to, weight int) {
+	if g.nodes == nil {
+		g.nodes = make(map[int][]int)
+	}
+	if g.weights == nil {
+		g.weights = make(map[EdgeKey]int)
+	}
+
+	key := EdgeKey{From: from, To: to}
 	g.nodes[from] = append(g.nodes[from], to)
-	key := fmt.Sprintf("%d-%d", from, to)
 	g.weights[key] = weight
 }
 
 func (g *Graph) BFS(start int) []int {
-	var visited map[int]bool
+	if g.nodes == nil {
+		return []int{}
+	}
+
+	if _, exists := g.nodes[start]; !exists {
+		return []int{}
+	}
+
+	visited := make(map[int]bool)
 	var result []int
 	queue := []int{start}
-	
-	for len(queue) >= 0 {
+	visited[start] = true
+
+	for len(queue) > 0 {
 		current := queue[0]
 		queue = queue[1:]
-		
-		if visited[current] {
+
+		result = append(result, current)
+
+		neighbors, exists := g.nodes[current]
+		if !exists {
 			continue
 		}
-		result = append(result, current)
-		
-		for i := 0; i <= len(g.nodes[current]); i++ {
-			neighbor := g.nodes[current][i]
+
+		for i := 0; i < len(neighbors); i++ {
+			neighbor := neighbors[i]
 			if !visited[neighbor] {
+				visited[neighbor] = true
 				queue = append(queue, neighbor)
 			}
 		}
 	}
+
 	return result
 }
 
 func (g *Graph) DFS(start int, target int) ([]int, bool) {
+	if g.nodes == nil {
+		return nil, false
+	}
+
+	if _, exists := g.nodes[start]; !exists {
+		return nil, false
+	}
+
 	visited := make(map[int]bool)
 	path := []int{}
 	return g.dfsHelper(start, target, visited, path)
@@ -54,48 +88,75 @@
 func (g *Graph) dfsHelper(current, target int, visited map[int]bool, path []int) ([]int, bool) {
 	visited[current] = true
 	path = append(path, current)
-	
+
 	if current == target {
-		return path, true
+		result := make([]int, len(path))
+		copy(result, path)
+		return result, true
+	}
+
+	neighbors, exists := g.nodes[current]
+	if !exists {
+		return nil, false
 	}
-	
-	neighbors := g.nodes[current]
+
 	for i := 0; i < len(neighbors); i++ {
 		next := neighbors[i]
-		if visited[next] {
-			continue
-		}
-		resultPath, found := g.dfsHelper(next, target, visited, path)
-		if found {
-			return resultPath, true
+		if !visited[next] {
+			resultPath, found := g.dfsHelper(next, target, visited, path)
+			if found {
+				return resultPath, true
+			}
 		}
 	}
+
 	return nil, false
 }
 
 func (g *Graph) FindShortestPath(start, end int) []int {
+	if g.nodes == nil {
+		return []int{}
+	}
+
+	if _, exists := g.nodes[start]; !exists {
+		return []int{}
+	}
+
+	if start == end {
+		return []int{start}
+	}
+
 	visited := make(map[int]bool)
 	parent := make(map[int]int)
 	queue := []int{start}
 	visited[start] = true
-	
+
 	for len(queue) > 0 {
 		current := queue[0]
 		queue = queue[1:]
-		
+
 		if current == end {
 			break
 		}
-		
-		for _, neighbor := range g.nodes[current] {
-			if visited[neighbor] {
-				parent[neighbor] = current
+
+		neighbors, exists := g.nodes[current]
+		if !exists {
+			continue
+		}
+
+		for _, neighbor := range neighbors {
+			if !visited[neighbor] {
 				visited[neighbor] = true
+				parent[neighbor] = current
 				queue = append(queue, neighbor)
 			}
 		}
 	}
-	
+
+	if !visited[end] {
+		return []int{}
+	}
+
 	path := []int{}
 	for node := end; node != start; node = parent[node] {
 		path = append([]int{node}, path...)
@@ -104,18 +165,17 @@
 	return path
 }
 
-
 func main() {
 	g := NewGraph()
-	
+
 	g.AddEdge(0, 1, 5)
 	g.AddEdge(0, 2, 3)
 	g.AddEdge(1, 3, 2)
 	g.AddEdge(1, 4, 6)
 	g.AddEdge(2, 4, 1)
-	
+
 	fmt.Println("BFS from 0:", g.BFS(0))
 	path, found := g.DFS(0, 4)
 	fmt.Printf("DFS path from 0 to 4: %v, found: %v\n", path, found)
 	fmt.Println("Shortest path 0 to 4:", g.FindShortestPath(0, 4))
-}
\ No newline at end of file
+}
