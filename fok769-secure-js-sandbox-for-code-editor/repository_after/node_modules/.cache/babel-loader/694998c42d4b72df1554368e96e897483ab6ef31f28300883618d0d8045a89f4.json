{"ast":null,"code":"import{useRef,useEffect,useCallback}from'react';/**\n * Secure JavaScript Sandbox Component\n * \n * Uses iframe with sandbox attributes to isolate user code execution.\n * Prevents access to parent window, document, localStorage, and other browser APIs.\n * Intercepts console methods and restores them after execution.\n * Handles infinite loops with timeout protection.\n */export function useSecureSandbox(){const iframeRef=useRef(null);const timeoutRef=useRef(null);// Create sandbox HTML content that will be loaded in iframe\nconst createSandboxHTML=useCallback(userCode=>{return\"\\n<!DOCTYPE html>\\n<html>\\n<head>\\n  <meta charset=\\\"utf-8\\\">\\n  <title>Sandbox</title>\\n</head>\\n<body>\\n  <script>\\n    (function() {\\n      'use strict';\\n      \\n      // Backup original console methods\\n      const consoleBackup = {\\n        log: console.log,\\n        error: console.error,\\n        warn: console.warn,\\n        info: console.info,\\n        debug: console.debug\\n      };\\n      \\n      // Intercept console methods\\n      const interceptedLogs = [];\\n      const interceptConsole = (method) => {\\n        return function(...args) {\\n          interceptedLogs.push({\\n            type: method,\\n            message: args.map(arg => {\\n              if (typeof arg === 'object') {\\n                try {\\n                  return JSON.stringify(arg, null, 2);\\n                } catch (e) {\\n                  return String(arg);\\n                }\\n              }\\n              return String(arg);\\n            }).join(' ')\\n          });\\n          // Also call original to see in iframe console for debugging\\n          consoleBackup[method].apply(console, args);\\n        };\\n      };\\n      \\n      console.log = interceptConsole('log');\\n      console.error = interceptConsole('error');\\n      console.warn = interceptConsole('warn');\\n      console.info = interceptConsole('info');\\n      console.debug = interceptConsole('debug');\\n      \\n      // Remove dangerous globals\\n      delete window.eval;\\n      delete window.Function;\\n      \\n      // Block access to parent\\n      try {\\n        Object.defineProperty(window, 'parent', {\\n          get: function() { return window; },\\n          configurable: false\\n        });\\n        Object.defineProperty(window, 'top', {\\n          get: function() { return window; },\\n          configurable: false\\n        });\\n        Object.defineProperty(window, 'frameElement', {\\n          get: function() { return null; },\\n          configurable: false\\n        });\\n      } catch (e) {}\\n      \\n      // Block localStorage and sessionStorage\\n      try {\\n        Object.defineProperty(window, 'localStorage', {\\n          get: function() { throw new Error('localStorage access denied'); },\\n          configurable: false\\n        });\\n        Object.defineProperty(window, 'sessionStorage', {\\n          get: function() { throw new Error('sessionStorage access denied'); },\\n          configurable: false\\n        });\\n      } catch (e) {}\\n      \\n      // Block document access to sensitive APIs\\n      if (document) {\\n        try {\\n          const originalOpen = document.open;\\n          document.open = function() {\\n            throw new Error('document.open() is not allowed');\\n          };\\n        } catch (e) {}\\n      }\\n      \\n      // Execute user code with timeout protection\\n      let executionResult = null;\\n      let executionError = null;\\n      let resultSent = false;\\n      \\n      // Function to send result (only once)\\n      function sendResult() {\\n        if (resultSent) return;\\n        resultSent = true;\\n        clearTimeout(timeoutId);\\n        window.parent.postMessage({\\n          type: 'sandbox-result',\\n          logs: interceptedLogs,\\n          result: executionResult,\\n          error: executionError\\n        }, '*');\\n      }\\n      \\n      // Set up timeout protection\\n      const MAX_EXECUTION_TIME = 5000; // 5 seconds max\\n      const timeoutId = setTimeout(() => {\\n        if (!resultSent) {\\n          executionError = {\\n            message: 'Execution timeout: Possible infinite loop detected',\\n            stack: ''\\n          };\\n          sendResult();\\n        }\\n      }, MAX_EXECUTION_TIME);\\n      \\n      // Execute code immediately\\n      try {\\n        // Wrap user code in IIFE to prevent global pollution\\n        // Use script tag injection instead of eval/Function\\n        const script = document.createElement('script');\\n        const wrappedCode = `\\n          (function() {\\n            'use strict';\\n            try {\\n              ${userCode}\\n            } catch (err) {\\n              window.__sandboxError = {\\n                message: err.message,\\n                stack: err.stack\\n              };\\n            }\\n          })();\\n        `;\\n        \\n        script.textContent = wrappedCode;\\n        \\n        // Use error handler\\n        script.onerror = function(err) {\\n          if (!resultSent) {\\n            executionError = {\\n              message: 'Script execution error: ' + (err.message || 'Unknown error'),\\n              stack: ''\\n            };\\n            sendResult();\\n          }\\n        };\\n        \\n        // Append script - executes synchronously\\n        document.body.appendChild(script);\\n        \\n        // Check for errors and send result after script executes\\n        // Use setTimeout to ensure script has executed and console logs are captured\\n        setTimeout(() => {\\n          if (window.__sandboxError) {\\n            executionError = window.__sandboxError;\\n            delete window.__sandboxError;\\n          }\\n          \\n          // Remove script after execution\\n          try {\\n            if (script.parentNode) {\\n              document.body.removeChild(script);\\n            }\\n          } catch (e) {}\\n          \\n          sendResult();\\n        }, 100); // Small delay to ensure all console logs are captured\\n        \\n      } catch (err) {\\n        if (!resultSent) {\\n          executionError = {\\n            message: err.message,\\n            stack: err.stack\\n          };\\n          sendResult();\\n        }\\n      }\\n    })();\\n  </script>\\n</body>\\n</html>\\n    \";},[]);const executeCode=useCallback((code,onResult)=>{if(!iframeRef.current){onResult({error:'Sandbox not initialized'});return;}// Clear any existing timeout\nif(timeoutRef.current){clearTimeout(timeoutRef.current);}// Set up timeout for infinite loop protection\ntimeoutRef.current=setTimeout(()=>{onResult({error:'Execution timeout: Code execution exceeded maximum time limit (5 seconds). Possible infinite loop detected.',logs:[]});},5000);// Set up message listener FIRST, before loading iframe\nlet messageHandler=null;let handlerRemoved=false;messageHandler=event=>{// Verify message is from our iframe (basic security check)\nif(event.data&&event.data.type==='sandbox-result'){if(!handlerRemoved){handlerRemoved=true;clearTimeout(timeoutRef.current);window.removeEventListener('message',messageHandler);onResult({logs:event.data.logs||[],result:event.data.result,error:event.data.error?event.data.error.message:null});}}};window.addEventListener('message',messageHandler);// Load sandbox content\ntry{const sandboxHTML=createSandboxHTML(code);const blob=new Blob([sandboxHTML],{type:'text/html'});const url=URL.createObjectURL(blob);// Set iframe src immediately - message handler is already set up\nif(iframeRef.current){iframeRef.current.src=url;// Clean up blob URL after loading\niframeRef.current.onload=()=>{setTimeout(()=>URL.revokeObjectURL(url),1000);};}}catch(err){if(!handlerRemoved&&messageHandler){handlerRemoved=true;clearTimeout(timeoutRef.current);window.removeEventListener('message',messageHandler);}onResult({error:\"Failed to initialize sandbox: \".concat(err.message),logs:[]});}},[createSandboxHTML]);// Initialize iframe\nuseEffect(()=>{if(!iframeRef.current){return;}// Set sandbox attributes for maximum isolation\niframeRef.current.setAttribute('sandbox','allow-scripts');iframeRef.current.style.display='none';},[]);return{iframeRef,executeCode};}","map":{"version":3,"names":["useRef","useEffect","useCallback","useSecureSandbox","iframeRef","timeoutRef","createSandboxHTML","userCode","executeCode","code","onResult","current","error","clearTimeout","setTimeout","logs","messageHandler","handlerRemoved","event","data","type","window","removeEventListener","result","message","addEventListener","sandboxHTML","blob","Blob","url","URL","createObjectURL","src","onload","revokeObjectURL","err","concat","setAttribute","style","display"],"sources":["/app/repository_after/src/SecureSandbox.js"],"sourcesContent":["import { useRef, useEffect, useCallback } from 'react';\n\n/**\n * Secure JavaScript Sandbox Component\n * \n * Uses iframe with sandbox attributes to isolate user code execution.\n * Prevents access to parent window, document, localStorage, and other browser APIs.\n * Intercepts console methods and restores them after execution.\n * Handles infinite loops with timeout protection.\n */\nexport function useSecureSandbox() {\n  const iframeRef = useRef(null);\n  const timeoutRef = useRef(null);\n\n  // Create sandbox HTML content that will be loaded in iframe\n  const createSandboxHTML = useCallback((userCode) => {\n    return `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Sandbox</title>\n</head>\n<body>\n  <script>\n    (function() {\n      'use strict';\n      \n      // Backup original console methods\n      const consoleBackup = {\n        log: console.log,\n        error: console.error,\n        warn: console.warn,\n        info: console.info,\n        debug: console.debug\n      };\n      \n      // Intercept console methods\n      const interceptedLogs = [];\n      const interceptConsole = (method) => {\n        return function(...args) {\n          interceptedLogs.push({\n            type: method,\n            message: args.map(arg => {\n              if (typeof arg === 'object') {\n                try {\n                  return JSON.stringify(arg, null, 2);\n                } catch (e) {\n                  return String(arg);\n                }\n              }\n              return String(arg);\n            }).join(' ')\n          });\n          // Also call original to see in iframe console for debugging\n          consoleBackup[method].apply(console, args);\n        };\n      };\n      \n      console.log = interceptConsole('log');\n      console.error = interceptConsole('error');\n      console.warn = interceptConsole('warn');\n      console.info = interceptConsole('info');\n      console.debug = interceptConsole('debug');\n      \n      // Remove dangerous globals\n      delete window.eval;\n      delete window.Function;\n      \n      // Block access to parent\n      try {\n        Object.defineProperty(window, 'parent', {\n          get: function() { return window; },\n          configurable: false\n        });\n        Object.defineProperty(window, 'top', {\n          get: function() { return window; },\n          configurable: false\n        });\n        Object.defineProperty(window, 'frameElement', {\n          get: function() { return null; },\n          configurable: false\n        });\n      } catch (e) {}\n      \n      // Block localStorage and sessionStorage\n      try {\n        Object.defineProperty(window, 'localStorage', {\n          get: function() { throw new Error('localStorage access denied'); },\n          configurable: false\n        });\n        Object.defineProperty(window, 'sessionStorage', {\n          get: function() { throw new Error('sessionStorage access denied'); },\n          configurable: false\n        });\n      } catch (e) {}\n      \n      // Block document access to sensitive APIs\n      if (document) {\n        try {\n          const originalOpen = document.open;\n          document.open = function() {\n            throw new Error('document.open() is not allowed');\n          };\n        } catch (e) {}\n      }\n      \n      // Execute user code with timeout protection\n      let executionResult = null;\n      let executionError = null;\n      let resultSent = false;\n      \n      // Function to send result (only once)\n      function sendResult() {\n        if (resultSent) return;\n        resultSent = true;\n        clearTimeout(timeoutId);\n        window.parent.postMessage({\n          type: 'sandbox-result',\n          logs: interceptedLogs,\n          result: executionResult,\n          error: executionError\n        }, '*');\n      }\n      \n      // Set up timeout protection\n      const MAX_EXECUTION_TIME = 5000; // 5 seconds max\n      const timeoutId = setTimeout(() => {\n        if (!resultSent) {\n          executionError = {\n            message: 'Execution timeout: Possible infinite loop detected',\n            stack: ''\n          };\n          sendResult();\n        }\n      }, MAX_EXECUTION_TIME);\n      \n      // Execute code immediately\n      try {\n        // Wrap user code in IIFE to prevent global pollution\n        // Use script tag injection instead of eval/Function\n        const script = document.createElement('script');\n        const wrappedCode = \\`\n          (function() {\n            'use strict';\n            try {\n              \\${userCode}\n            } catch (err) {\n              window.__sandboxError = {\n                message: err.message,\n                stack: err.stack\n              };\n            }\n          })();\n        \\`;\n        \n        script.textContent = wrappedCode;\n        \n        // Use error handler\n        script.onerror = function(err) {\n          if (!resultSent) {\n            executionError = {\n              message: 'Script execution error: ' + (err.message || 'Unknown error'),\n              stack: ''\n            };\n            sendResult();\n          }\n        };\n        \n        // Append script - executes synchronously\n        document.body.appendChild(script);\n        \n        // Check for errors and send result after script executes\n        // Use setTimeout to ensure script has executed and console logs are captured\n        setTimeout(() => {\n          if (window.__sandboxError) {\n            executionError = window.__sandboxError;\n            delete window.__sandboxError;\n          }\n          \n          // Remove script after execution\n          try {\n            if (script.parentNode) {\n              document.body.removeChild(script);\n            }\n          } catch (e) {}\n          \n          sendResult();\n        }, 100); // Small delay to ensure all console logs are captured\n        \n      } catch (err) {\n        if (!resultSent) {\n          executionError = {\n            message: err.message,\n            stack: err.stack\n          };\n          sendResult();\n        }\n      }\n    })();\n  </script>\n</body>\n</html>\n    `;\n  }, []);\n\n  const executeCode = useCallback((code, onResult) => {\n    if (!iframeRef.current) {\n      onResult({ error: 'Sandbox not initialized' });\n      return;\n    }\n\n    // Clear any existing timeout\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    // Set up timeout for infinite loop protection\n    timeoutRef.current = setTimeout(() => {\n      onResult({\n        error: 'Execution timeout: Code execution exceeded maximum time limit (5 seconds). Possible infinite loop detected.',\n        logs: []\n      });\n    }, 5000);\n\n    // Set up message listener FIRST, before loading iframe\n    let messageHandler = null;\n    let handlerRemoved = false;\n    \n    messageHandler = (event) => {\n      // Verify message is from our iframe (basic security check)\n      if (event.data && event.data.type === 'sandbox-result') {\n        if (!handlerRemoved) {\n          handlerRemoved = true;\n          clearTimeout(timeoutRef.current);\n          window.removeEventListener('message', messageHandler);\n          onResult({\n            logs: event.data.logs || [],\n            result: event.data.result,\n            error: event.data.error ? event.data.error.message : null\n          });\n        }\n      }\n    };\n\n    window.addEventListener('message', messageHandler);\n\n    // Load sandbox content\n    try {\n      const sandboxHTML = createSandboxHTML(code);\n      const blob = new Blob([sandboxHTML], { type: 'text/html' });\n      const url = URL.createObjectURL(blob);\n      \n      // Set iframe src immediately - message handler is already set up\n      if (iframeRef.current) {\n        iframeRef.current.src = url;\n        \n        // Clean up blob URL after loading\n        iframeRef.current.onload = () => {\n          setTimeout(() => URL.revokeObjectURL(url), 1000);\n        };\n      }\n    } catch (err) {\n      if (!handlerRemoved && messageHandler) {\n        handlerRemoved = true;\n        clearTimeout(timeoutRef.current);\n        window.removeEventListener('message', messageHandler);\n      }\n      onResult({\n        error: `Failed to initialize sandbox: ${err.message}`,\n        logs: []\n      });\n    }\n  }, [createSandboxHTML]);\n\n  // Initialize iframe\n  useEffect(() => {\n    if (!iframeRef.current) {\n      return;\n    }\n\n    // Set sandbox attributes for maximum isolation\n    iframeRef.current.setAttribute('sandbox', 'allow-scripts');\n    iframeRef.current.style.display = 'none';\n  }, []);\n\n  return { iframeRef, executeCode };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}