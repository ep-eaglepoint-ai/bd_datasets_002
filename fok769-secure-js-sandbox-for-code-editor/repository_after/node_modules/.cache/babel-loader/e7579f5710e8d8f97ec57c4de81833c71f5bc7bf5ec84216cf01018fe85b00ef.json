{"ast":null,"code":"import{useRef,useEffect,useCallback}from'react';/**\n * Secure JavaScript Sandbox Component\n * \n * Uses iframe with sandbox attributes to isolate user code execution.\n * Prevents access to parent window, document, localStorage, and other browser APIs.\n * Intercepts console methods and restores them after execution.\n * Handles infinite loops with timeout protection.\n */export function useSecureSandbox(){const iframeRef=useRef(null);const timeoutRef=useRef(null);// Create sandbox HTML content that will be loaded in iframe\nconst createSandboxHTML=useCallback(userCode=>{return\"\\n<!DOCTYPE html>\\n<html>\\n<head>\\n  <meta charset=\\\"utf-8\\\">\\n  <title>Sandbox</title>\\n</head>\\n<body>\\n  <script>\\n    (function() {\\n      'use strict';\\n      \\n      // Backup original console methods\\n      const consoleBackup = {\\n        log: console.log,\\n        error: console.error,\\n        warn: console.warn,\\n        info: console.info,\\n        debug: console.debug\\n      };\\n      \\n      // Intercept console methods\\n      const interceptedLogs = [];\\n      const interceptConsole = (method) => {\\n        return function(...args) {\\n          interceptedLogs.push({\\n            type: method,\\n            message: args.map(arg => {\\n              if (typeof arg === 'object') {\\n                try {\\n                  return JSON.stringify(arg, null, 2);\\n                } catch (e) {\\n                  return String(arg);\\n                }\\n              }\\n              return String(arg);\\n            }).join(' ')\\n          });\\n          // Also call original to see in iframe console for debugging\\n          consoleBackup[method].apply(console, args);\\n        };\\n      };\\n      \\n      console.log = interceptConsole('log');\\n      console.error = interceptConsole('error');\\n      console.warn = interceptConsole('warn');\\n      console.info = interceptConsole('info');\\n      console.debug = interceptConsole('debug');\\n      \\n      // Remove dangerous globals\\n      delete window.eval;\\n      delete window.Function;\\n      \\n      // Block access to parent\\n      try {\\n        Object.defineProperty(window, 'parent', {\\n          get: function() { return window; },\\n          configurable: false\\n        });\\n        Object.defineProperty(window, 'top', {\\n          get: function() { return window; },\\n          configurable: false\\n        });\\n        Object.defineProperty(window, 'frameElement', {\\n          get: function() { return null; },\\n          configurable: false\\n        });\\n      } catch (e) {}\\n      \\n      // Block localStorage and sessionStorage\\n      try {\\n        Object.defineProperty(window, 'localStorage', {\\n          get: function() { throw new Error('localStorage access denied'); },\\n          configurable: false\\n        });\\n        Object.defineProperty(window, 'sessionStorage', {\\n          get: function() { throw new Error('sessionStorage access denied'); },\\n          configurable: false\\n        });\\n      } catch (e) {}\\n      \\n      // Block document access to sensitive APIs\\n      if (document) {\\n        try {\\n          const originalOpen = document.open;\\n          document.open = function() {\\n            throw new Error('document.open() is not allowed');\\n          };\\n        } catch (e) {}\\n      }\\n      \\n      // Execute user code with timeout protection\\n      let executionResult = null;\\n      let executionError = null;\\n      \\n      // Set up timeout protection\\n      const startTime = Date.now();\\n      const MAX_EXECUTION_TIME = 5000; // 5 seconds max\\n      const timeoutId = setTimeout(() => {\\n        executionError = {\\n          message: 'Execution timeout: Possible infinite loop detected',\\n          stack: ''\\n        };\\n        window.parent.postMessage({\\n          type: 'sandbox-result',\\n          logs: interceptedLogs,\\n          result: null,\\n          error: executionError\\n        }, '*');\\n      }, MAX_EXECUTION_TIME);\\n      \\n      // Use setTimeout to make execution interruptible (helps with some infinite loops)\\n      setTimeout(() => {\\n        try {\\n          // Wrap user code in IIFE to prevent global pollution\\n          // Use script tag injection instead of eval/Function\\n          const script = document.createElement('script');\\n          const wrappedCode = `\\n            (function() {\\n              'use strict';\\n              try {\\n                ${userCode}\\n              } catch (err) {\\n                window.__sandboxError = {\\n                  message: err.message,\\n                  stack: err.stack\\n                };\\n              }\\n            })();\\n          `;\\n          \\n          script.textContent = wrappedCode;\\n          \\n          // Use error handler\\n          script.onerror = function(err) {\\n            executionError = {\\n              message: 'Script execution error: ' + (err.message || 'Unknown error'),\\n              stack: ''\\n            };\\n            clearTimeout(timeoutId);\\n            sendResult();\\n          };\\n          \\n          document.body.appendChild(script);\\n          \\n          // Script executes synchronously when appended\\n          // Check for errors after a brief moment\\n          setTimeout(() => {\\n            if (window.__sandboxError) {\\n              executionError = window.__sandboxError;\\n              delete window.__sandboxError;\\n            }\\n            \\n            // Remove script after execution\\n            try {\\n              if (script.parentNode) {\\n                document.body.removeChild(script);\\n              }\\n            } catch (e) {}\\n            \\n            clearTimeout(timeoutId);\\n            sendResult();\\n          }, 10);\\n          \\n        } catch (err) {\\n          executionError = {\\n            message: err.message,\\n            stack: err.stack\\n          };\\n          clearTimeout(timeoutId);\\n          sendResult();\\n        }\\n      }, 0);\\n      \\n      // Function to send result\\n      function sendResult() {\\n        window.parent.postMessage({\\n          type: 'sandbox-result',\\n          logs: interceptedLogs,\\n          result: executionResult,\\n          error: executionError\\n        }, '*');\\n      }\\n    })();\\n  </script>\\n</body>\\n</html>\\n    \";},[]);const executeCode=useCallback((code,onResult)=>{if(!iframeRef.current){onResult({error:'Sandbox not initialized'});return;}// Clear any existing timeout\nif(timeoutRef.current){clearTimeout(timeoutRef.current);}// Set up timeout for infinite loop protection\ntimeoutRef.current=setTimeout(()=>{onResult({error:'Execution timeout: Code execution exceeded maximum time limit (5 seconds). Possible infinite loop detected.',logs:[]});},5000);// Set up message listener\nconst messageHandler=event=>{// Verify message is from our iframe (basic security check)\nif(event.data&&event.data.type==='sandbox-result'){clearTimeout(timeoutRef.current);window.removeEventListener('message',messageHandler);onResult({logs:event.data.logs||[],result:event.data.result,error:event.data.error?event.data.error.message:null});}};window.addEventListener('message',messageHandler);// Load sandbox content\ntry{const sandboxHTML=createSandboxHTML(code);const blob=new Blob([sandboxHTML],{type:'text/html'});const url=URL.createObjectURL(blob);iframeRef.current.src=url;// Clean up blob URL after loading\niframeRef.current.onload=()=>{setTimeout(()=>URL.revokeObjectURL(url),1000);};}catch(err){clearTimeout(timeoutRef.current);window.removeEventListener('message',messageHandler);onResult({error:\"Failed to initialize sandbox: \".concat(err.message),logs:[]});}},[createSandboxHTML]);// Initialize iframe\nuseEffect(()=>{if(!iframeRef.current){return;}// Set sandbox attributes for maximum isolation\niframeRef.current.setAttribute('sandbox','allow-scripts');iframeRef.current.style.display='none';},[]);return{iframeRef,executeCode};}","map":{"version":3,"names":["useRef","useEffect","useCallback","useSecureSandbox","iframeRef","timeoutRef","createSandboxHTML","userCode","executeCode","code","onResult","current","error","clearTimeout","setTimeout","logs","messageHandler","event","data","type","window","removeEventListener","result","message","addEventListener","sandboxHTML","blob","Blob","url","URL","createObjectURL","src","onload","revokeObjectURL","err","concat","setAttribute","style","display"],"sources":["/app/repository_after/src/SecureSandbox.js"],"sourcesContent":["import { useRef, useEffect, useCallback } from 'react';\n\n/**\n * Secure JavaScript Sandbox Component\n * \n * Uses iframe with sandbox attributes to isolate user code execution.\n * Prevents access to parent window, document, localStorage, and other browser APIs.\n * Intercepts console methods and restores them after execution.\n * Handles infinite loops with timeout protection.\n */\nexport function useSecureSandbox() {\n  const iframeRef = useRef(null);\n  const timeoutRef = useRef(null);\n\n  // Create sandbox HTML content that will be loaded in iframe\n  const createSandboxHTML = useCallback((userCode) => {\n    return `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Sandbox</title>\n</head>\n<body>\n  <script>\n    (function() {\n      'use strict';\n      \n      // Backup original console methods\n      const consoleBackup = {\n        log: console.log,\n        error: console.error,\n        warn: console.warn,\n        info: console.info,\n        debug: console.debug\n      };\n      \n      // Intercept console methods\n      const interceptedLogs = [];\n      const interceptConsole = (method) => {\n        return function(...args) {\n          interceptedLogs.push({\n            type: method,\n            message: args.map(arg => {\n              if (typeof arg === 'object') {\n                try {\n                  return JSON.stringify(arg, null, 2);\n                } catch (e) {\n                  return String(arg);\n                }\n              }\n              return String(arg);\n            }).join(' ')\n          });\n          // Also call original to see in iframe console for debugging\n          consoleBackup[method].apply(console, args);\n        };\n      };\n      \n      console.log = interceptConsole('log');\n      console.error = interceptConsole('error');\n      console.warn = interceptConsole('warn');\n      console.info = interceptConsole('info');\n      console.debug = interceptConsole('debug');\n      \n      // Remove dangerous globals\n      delete window.eval;\n      delete window.Function;\n      \n      // Block access to parent\n      try {\n        Object.defineProperty(window, 'parent', {\n          get: function() { return window; },\n          configurable: false\n        });\n        Object.defineProperty(window, 'top', {\n          get: function() { return window; },\n          configurable: false\n        });\n        Object.defineProperty(window, 'frameElement', {\n          get: function() { return null; },\n          configurable: false\n        });\n      } catch (e) {}\n      \n      // Block localStorage and sessionStorage\n      try {\n        Object.defineProperty(window, 'localStorage', {\n          get: function() { throw new Error('localStorage access denied'); },\n          configurable: false\n        });\n        Object.defineProperty(window, 'sessionStorage', {\n          get: function() { throw new Error('sessionStorage access denied'); },\n          configurable: false\n        });\n      } catch (e) {}\n      \n      // Block document access to sensitive APIs\n      if (document) {\n        try {\n          const originalOpen = document.open;\n          document.open = function() {\n            throw new Error('document.open() is not allowed');\n          };\n        } catch (e) {}\n      }\n      \n      // Execute user code with timeout protection\n      let executionResult = null;\n      let executionError = null;\n      \n      // Set up timeout protection\n      const startTime = Date.now();\n      const MAX_EXECUTION_TIME = 5000; // 5 seconds max\n      const timeoutId = setTimeout(() => {\n        executionError = {\n          message: 'Execution timeout: Possible infinite loop detected',\n          stack: ''\n        };\n        window.parent.postMessage({\n          type: 'sandbox-result',\n          logs: interceptedLogs,\n          result: null,\n          error: executionError\n        }, '*');\n      }, MAX_EXECUTION_TIME);\n      \n      // Use setTimeout to make execution interruptible (helps with some infinite loops)\n      setTimeout(() => {\n        try {\n          // Wrap user code in IIFE to prevent global pollution\n          // Use script tag injection instead of eval/Function\n          const script = document.createElement('script');\n          const wrappedCode = \\`\n            (function() {\n              'use strict';\n              try {\n                \\${userCode}\n              } catch (err) {\n                window.__sandboxError = {\n                  message: err.message,\n                  stack: err.stack\n                };\n              }\n            })();\n          \\`;\n          \n          script.textContent = wrappedCode;\n          \n          // Use error handler\n          script.onerror = function(err) {\n            executionError = {\n              message: 'Script execution error: ' + (err.message || 'Unknown error'),\n              stack: ''\n            };\n            clearTimeout(timeoutId);\n            sendResult();\n          };\n          \n          document.body.appendChild(script);\n          \n          // Script executes synchronously when appended\n          // Check for errors after a brief moment\n          setTimeout(() => {\n            if (window.__sandboxError) {\n              executionError = window.__sandboxError;\n              delete window.__sandboxError;\n            }\n            \n            // Remove script after execution\n            try {\n              if (script.parentNode) {\n                document.body.removeChild(script);\n              }\n            } catch (e) {}\n            \n            clearTimeout(timeoutId);\n            sendResult();\n          }, 10);\n          \n        } catch (err) {\n          executionError = {\n            message: err.message,\n            stack: err.stack\n          };\n          clearTimeout(timeoutId);\n          sendResult();\n        }\n      }, 0);\n      \n      // Function to send result\n      function sendResult() {\n        window.parent.postMessage({\n          type: 'sandbox-result',\n          logs: interceptedLogs,\n          result: executionResult,\n          error: executionError\n        }, '*');\n      }\n    })();\n  </script>\n</body>\n</html>\n    `;\n  }, []);\n\n  const executeCode = useCallback((code, onResult) => {\n    if (!iframeRef.current) {\n      onResult({ error: 'Sandbox not initialized' });\n      return;\n    }\n\n    // Clear any existing timeout\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    // Set up timeout for infinite loop protection\n    timeoutRef.current = setTimeout(() => {\n      onResult({\n        error: 'Execution timeout: Code execution exceeded maximum time limit (5 seconds). Possible infinite loop detected.',\n        logs: []\n      });\n    }, 5000);\n\n    // Set up message listener\n    const messageHandler = (event) => {\n      // Verify message is from our iframe (basic security check)\n      if (event.data && event.data.type === 'sandbox-result') {\n        clearTimeout(timeoutRef.current);\n        window.removeEventListener('message', messageHandler);\n        onResult({\n          logs: event.data.logs || [],\n          result: event.data.result,\n          error: event.data.error ? event.data.error.message : null\n        });\n      }\n    };\n\n    window.addEventListener('message', messageHandler);\n\n    // Load sandbox content\n    try {\n      const sandboxHTML = createSandboxHTML(code);\n      const blob = new Blob([sandboxHTML], { type: 'text/html' });\n      const url = URL.createObjectURL(blob);\n      iframeRef.current.src = url;\n      \n      // Clean up blob URL after loading\n      iframeRef.current.onload = () => {\n        setTimeout(() => URL.revokeObjectURL(url), 1000);\n      };\n    } catch (err) {\n      clearTimeout(timeoutRef.current);\n      window.removeEventListener('message', messageHandler);\n      onResult({\n        error: `Failed to initialize sandbox: ${err.message}`,\n        logs: []\n      });\n    }\n  }, [createSandboxHTML]);\n\n  // Initialize iframe\n  useEffect(() => {\n    if (!iframeRef.current) {\n      return;\n    }\n\n    // Set sandbox attributes for maximum isolation\n    iframeRef.current.setAttribute('sandbox', 'allow-scripts');\n    iframeRef.current.style.display = 'none';\n  }, []);\n\n  return { iframeRef, executeCode };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}