# WXPAC9 - Medical Appointment Scheduling System with Automated Reminders and Waitlist Management

**Category:** sft

## Overview
- Task ID: WXPAC9
- Title: Medical Appointment Scheduling System with Automated Reminders and Waitlist Management
- Category: sft
- Repository: ep-eaglepoint-ai/bd_datasets_002
- Branch: wxpac9-medical-appointment-scheduling-system-with-automated-reminders-and-waitlist-management

## Requirements
- ### 1. Doctor Directory and Availability Management - The GET /api/doctors endpoint must return all doctors with: id, name, specialty, bio, photo_url, years_of_experience. - The GET /api/doctors/:id/availability?date=YYYY-MM-DD endpoint must return available time slots for a specific doctor on a given date. - Available slots must be calculated by: (1) fetching doctor's schedule for that day_of_week, (2) fetching existing appointments, (3) returning free slots. - When a doctor works 8:00 AM - 6:00 PM with a 30-minute appointment at 9:00 AM, available slots must exclude 9:00-9:30 AM. - Slot calculation must account for appointment duration: a 60-minute slot at 5:30 PM is invalid (extends past 6:00 PM closing). - When a doctor has no schedule entry for a day (e.g., Wednesday off), the endpoint must return an empty array []. - Availability calculation must complete in < 500ms for a single doctor-day query. - The system must support doctor vacation/time-off: when a doctor is marked unavailable for a date range, all slots in that range must be blocked. - Doctors table schema: CREATE TABLE doctors (id SERIAL PRIMARY KEY, name VARCHAR(100), specialty VARCHAR(50), bio TEXT, photo_url VARCHAR(255), created_at TIMESTAMP).  ### 2. Appointment Booking with Concurrent Conflict Prevention - The POST /api/appointments endpoint must accept: {doctor_id, patient_id, start_time (ISO 8601), duration (15|30|60), type ("follow-up"|"standard"|"new-patient")}. - Before creating an appointment, the system must validate: (1) doctor exists, (2) patient exists, (3) start_time is within doctor's working hours, (4) no overlapping appointments exist. - Overlap detection must use a database query: SELECT COUNT(*) FROM appointments WHERE doctor_id = ? AND status != 'cancelled' AND (start_time, start_time + duration * INTERVAL '1 minute') OVERLAPS (?, ? + ? * INTERVAL '1 minute'). - When 2 concurrent requests attempt to book the same slot, exactly 1 must succeed (HTTP 201) and 1 must fail (HTTP 409 Conflict) with error: "Time slot no longer available". - Concurrent conflict prevention must use database-level locking: SELECT ... FOR UPDATE or UNIQUE constraint on (doctor_id, start_time, status) WHERE status != 'cancelled'. - Booking must enforce minimum advance notice: cannot book appointments less than 2 hours from current time (reject with HTTP 400: "Must book at least 2 hours in advance"). - Booking must enforce maximum advance notice: cannot book appointments more than 90 days from current time (reject with HTTP 400: "Cannot book more than 90 days in advance"). - New patient appointments must require 60-minute duration: if type="new-patient" and duration != 60, reject with HTTP 400: "New patient appointments require 60-minute slots". - Appointment creation must complete in < 1 second including all validations and database writes.
- Patient Portal and Appointment Management - The GET /api/patients/:id/appointments endpoint must return all appointments for a patient: upcoming (start_time > now), past (start_time < now), cancelled. - Appointments must be sorted by start_time DESC (most recent first) with pagination: ?page=1&limit=20. - The GET /api/appointments/:id endpoint must return appointment details including: doctor name, specialty, start_time, duration, type, status, cancellation_fee_applied. - The DELETE /api/appointments/:id endpoint must cancel an appointment and apply business rules: (1) if cancelled < 24 hours before start_time, set cancellation_fee_applied = true ($50 fee), (2) if cancelled >= 24 hours before, no fee. - Cancellation must update appointment status to 'cancelled' (soft delete, not physical delete) and set cancelled_at timestamp. - When an appointment is cancelled, the system must trigger a background job to check the waitlist and promote the first waiting patient for that doctor-date-time. - Cancellation must complete in < 500ms (excluding background job execution). - The system must prevent cancelling appointments that are already in progress or completed: if start_time < now, reject with HTTP 400: "Cannot cancel past appointments".  ### 4. Automated Reminder System with Redis Job Queue - The system must use Redis + Celery (or RQ) to schedule reminder jobs when appointments are created. - When an appointment is created, the system must enqueue 2 reminder jobs: (1) email reminder 24 hours before start_time, (2) SMS reminder 2 hours before start_time. - Email reminders must include: patient name, doctor name, appointment date/time, clinic address, cancellation policy link. - SMS reminders must include: "Reminder: Appointment with Dr. {doctor_name} at {time} tomorrow. Reply CANCEL to cancel." - In development mode, reminders must log to console instead of sending actual emails/SMS: "EMAIL SENT: To {email}, Subject: Appointment Reminder, Body: {...}". - Reminder jobs must be idempotent: if a job is retried due to failure, it must not send duplicate reminders (check if reminder_sent flag is set). - Reminder scheduling must account for timezone: all times must be stored in UTC, displayed in clinic's local timezone (configurable, default America/New_York). - When an appointment is cancelled, the system must cancel (delete) the scheduled reminder jobs from Redis queue. - Reminder delivery must be tracked: appointments table must have email_reminder_sent_at and sms_reminder_sent_at columns.
- Waitlist Management and Automatic Promotion - The POST /api/waitlist endpoint must accept: {doctor_id, patient_id, desired_date (YYYY-MM-DD), preferred_time_range ("morning"|"afternoon"|"any")}. - Waitlist entries must be stored with: id, doctor_id, patient_id, desired_date, preferred_time_range, created_at, status ("waiting"|"promoted"|"expired"). - When an appointment is cancelled, a background job must: (1) find waitlist entries for that doctor and date, (2) filter by preferred_time_range if specified, (3) promote the oldest entry (lowest created_at). - Promotion process: (1) create appointment for waitlist patient, (2) update waitlist status to 'promoted', (3) send notification email: "Good news! A slot opened up for Dr. {doctor_name} on {date} at {time}. Your appointment has been booked." - If no waitlist entries match the cancelled slot, do nothing (no promotion). - Waitlist entries must expire after 30 days: a background job runs daily at midnight to mark entries with created_at < now - 30 days as 'expired'. - The GET /api/waitlist/:doctor_id endpoint must return all active waitlist entries for a doctor, sorted by created_at ASC (FIFO order). - Patients must be limited to 3 active waitlist entries at a time: if patient already has 3 entries with status='waiting', reject new entries with HTTP 400: "Maximum 3 waitlist entries allowed".  ### 6. Doctor Schedule Configuration - The schedules table must define doctor working hours: CREATE TABLE schedules (id SERIAL PRIMARY KEY, doctor_id INT, day_of_week INT (0=Sunday, 6=Saturday), start_time TIME, end_time TIME, UNIQUE(doctor_id, day_of_week)). - When calculating availability, the system must query schedules WHERE doctor_id = ? AND day_of_week = EXTRACT(DOW FROM ?::date). - Doctors can have multiple schedule entries per day (e.g., 8:00-12:00 and 13:00-17:00 for lunch break), but slots must only be generated within these ranges. - When a doctor has no schedule entry for a day, they are considered unavailable (no slots returned). - Schedule changes must take effect immediately: updating a schedule entry must not affect existing appointments (appointments are immutable once booked). - The system must support blocking specific dates for doctor vacations: a separate doctor_time_off table with (doctor_id, start_date, end_date, reason).
- Database Schema and Constraints - Doctors table: id, name, specialty, bio, photo_url, created_at. - Patients table: id, name, email, phone, date_of_birth, created_at. - Appointments table: id, doctor_id (FK), patient_id (FK), start_time (TIMESTAMP), duration (INT minutes), type (VARCHAR), status (VARCHAR: 'scheduled'|'completed'|'cancelled'|'no-show'), cancellation_fee_applied (BOOLEAN), email_reminder_sent_at, sms_reminder_sent_at, cancelled_at, created_at. - Schedules table: id, doctor_id (FK), day_of_week (INT 0-6), start_time (TIME), end_time (TIME), UNIQUE(doctor_id, day_of_week). - Waitlist table: id, doctor_id (FK), patient_id (FK), desired_date (DATE), preferred_time_range (VARCHAR), status (VARCHAR: 'waiting'|'promoted'|'expired'), created_at. - Doctor_time_off table: id, doctor_id (FK), start_date (DATE), end_date (DATE), reason (VARCHAR). - Database constraints: UNIQUE constraint on (doctor_id, start_time) WHERE status != 'cancelled' to prevent double-bookings at database level. - All foreign keys must have ON DELETE CASCADE to maintain referential integrity.  ### 8. API Endpoints and Request/Response Formats - GET /api/doctors → Response: [{id, name, specialty, bio, photo_url}, ...], Status: 200. - GET /api/doctors/:id/availability?date=YYYY-MM-DD → Response: {date, slots: [{start_time, end_time, duration}, ...]}, Status: 200. - POST /api/appointments → Request: {doctor_id, patient_id, start_time, duration, type}, Response: {id, doctor_id, patient_id, start_time, duration, type, status}, Status: 201. - GET /api/appointments/:id → Response: {id, doctor: {name, specialty}, patient: {name}, start_time, duration, type, status, cancellation_fee_applied}, Status: 200. - DELETE /api/appointments/:id → Response: {message, cancellation_fee_applied}, Status: 200. - GET /api/patients/:id/appointments?page=1&limit=20 → Response: {appointments: [...], total, page, limit}, Status: 200. - POST /api/waitlist → Request: {doctor_id, patient_id, desired_date, preferred_time_range}, Response: {id, status: "waiting"}, Status: 201. - GET /api/waitlist/:doctor_id → Response: [{id, patient: {name}, desired_date, preferred_time_range, created_at}, ...],
- 9. Frontend React Components and User Flows - DoctorList component: Display all doctors with photo, name, specialty, bio, "Book Appointment" button. - DoctorAvailability component: Show calendar with available dates, time slot picker for selected date, appointment type selector (15/30/60 min). - BookingForm component: Collect patient info (name, email, phone, DOB), confirm booking details, submit to POST /api/appointments. - PatientDashboard component: Show upcoming appointments, past appointments, "Cancel" button (disabled if < 24 hours), "Join Waitlist" button. - WaitlistForm component: Select doctor, desired date, preferred time range (morning/afternoon/any), submit to POST /api/waitlist. - Booking flow: (1) Select doctor → (2) Select date → (3) Select time slot → (4) Enter patient info → (5) Confirm booking → (6) Show confirmation with appointment details. - The frontend must handle concurrent booking conflicts gracefully: if POST /api/appointments returns 409, show error: "This time slot was just booked. Please select another time." - All forms must have client-side validation: email format, phone format (XXX-XXX-XXXX), date_of_birth (must be in past), required fields.  ### 10. Docker Deployment and Environment Configuration - docker-compose.yml must define 4 services: (1) backend (Flask app), (2) frontend (React app), (3) postgres (PostgreSQL 14), (4) redis (Redis 7). - Backend Dockerfile: FROM python:3.11, COPY requirements.txt, RUN pip install -r requirements.txt, COPY app/, CMD ["python", "run.py"]. - Frontend Dockerfile: FROM node:18, COPY package.json, RUN npm install, COPY src/, RUN npm run build, CMD ["npm", "start"]. - PostgreSQL must use a volume for data persistence: volumes: - postgres_data:/var/lib/postgresql/data. - Redis must be configured for job queue: no persistence required (ephemeral). - Environment variables: DATABASE_URL, REDIS_URL, SENDGRID_API_KEY (optional, mock in dev), TWILIO_API_KEY (optional, mock in dev), FLASK_ENV (development|production). - The system must run with a single command: docker-compose up --build, and be accessible at http://localhost:3000 (frontend) and http://localhost:5000 (backend). - Database migrations must run automatically on startup: backend entrypoint must execute flask db upgrade before starting the server.
- Seed Data and Initial Setup - The system must include a seed script (seed.py) that populates: (1) 10 doctors with realistic names, specialties, bios, (2) schedules for all doctors (Mon-Fri 8:00-18:00), (3) 5 sample patients. - Seed data for doctors: 3 General Practice (Dr. Sarah Johnson, Dr. Michael Chen, Dr. Emily Rodriguez), 3 Cardiology (Dr. David Kim, Dr. Lisa Patel, Dr. James Wilson), 2 Dermatology (Dr. Maria Garcia, Dr. Robert Taylor), 2 Pediatrics (Dr. Jennifer Lee, Dr. Christopher Brown). - Seed data for schedules: All doctors work Mon-Fri 8:00-18:00 except Dr. Sarah Johnson (Mon-Thu 9:00-17:00, Fri off). - Seed script must be idempotent: running it multiple times must not create duplicate data (use INSERT ... ON CONFLICT DO NOTHING or check existence before insert). - The seed script must be executed automatically on first startup: backend entrypoint checks if doctors table is empty, runs seed.py if true.  ### 12. Error Handling and Validation - All API endpoints must return appropriate HTTP status codes: 200 (OK), 201 (Created), 400 (Bad Request), 404 (Not Found), 409 (Conflict), 500 (Internal Server Error). - Validation errors must return structured JSON: {error: "Validation failed", details: [{field: "email", message: "Invalid email format"}]}, Status: 400. - When a doctor_id or patient_id does not exist, return: {error: "Doctor not found"}, Status: 404. - When attempting to book an overlapping slot, return: {error: "Time slot no longer available", available_slots: [...]}, Status: 409. - When booking outside working hours, return: {error: "Selected time is outside doctor's working hours", working_hours: {start: "08:00", end: "18:00"}}, Status: 400. - When booking on a closed day (weekend), return: {error: "Doctor is not available on weekends"}, Status: 400. - When booking less than 2 hours in advance, return: {error: "Must book at least 2 hours in advance"}, Status: 400. - When booking more than 90 days in advance, return: {error: "Cannot book more than 90 days in advance"}, Status: 400. - When new patient books 15-min slot, return: {error: "New patient appointments require 60-minute slots"}, Status: 400. - All database errors must be caught and logged, returning: {error: "Internal server error"}, Status: 500 (never expose database details to client).
- Performance and Scalability Requirements - Availability calculation: < 500ms for a single doctor-day query (including database query and slot generation). - Appointment booking: < 1 second for the entire flow (validation + database insert + reminder job enqueue). - Appointment cancellation: < 500ms (excluding background waitlist promotion job). - Patient dashboard load: < 1 second to fetch and render all appointments (with pagination). - Concurrent booking: The system must handle 100 concurrent POST /api/appointments requests without double-bookings (verified by database constraints). - Database connection pool: Minimum 10 connections, maximum 50 connections to handle concurrent requests. - Redis job queue: Must process 1,000 reminder jobs per minute (16.67 jobs/sec) without delays. - Frontend load time: < 2 seconds for initial page load (doctor list), < 1 second for subsequent navigation. - Memory usage: Backend < 512MB, Frontend < 256MB, PostgreSQL < 1GB, Redis < 256MB.  ### 14. Stress Test and Validation Scenarios - Scenario 1: 100 concurrent requests to book the same time slot → exactly 1 succeeds (HTTP 201), 99 fail (HTTP 409). - Scenario 2: Book appointment at 9:00 AM, check availability → 9:00-9:30 AM slot no longer appears in available slots. - Scenario 3: Cancel appointment 48 hours before → cancellation_fee_applied = false, waitlist promoted if exists. - Scenario 4: Cancel appointment 1 hour before → cancellation_fee_applied = true ($50 fee), waitlist promoted if exists. - Scenario 5: New patient attempts to book 15-min slot → rejected with HTTP 400: "New patient appointments require 60-minute slots". - Scenario 6: Attempt to book on Sunday (closed) → rejected with HTTP 400: "Doctor is not available on weekends". - Scenario 7: Attempt to book 1 hour in advance → rejected with HTTP 400: "Must book at least 2 hours in advance". - Scenario 8: Attempt to book 100 days in advance → rejected with HTTP 400: "Cannot book more than 90 days in advance". - Scenario 9: Reminder jobs execute at exact times → email reminder sent 24 hours before, SMS reminder sent 2 hours before (verified by logs). - Scenario 10: Stress test with 1,000 bookings over 5 minutes → zero double-bookings, all reminders scheduled correctly, database integrity maintained.

## Metadata
- Programming Languages: Python, JavaScript
- Frameworks: (none)
- Libraries: (none)
- Databases: (none)
- Tools: (none)
- Best Practices: (none)
- Performance Metrics: (none)
- Security Standards: (none)

## Structure
- repository_before/: baseline code (`__init__.py`)
- repository_after/: optimized code (`__init__.py`)
- tests/: test suite (`__init__.py`)
- evaluation/: evaluation scripts (`evaluation.py`)
- instances/: sample/problem instances (JSON)
- patches/: patches for diffing
- trajectory/: notes or write-up (Markdown)

## Quick start
- Run tests locally: `python -m pytest -q tests`
- With Docker: `docker compose up --build --abort-on-container-exit`
- Add dependencies to `requirements.txt`

## Notes
- Keep commits focused and small.
- Open a PR when ready for review.
