diff --git a/go.mod b/go.mod
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/go.mod
@@ -0,0 +1,3 @@
+module example.com/timingwheel_after
+
+go 1.21
diff --git a/timingwheel/timingwheel.go b/timingwheel/timingwheel.go
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/timingwheel/timingwheel.go
@@ -0,0 +1,398 @@
+package timingwheel
+
+import (
+	"fmt"
+	"sync/atomic"
+	"time"
+)
+
+// Task represents a scheduled task in the timing wheel
+type Task struct {
+	id        string
+	deadline  int64 // absolute deadline in ticks
+	callback  func()
+	bucket    *Bucket
+	prev      *Task
+	next      *Task
+	cancelled bool
+}
+
+// Bucket represents a slot in the timing wheel using a doubly linked list
+type Bucket struct {
+	head *Task
+	tail *Task
+}
+
+// NewBucket creates a new empty bucket
+func NewBucket() *Bucket {
+	return &Bucket{}
+}
+
+// Add adds a task to the bucket (O(1))
+func (b *Bucket) Add(task *Task) {
+	task.bucket = b
+	task.prev = nil
+	task.next = nil
+
+	if b.head == nil {
+		b.head = task
+		b.tail = task
+	} else {
+		task.prev = b.tail
+		b.tail.next = task
+		b.tail = task
+	}
+}
+
+// Remove removes a task from the bucket (O(1))
+func (b *Bucket) Remove(task *Task) {
+	if task.bucket != b {
+		return
+	}
+
+	if task.prev != nil {
+		task.prev.next = task.next
+	} else {
+		b.head = task.next
+	}
+
+	if task.next != nil {
+		task.next.prev = task.prev
+	} else {
+		b.tail = task.prev
+	}
+
+	task.prev = nil
+	task.next = nil
+	task.bucket = nil
+}
+
+// Flush removes all tasks from the bucket and returns them
+func (b *Bucket) Flush() []*Task {
+	var tasks []*Task
+	current := b.head
+	for current != nil {
+		next := current.next
+		current.prev = nil
+		current.next = nil
+		current.bucket = nil
+		tasks = append(tasks, current)
+		current = next
+	}
+	b.head = nil
+	b.tail = nil
+	return tasks
+}
+
+// IsEmpty returns true if the bucket has no tasks
+func (b *Bucket) IsEmpty() bool {
+	return b.head == nil
+}
+
+// WheelLevel represents a single level in the hierarchical timing wheel
+type WheelLevel struct {
+	buckets      []*Bucket
+	numSlots     int
+	ticksPerSlot int64 // how many base ticks each slot represents
+	currentIdx   int
+}
+
+// NewWheelLevel creates a new wheel level
+func NewWheelLevel(numSlots int, ticksPerSlot int64) *WheelLevel {
+	buckets := make([]*Bucket, numSlots)
+	for i := 0; i < numSlots; i++ {
+		buckets[i] = NewBucket()
+	}
+	return &WheelLevel{
+		buckets:      buckets,
+		numSlots:     numSlots,
+		ticksPerSlot: ticksPerSlot,
+		currentIdx:   0,
+	}
+}
+
+// TimingWheel represents the hierarchical timing wheel
+type TimingWheel struct {
+	levels        []*WheelLevel
+	tickDuration  time.Duration    // duration of one tick (base resolution)
+	currentTicks  int64            // current virtual time in ticks
+	overflow      []*Task          // overflow list for tasks beyond wheel capacity
+	totalCapacity int64            // total capacity of all wheels in ticks
+	taskCounter   uint64           // for generating unique task IDs
+	tasks         map[string]*Task // map of task ID to task for O(1) cancellation
+	pendingExec   []*Task          // tasks pending immediate execution
+}
+
+// Config holds configuration for the timing wheel
+type Config struct {
+	TickDuration time.Duration // base tick duration (e.g., 1ms)
+	WheelSizes   []int         // number of slots per level (e.g., [100, 60, 60, 24])
+}
+
+// DefaultConfig returns a default configuration
+func DefaultConfig() Config {
+	return Config{
+		TickDuration: time.Millisecond,
+		WheelSizes:   []int{100, 60, 60, 60},
+	}
+}
+
+// New creates a new hierarchical timing wheel
+func New(config Config) *TimingWheel {
+	if config.TickDuration <= 0 {
+		config.TickDuration = time.Millisecond
+	}
+	if len(config.WheelSizes) == 0 {
+		config.WheelSizes = []int{100, 60, 60, 60}
+	}
+
+	tw := &TimingWheel{
+		levels:       make([]*WheelLevel, len(config.WheelSizes)),
+		tickDuration: config.TickDuration,
+		currentTicks: 0,
+		overflow:     make([]*Task, 0),
+		tasks:        make(map[string]*Task),
+		pendingExec:  make([]*Task, 0),
+	}
+
+	// Create wheel levels with increasing tick multipliers
+	ticksPerSlot := int64(1)
+	for i, size := range config.WheelSizes {
+		tw.levels[i] = NewWheelLevel(size, ticksPerSlot)
+		ticksPerSlot *= int64(size)
+	}
+
+	// Total capacity is the product of all wheel sizes
+	tw.totalCapacity = ticksPerSlot
+
+	return tw
+}
+
+// generateID generates a unique task ID
+func (tw *TimingWheel) generateID() string {
+	id := atomic.AddUint64(&tw.taskCounter, 1)
+	return fmt.Sprintf("task-%d", id)
+}
+
+// Schedule schedules a task to be executed after the given delay
+// Returns a cancel ID that can be used to cancel the task
+func (tw *TimingWheel) Schedule(delay time.Duration, callback func()) string {
+	if delay < 0 {
+		delay = 0
+	}
+
+	// Convert delay to ticks, rounding UP to ensure we never fire early
+	var delayTicks int64
+	if delay == 0 {
+		delayTicks = 0
+	} else {
+		delayTicks = int64((delay + tw.tickDuration - 1) / tw.tickDuration)
+		if delayTicks == 0 {
+			delayTicks = 1
+		}
+	}
+
+	// Calculate absolute deadline
+	deadline := tw.currentTicks + delayTicks
+
+	task := &Task{
+		id:       tw.generateID(),
+		deadline: deadline,
+		callback: callback,
+	}
+
+	tw.tasks[task.id] = task
+	tw.insertTask(task)
+
+	return task.id
+}
+
+// insertTask inserts a task into the appropriate wheel level based on remaining time
+func (tw *TimingWheel) insertTask(task *Task) {
+	if task.cancelled {
+		return
+	}
+
+	remainingTicks := task.deadline - tw.currentTicks
+
+	// If deadline has passed or is now, add to pending execution
+	if remainingTicks <= 0 {
+		tw.pendingExec = append(tw.pendingExec, task)
+		return
+	}
+
+	// Check if it exceeds total capacity -> overflow
+	if remainingTicks >= tw.totalCapacity {
+		tw.overflow = append(tw.overflow, task)
+		return
+	}
+
+	// Find the appropriate wheel level
+	tw.insertTaskToWheel(task, remainingTicks)
+}
+
+// insertTaskToWheel inserts a task directly into the wheel
+func (tw *TimingWheel) insertTaskToWheel(task *Task, remainingTicks int64) {
+	for i, level := range tw.levels {
+		levelCapacity := int64(level.numSlots) * level.ticksPerSlot
+
+		if remainingTicks < levelCapacity {
+			// Calculate slot index relative to current position
+			slotOffset := remainingTicks / level.ticksPerSlot
+
+			if i == 0 {
+				// For level 0, place in the exact slot
+				targetIdx := (level.currentIdx + int(slotOffset)) % level.numSlots
+				level.buckets[targetIdx].Add(task)
+			} else {
+				// For higher levels, ensure we don't put in current slot (it would be missed)
+				if slotOffset == 0 {
+					slotOffset = 1
+				}
+				targetIdx := (level.currentIdx + int(slotOffset)) % level.numSlots
+				level.buckets[targetIdx].Add(task)
+			}
+			return
+		}
+	}
+
+	// Fallback - should not reach here if remainingTicks < totalCapacity
+	tw.overflow = append(tw.overflow, task)
+}
+
+// Cancel cancels a scheduled task by its ID
+// Returns true if the task was found and cancelled
+func (tw *TimingWheel) Cancel(id string) bool {
+	task, exists := tw.tasks[id]
+	if !exists {
+		return false
+	}
+
+	task.cancelled = true
+
+	if task.bucket != nil {
+		task.bucket.Remove(task)
+	}
+
+	delete(tw.tasks, id)
+	return true
+}
+
+// Advance advances the virtual clock by the given duration
+// This processes cascading logic and executes expired tasks
+func (tw *TimingWheel) Advance(duration time.Duration) {
+	if duration <= 0 {
+		return
+	}
+
+	// Convert duration to ticks
+	ticks := int64(duration / tw.tickDuration)
+	if ticks == 0 && duration > 0 {
+		ticks = 1
+	}
+
+	// Process one tick at a time to ensure correct cascading
+	for i := int64(0); i < ticks; i++ {
+		tw.tick()
+	}
+}
+
+// tick advances the wheel by one tick
+func (tw *TimingWheel) tick() {
+	tw.currentTicks++
+
+	// First, check overflow and move tasks that now fit into the wheel
+	tw.processOverflow()
+
+	// Execute any pending tasks from previous operations
+	tw.executePending()
+
+	// Process lowest level first - advance index and execute ready tasks
+	level0 := tw.levels[0]
+	level0.currentIdx = (level0.currentIdx + 1) % level0.numSlots
+
+	// Execute all tasks in the current slot of level 0
+	tasks := level0.buckets[level0.currentIdx].Flush()
+	for _, task := range tasks {
+		if !task.cancelled {
+			delete(tw.tasks, task.id)
+			task.callback()
+		}
+	}
+
+	// Check if we need to cascade from higher levels
+	tw.processCascading()
+
+	// Execute any tasks that became pending during cascading
+	tw.executePending()
+}
+
+// executePending executes all pending tasks
+func (tw *TimingWheel) executePending() {
+	if len(tw.pendingExec) == 0 {
+		return
+	}
+
+	pending := tw.pendingExec
+	tw.pendingExec = make([]*Task, 0)
+
+	for _, task := range pending {
+		if !task.cancelled {
+			delete(tw.tasks, task.id)
+			task.callback()
+		}
+	}
+}
+
+// processCascading handles the cascading of tasks from higher levels to lower levels
+func (tw *TimingWheel) processCascading() {
+	// Check each level starting from level 1
+	for i := 1; i < len(tw.levels); i++ {
+		prevLevel := tw.levels[i-1]
+		currLevel := tw.levels[i]
+
+		// Check if the previous level wrapped around (went back to 0)
+		if prevLevel.currentIdx == 0 {
+			// Advance current level's index
+			currLevel.currentIdx = (currLevel.currentIdx + 1) % currLevel.numSlots
+
+			// Cascade tasks from current slot down to lower levels
+			tasks := currLevel.buckets[currLevel.currentIdx].Flush()
+			for _, task := range tasks {
+				if !task.cancelled {
+					// Re-insert based on remaining time (deadline - currentTicks)
+					tw.insertTask(task)
+				}
+			}
+		} else {
+			// No wrap, stop cascading up
+			break
+		}
+	}
+}
+
+// processOverflow moves tasks from overflow to wheels when they fit
+func (tw *TimingWheel) processOverflow() {
+	if len(tw.overflow) == 0 {
+		return
+	}
+
+	remaining := make([]*Task, 0, len(tw.overflow))
+
+	for _, task := range tw.overflow {
+		if task.cancelled {
+			continue
+		}
+
+		remainingTicks := task.deadline - tw.currentTicks
+
+		if remainingTicks <= 0 {
+			// Should execute now
+			tw.pendingExec = append(tw.pendingExec, task)
+		} else if remainingTicks < tw.totalCapacity {
+			// Can now fit in the wheel
+			tw.insertTaskToWheel(task, remainingTicks)
+		} else {
+			// Still too far, keep in overflow
+			remaining = append(remaining, task)
+		}
+	}
+
+	tw.overflow = remaining
+}
+
+// GetCurrentTime returns the current virtual time
+func (tw *TimingWheel) GetCurrentTime() time.Duration {
+	return time.Duration(tw.currentTicks) * tw.tickDuration
+}
+
+// GetCurrentTicks returns the current tick count
+func (tw *TimingWheel) GetCurrentTicks() int64 {
+	return tw.currentTicks
+}
+
+// GetTickDuration returns the base tick duration
+func (tw *TimingWheel) GetTickDuration() time.Duration {
+	return tw.tickDuration
+}
+
+// GetTotalCapacity returns the total capacity of the wheel in ticks
+func (tw *TimingWheel) GetTotalCapacity() int64 {
+	return tw.totalCapacity
+}
+
+// GetPendingTaskCount returns the number of pending tasks
+func (tw *TimingWheel) GetPendingTaskCount() int {
+	return len(tw.tasks)
+}
+
+// HasOverflowTasks returns true if there are tasks in the overflow list
+func (tw *TimingWheel) HasOverflowTasks() bool {
+	return len(tw.overflow) > 0
+}