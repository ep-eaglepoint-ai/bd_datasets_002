{
    "instance_id": "92UEZA",
    "problem_statement": "In embedded networking, data is a continuous stream, not discrete packets. A major failure mode for mid-tier AI is treating the input of a socket read as a single, complete message. The problem requires a \"Holding Buffer\" pattern: data is appended to a buffer, and a loop repeatedly checks if enough bytes exist to parse a header, then the length, then the payload. If not, it waits for more data. This requires managing an internal cursor or slicing bytes. Additionally, the protocol involves mixed-type decoding based on a bit-flag (MSB of a byte) and a custom XOR checksum, which tests the model's ability to manipulate binary data beyond simple text parsing",
    "base_commit": "repository_before/",
    "test_patch": "tests/",
    "github_url": "https://github.com/ep-eaglepoint-ai/bd_datasets_002/tree/main/92ueza-stream-reassembly-with-bitwise-control-logic-and-xor-integrity",
    "environment_setup": "Dockerfile",
    "FAIL_TO_PASS": [],
    "PASS_TO_PASS": [
        "tests/test_stream_parser.py::TestFragmentedReassembly::test_header_in_first_chunk_payload_in_second",
        "tests/test_stream_parser.py::TestFragmentedReassembly::test_split_in_middle_of_payload",
        "tests/test_stream_parser.py::TestFragmentedReassembly::test_single_byte_at_a_time",
        "tests/test_stream_parser.py::TestFragmentedReassembly::test_sync_marker_split_across_chunks",
        "tests/test_stream_parser.py::TestFragmentedReassembly::test_checksum_byte_in_separate_chunk",
        "tests/test_stream_parser.py::TestChecksumRecovery::test_corrupted_frame_followed_by_valid",
        "tests/test_stream_parser.py::TestChecksumRecovery::test_corruption_does_not_clear_buffer",
        "tests/test_stream_parser.py::TestChecksumRecovery::test_multiple_corrupted_frames_before_valid",
        "tests/test_stream_parser.py::TestChecksumRecovery::test_no_crash_on_all_corrupt_data",
        "tests/test_stream_parser.py::TestChecksumRecovery::test_valid_frame_embedded_in_garbage",
        "tests/test_stream_parser.py::TestBitwiseControlDecode::test_msb_set_is_alarm",
        "tests/test_stream_parser.py::TestBitwiseControlDecode::test_msb_set_with_other_bits",
        "tests/test_stream_parser.py::TestBitwiseControlDecode::test_msb_set_0xFF",
        "tests/test_stream_parser.py::TestBitwiseControlDecode::test_msb_clear_is_telemetry",
        "tests/test_stream_parser.py::TestBitwiseControlDecode::test_msb_clear_with_other_bits",
        "tests/test_stream_parser.py::TestBitwiseControlDecode::test_control_0x01_is_telemetry",
        "tests/test_stream_parser.py::TestBitwiseControlDecode::test_source_uses_bitmask_not_equality",
        "tests/test_stream_parser.py::TestBigEndianParsing::test_length_is_big_endian",
        "tests/test_stream_parser.py::TestBigEndianParsing::test_float_value_big_endian",
        "tests/test_stream_parser.py::TestBigEndianParsing::test_multiple_floats_big_endian",
        "tests/test_stream_parser.py::TestBigEndianParsing::test_large_payload_length_big_endian",
        "tests/test_stream_parser.py::TestBigEndianParsing::test_source_uses_big_endian_format",
        "tests/test_stream_parser.py::TestXORChecksum::test_xor_checksum_simple",
        "tests/test_stream_parser.py::TestXORChecksum::test_xor_checksum_single_byte",
        "tests/test_stream_parser.py::TestXORChecksum::test_xor_checksum_empty",
        "tests/test_stream_parser.py::TestXORChecksum::test_xor_checksum_all_same",
        "tests/test_stream_parser.py::TestXORChecksum::test_xor_checksum_all_same_odd",
        "tests/test_stream_parser.py::TestXORChecksum::test_frame_rejected_on_wrong_checksum",
        "tests/test_stream_parser.py::TestXORChecksum::test_frame_accepted_on_correct_checksum",
        "tests/test_stream_parser.py::TestXORChecksum::test_source_uses_xor_operator",
        "tests/test_stream_parser.py::TestBufferEfficiency::test_buffer_is_bytearray",
        "tests/test_stream_parser.py::TestBufferEfficiency::test_buffer_after_feed_is_bytearray",
        "tests/test_stream_parser.py::TestBufferEfficiency::test_buffer_clears_after_complete_frame",
        "tests/test_stream_parser.py::TestBufferEfficiency::test_buffer_retains_incomplete_data",
        "tests/test_stream_parser.py::TestHeartbeat::test_heartbeat_frame",
        "tests/test_stream_parser.py::TestHeartbeat::test_heartbeat_with_msb_set",
        "tests/test_stream_parser.py::TestMultipleFrames::test_three_frames_in_one_feed",
        "tests/test_stream_parser.py::TestMultipleFrames::test_mixed_valid_and_corrupt_in_stream",
        "tests/test_stream_parser.py::TestEdgeCases::test_empty_feed",
        "tests/test_stream_parser.py::TestEdgeCases::test_only_garbage",
        "tests/test_stream_parser.py::TestEdgeCases::test_only_sync_marker",
        "tests/test_stream_parser.py::TestEdgeCases::test_reset_clears_state",
        "tests/test_stream_parser.py::TestEdgeCases::test_get_frames_returns_all_parsed",
        "tests/test_stream_parser.py::TestEdgeCases::test_false_sync_in_payload"
    ]
}
