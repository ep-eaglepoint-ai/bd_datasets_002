--- repository_before/process_sales.py	2026-01-22 16:21:00.278034923 +0300
+++ repository_after/process_sales.py	2026-01-22 17:13:48.629674975 +0300
@@ -3,50 +3,95 @@
 from datetime import datetime
 
 def calculate_discounts(transactions_df, customer_tiers_df, tax_rates_df):
-    for idx, row in transactions_df.iterrows():
-        customer_id = row['customer_id']
-        
-        tier_row = customer_tiers_df[customer_tiers_df['customer_id'] == customer_id]
-        if len(tier_row) > 0:
-            tier = tier_row.iloc[0]['tier']
-        else:
-            tier = 'bronze'
-        
-        if tier == 'platinum':
-            discount_rate = 0.20
-        elif tier == 'gold':
-            discount_rate = 0.15
-        elif tier == 'silver':
-            discount_rate = 0.10
-        else:
-            discount_rate = 0.05
-        
-        if row['quantity'] >= 10:
-            discount_rate = discount_rate + 0.05
-        
-        transactions_df.loc[idx, 'discount_rate'] = discount_rate
-        
-        base_price = row['product_price'] * row['quantity']
-        discount_amount_unrounded = base_price * discount_rate
-        subtotal_unrounded = base_price - discount_amount_unrounded
-        
-        transactions_df.loc[idx, 'discount_amount'] = round(discount_amount_unrounded, 2)
-        transactions_df.loc[idx, 'subtotal'] = round(subtotal_unrounded, 2)
-        
-        state = row['state']
-        tax_row = tax_rates_df[tax_rates_df['state'] == state]
-        if len(tax_row) > 0:
-            tax_rate = tax_row.iloc[0]['tax_rate']
-        else:
-            tax_rate = 0.0
-        
-        tax_amount_unrounded = subtotal_unrounded * tax_rate
-        final_price_unrounded = subtotal_unrounded + tax_amount_unrounded
-        
-        transactions_df.loc[idx, 'tax_amount'] = round(tax_amount_unrounded, 2)
-        transactions_df.loc[idx, 'final_price'] = round(final_price_unrounded, 2)
+    """
+    Calculate discounts, taxes, and final prices for transactions using vectorized operations.
     
-    return transactions_df
+    Args:
+        transactions_df: DataFrame with columns: order_id, customer_id, product_price, quantity, state
+        customer_tiers_df: DataFrame with columns: customer_id, tier (may have duplicates - use first)
+        tax_rates_df: DataFrame with columns: state, tax_rate (may have duplicates - use first)
+    
+    Returns:
+        DataFrame with original columns plus: discount_rate, discount_amount, subtotal, tax_amount, final_price
+    """
+    # Create a copy to avoid modifying the input
+    result_df = transactions_df.copy()
+    
+    # Handle duplicate keys in lookup tables - keep only first occurrence
+    # This prevents row explosion in merge operations
+    customer_tiers_df_clean = customer_tiers_df.drop_duplicates(subset=['customer_id'], keep='first').copy()
+    tax_rates_df_clean = tax_rates_df.drop_duplicates(subset=['state'], keep='first').copy()
+    
+    # Create tier to discount rate mapping
+    tier_discount_map = {
+        'platinum': 0.20,
+        'gold': 0.15,
+        'silver': 0.10,
+        'bronze': 0.05
+    }
+    
+    # Merge customer tiers (left join to preserve all transactions)
+    # Default to 'bronze' for missing customers
+    result_df = result_df.merge(
+        customer_tiers_df_clean[['customer_id', 'tier']],
+        on='customer_id',
+        how='left'
+    )
+    result_df['tier'] = result_df['tier'].fillna('bronze')
+    
+    # Map tier to base discount rate using vectorized operation
+    result_df['discount_rate'] = result_df['tier'].map(tier_discount_map).fillna(0.05)
+    
+    # Add bulk bonus (5%) for quantity >= 10 (vectorized)
+    bulk_bonus = (result_df['quantity'] >= 10).astype(float) * 0.05
+    result_df['discount_rate'] = result_df['discount_rate'] + bulk_bonus
+    
+    # Calculate base price (vectorized)
+    base_price = result_df['product_price'] * result_df['quantity']
+    
+    # Calculate discount amount (unrounded intermediate)
+    discount_amount_unrounded = base_price * result_df['discount_rate']
+    
+    # Calculate subtotal (unrounded intermediate)
+    subtotal_unrounded = base_price - discount_amount_unrounded
+    
+    # Merge tax rates (left join to preserve all transactions)
+    # Default to 0.0 for missing states
+    result_df = result_df.merge(
+        tax_rates_df_clean[['state', 'tax_rate']],
+        on='state',
+        how='left'
+    )
+    result_df['tax_rate'] = result_df['tax_rate'].fillna(0.0)
+    
+    # Calculate tax amount using unrounded subtotal (vectorized)
+    tax_amount_unrounded = subtotal_unrounded * result_df['tax_rate']
+    
+    # Calculate final price using unrounded values (vectorized)
+    final_price_unrounded = subtotal_unrounded + tax_amount_unrounded
+    
+    # Round only final values to 2 decimal places
+    result_df['discount_amount'] = discount_amount_unrounded.round(2)
+    result_df['subtotal'] = subtotal_unrounded.round(2)
+    result_df['tax_amount'] = tax_amount_unrounded.round(2)
+    result_df['final_price'] = final_price_unrounded.round(2)
+    
+    # Drop temporary columns (tier, tax_rate) to match expected output schema
+    result_df = result_df.drop(columns=['tier', 'tax_rate'])
+    
+    # Ensure column order matches specification exactly
+    expected_columns = ['order_id', 'customer_id', 'product_price', 'quantity', 'state', 
+                       'discount_rate', 'discount_amount', 'subtotal', 'tax_amount', 'final_price']
+    
+    # Verify all expected columns exist
+    missing_columns = set(expected_columns) - set(result_df.columns)
+    if missing_columns:
+        raise ValueError(f"Missing required columns: {missing_columns}")
+    
+    # Reorder columns to match specification
+    result_df = result_df[expected_columns]
+    
+    return result_df
 
 
 def load_and_process_sales(transactions_file, customers_file, tax_rates_file):
@@ -76,4 +121,3 @@
     )
     result.to_csv('data/processed_sales.csv', index=False)
     print("Results saved to processed_sales.csv")
-
