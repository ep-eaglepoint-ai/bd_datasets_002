# 3YFXDO - Thread-Safe gRPC Service for Distributed State Management

**Category:** sft

## Overview
- Task ID: 3YFXDO
- Title: Thread-Safe gRPC Service for Distributed State Management
- Category: sft
- Repository: ep-eaglepoint-ai/bd_datasets_002
- Branch: 3yfxdo-thread-safe-grpc-service-for-distributed-state-management

## Requirements
- Thread-Safe Account Creation - The CreateAccount operation must be protected by a write lock on the accounts map to prevent concurrent map writes. - When 100 goroutines attempt to create 100 different accounts simultaneously, all 100 accounts must be created successfully with no panics or data corruption. - When 2 goroutines attempt to create the same account ID simultaneously, exactly one must succeed with status code OK, and the other must fail with status code ALREADY_EXISTS. - Account creation must complete in < 10ms at p99 when there are < 50 concurrent operations. - When creating an account with initial_balance < 0, the operation must fail with status code INVALID_ARGUMENT and error message: "Initial balance cannot be negative". - Each account creation must be logged to the transaction log with operation="create", timestamp, account_id, and initial_balance. - The transaction log append must be protected by a separate lock (logMu) to avoid blocking account operations unnecessarily.
- Thread-Safe Balance Reads (GetBalance) - The GetBalance operation must use RWMutex.RLock() to allow concurrent reads without blocking other readers. - When 1000 goroutines call GetBalance on the same account simultaneously, all must complete successfully within 100ms total (< 0.1ms per call). - GetBalance must NOT block concurrent GetBalance calls on the same or different accounts. - GetBalance must NOT block concurrent GetBalance calls even when UpdateBalance is waiting for a write lock (readers should not be starved). - When an account does not exist, GetBalance must return status code NOT_FOUND with error message: "Account {account_id} not found". - GetBalance must return the most recent committed balance (read-your-writes consistency for the calling goroutine). - Balance reads must complete in < 5ms at p99 under normal load (< 100 concurrent operations).
- Thread-Safe Balance Updates (UpdateBalance) - The UpdateBalance operation must implement atomic read-modify-write using a write lock on the specific account. - When 100 goroutines each add $10 to an account with initial balance $1000, the final balance must be exactly $2000 (no lost updates). - The operation must follow this sequence under lock: (1) read current balance, (2) compute new balance, (3) write new balance, (4) increment version. - When updating an account that doesn't exist, the operation must fail with status code NOT_FOUND and error message: "Account {account_id} not found". - When an update would result in a negative balance (balance + delta < 0), the operation must fail with status code FAILED_PRECONDITION and error message: "Insufficient balance: current={current}, delta={delta}". - UpdateBalance must complete in < 20ms at p99 under normal load (< 100 concurrent operations). - Each successful update must be logged to the transaction log with operation="update", timestamp, account_id, delta, and new_balance.
- Idempotency for Updates - Each UpdateBalance and TransferFunds request must include a unique transaction_id string. - Before processing any operation, the system must check if the transaction_id has been processed before. - The transaction ID check and insert must be atomic: lock txIDsMu, check if ID exists, insert if not, unlock. - When a transaction_id is submitted twice, the second request must return the same response as the first (idempotent) without applying the operation again. - When 10 goroutines submit the same transaction_id simultaneously, exactly 1 must process the operation and 9 must return the cached result. - The txIDs map must be protected by RWMutex: RLock for checking existence, Lock for inserting new IDs. - Transaction ID validation must add < 2ms overhead per operation.
- Atomic Fund Transfers - The TransferFunds operation must atomically deduct from source account and add to destination account, or fail with no changes to either. - When transferring $50 from account A (balance $100) to account B (balance $200), the final state must be A=$50, B=$250, with no intermediate state visible to other goroutines. - When a transfer would cause the source account to go negative, the operation must fail with status code FAILED_PRECONDITION and error message: "Insufficient balance in account {from_account_id}: current={balance}, required={amount}". - When either the source or destination account doesn't exist, the operation must fail with status code NOT_FOUND and error message: "Account {account_id} not found". - When from_account_id equals to_account_id, the operation must fail with status code INVALID_ARGUMENT and error message: "Cannot transfer to the same account". - When amount ≤ 0, the operation must fail with status code INVALID_ARGUMENT and error message: "Transfer amount must be positive". - TransferFunds must complete in < 50ms at p99 under normal load (< 100 concurrent operations).  ### 6. Deadlock Prevention in Transfers - To prevent deadlocks, accounts must always be locked in a consistent order based on account ID (lexicographic or numeric ordering). - When transferring from account "user_123" to "user_456", lock "user_123" first, then "user_456". - When transferring from account "user_456" to "user_123", lock "user_123" first, then "user_456" (same order). - When 50 goroutines perform transfers A→B and 50 goroutines perform transfers B→A simultaneously, all 100 transfers must complete without deadlock within 5 seconds. - The lock ordering must be implemented by comparing account IDs: if from_id < to_id, lock from first; else lock to first. - After locking both accounts, the operation must: (1) validate source balance, (2) deduct from source, (3) add to destination, (4) log transaction, (5) unlock both.
- Balance Integrity and Consistency - The sum of all account balances in the system must remain constant across all operations (conservation of money). - When the system starts with 10 accounts each having $1000 (total $10,000), after 1000 random transfers, the total must still be exactly $10,000. - When 100 concurrent operations are in progress, any goroutine reading all balances must see a consistent snapshot (no torn reads). - The system must provide read-your-writes consistency: after a goroutine updates an account, its subsequent reads must see the updated value. - The system must provide monotonic reads: a goroutine must never see an older version of an account after seeing a newer version. - Balance integrity must be verified by a test that: (1) records initial sum, (2) performs 10,000 random operations with 50 concurrent goroutines, (3) verifies final sum equals initial sum.  ### 8. Transaction Log Consistency - All successful operations (create, update, transfer) must be appended to an in-memory transaction log for audit purposes. - The transaction log must be append-only: no deletions or modifications allowed. - Log appends must be protected by a dedicated mutex (logMu) separate from account locks to minimize contention. - When 200 concurrent operations complete, all 200 must appear in the transaction log in some order (no lost log entries). - Each log entry must include: transaction_id, timestamp (with nanosecond precision), operation type, affected account IDs, amounts, and result status. - Log writes must complete in < 1ms per entry (< 5% of total operation time). - The log must be queryable by transaction_id in O(log N) time using a secondary index (map[string]int pointing to log position).
- Concurrency and Performance Under Load - The system must handle 200 concurrent goroutines performing random operations without deadlocks, panics, or data corruption. - At 500 requests/second sustained load, the system must maintain:   - GetBalance p99 latency < 5ms   - UpdateBalance p99 latency < 20ms   - TransferFunds p99 latency < 50ms   - CPU utilization < 70% on a 4-core system   - Memory usage < 500MB for 100,000 accounts - Lock contention (time spent waiting for locks) must be < 10% of total execution time, measured using Go's pprof. - When 1000 goroutines call GetBalance on 1000 different accounts simultaneously, all must complete within 200ms (< 0.2ms per call). - When 100 goroutines perform transfers between 10 accounts simultaneously, all must complete within 5 seconds with no deadlocks.   Race Condition Prevention - The system must pass `go test -race` with zero race condition warnings. - Lost Update Prevention: When 100 goroutines each add $1 to the same account (initial balance $0), final balance must be exactly $100. - Dirty Read Prevention: No goroutine may observe intermediate state during a transfer (e.g., money deducted from source but not yet added to destination). - Phantom Transaction Prevention: When 10 goroutines submit the same transaction_id simultaneously, exactly 1 must process it and 9 must detect it as duplicate. - Write Skew Prevention: When two goroutines transfer from the same account simultaneously, the sum of transfers must not exceed the account balance. - The accounts map must never be read or written without holding the appropriate lock (RLock for reads, Lock for writes).
- Error Handling and gRPC Status Codes - All operations must return appropriate gRPC status codes:   - OK (0): Operation succeeded   - NOT_FOUND (5): Account does not exist   - INVALID_ARGUMENT (3): Invalid input (negative amount, same account transfer, etc.)   - FAILED_PRECONDITION (9): Business rule violation (insufficient balance)   - ALREADY_EXISTS (6): Account already exists   - INTERNAL (13): Unexpected errors (should never happen in correct implementation) - Error messages must be descriptive and include relevant details (account IDs, amounts, current state). - When an operation fails, no partial state changes must be visible (atomicity). - Errors must be logged with severity level ERROR, including timestamp, operation, account IDs, and error details.  ### 12. Memory Management and Resource Cleanup - The system must not leak goroutines: all spawned goroutines must complete within operation timeout (5 seconds). - The system must not leak memory: after processing 1 million operations, memory usage must be proportional to number of accounts, not number of operations. - The txIDs map must implement a cleanup strategy: remove transaction IDs older than 24 hours to prevent unbounded growth. - When the txIDs map exceeds 100,000 entries, a background cleanup goroutine must remove entries older than 24 hours, reducing map size by at least 50%. - Memory usage must be measured before and after 1 million operations: growth must be < 10% (proving no memory leak).

## Metadata
- Programming Languages: Go
- Frameworks: (none)
- Libraries: (none)
- Databases: (none)
- Tools: (none)
- Best Practices: (none)
- Performance Metrics: (none)
- Security Standards: (none)

## Structure
- repository_before/: baseline code (`__init__.py`)
- repository_after/: optimized code (`__init__.py`)
- tests/: test suite (`__init__.py`)
- evaluation/: evaluation scripts (`evaluation.py`)
- instances/: sample/problem instances (JSON)
- patches/: patches for diffing
- trajectory/: notes or write-up (Markdown)

## Quick start
- Run tests locally: `python -m pytest -q tests`
- With Docker: `docker compose up --build --abort-on-container-exit`
- Add dependencies to `requirements.txt`

## Notes
- Keep commits focused and small.
- Open a PR when ready for review.
