diff --git a/repository_before/__init__.py b/repository_before/__init__.py
deleted file mode 100644
index e69de29b..00000000
diff --git a/repository_after/goal-traking/app/components/AnalyticsDashboard.tsx b/repository_after/goal-traking/app/components/AnalyticsDashboard.tsx
new file mode 100644
index 00000000..4313b23d
--- /dev/null
+++ b/repository_after/goal-traking/app/components/AnalyticsDashboard.tsx
@@ -0,0 +1,42 @@
+'use client';
+
+import React from 'react';
+import { ProgressTimelineChart } from './analytics/charts/ProgressTimeline';
+import { GoalStateDistributionChart } from './analytics/charts/StateDistribution';
+import { MotivationTrendChart } from './analytics/charts/MotivationTrend';
+import { PriorityDistributionChart } from './analytics/charts/PriorityDistribution';
+import { ConsistencyHeatmap } from './analytics/charts/ConsistencyHeatmap';
+import { TrendSummaryCard } from './analytics/charts/TrendSummary';
+
+export function AnalyticsDashboard() {
+  return (
+    <div className="space-y-6 animate-in fade-in slide-up duration-500">
+      <div className="flex items-center justify-between">
+        <h2 className="text-2xl font-bold tracking-tight text-white">Analytics Dashboard</h2>
+        <span className="text-sm text-muted-foreground">Real-time insights</span>
+      </div>
+      
+      {/* Top Row: Timeline (Wide) & Stat Distribution */}
+      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
+        <div className="lg:col-span-2">
+           <ProgressTimelineChart />
+        </div>
+        <div>
+           <GoalStateDistributionChart />
+        </div>
+      </div>
+      
+      {/* Middle Row: Trend Summary & Heatmap */}
+      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
+        <TrendSummaryCard />
+        <ConsistencyHeatmap />
+      </div>
+      
+      {/* Bottom Row: Motivation & Priorities */}
+      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
+        <MotivationTrendChart />
+        <PriorityDistributionChart />
+      </div>
+    </div>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/GoalDetail.tsx b/repository_after/goal-traking/app/components/GoalDetail.tsx
new file mode 100644
index 00000000..d4e9f1e6
--- /dev/null
+++ b/repository_after/goal-traking/app/components/GoalDetail.tsx
@@ -0,0 +1,147 @@
+'use client';
+
+import React, { useState } from 'react';
+import { Calendar, Trash2, Edit, BarChart } from 'lucide-react';
+import { format } from 'date-fns';
+import { ValidStateTransitions, GoalState, GoalStates } from '@/lib/types';
+import { useGoalStore } from '@/lib/store';
+import { Button } from '@/components/ui/Button';
+import { Badge } from '@/components/ui/Badge';
+import { ProgressBar } from '@/components/ui/ProgressBar';
+import { Tabs, TabsContent } from '@/components/ui/Tabs';
+import { MilestoneTree } from '@/components/goals/MilestoneTree';
+import { GoalAnalytics } from '@/components/analytics/GoalAnalytics';
+import { ProgressHistory } from '@/components/goals/ProgressHistory';
+import { GoalForm, ProgressUpdateForm } from '@/components/GoalForms';
+
+interface GoalDetailProps {
+  goalId: string;
+  onClose: () => void;
+}
+
+export function GoalDetail({ goalId, onClose }: GoalDetailProps) {
+  const { goals, updateGoal, deleteGoal } = useGoalStore();
+  const goal = goals.find(g => g.id === goalId);
+  const [showEditForm, setShowEditForm] = useState(false);
+  const [showProgressForm, setShowProgressForm] = useState(false);
+  const [activeTab, setActiveTab] = useState('milestones');
+  
+  if (!goal) return null;
+  
+  const validTransitions = ValidStateTransitions[goal.state];
+  
+  const handleStateChange = async (newState: GoalState) => {
+    await updateGoal(goal.id, { state: newState }, `State changed to ${newState}`);
+  };
+  
+  const handleDelete = async () => {
+    if (confirm('Are you sure you want to delete this goal? This action cannot be undone.')) {
+      await deleteGoal(goal.id);
+      onClose();
+    }
+  };
+  
+  return (
+    <div className="h-full flex flex-col bg-background animate-in fade-in duration-300">
+      {/* Header */}
+      <div className="p-6 border-b border-white/10 relative">
+        <Button variant="ghost" size="icon" onClick={onClose} className="absolute right-4 top-4 text-muted-foreground hover:text-foreground">
+          <span className="sr-only">Close</span>
+          <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
+        </Button>
+
+        <div className="pr-12">
+          <div className="flex items-center gap-3 mb-3">
+             <h2 className="text-2xl font-bold tracking-tight text-white">{goal.title}</h2>
+             <Badge variant={goal.priority === 'critical' ? 'destructive' : 'default'} className="uppercase">
+               {goal.priority}
+             </Badge>
+          </div>
+          
+          {goal.description && <p className="text-muted-foreground mb-4 max-w-2xl">{goal.description}</p>}
+          
+          <div className="flex flex-wrap gap-4 text-sm text-muted-foreground/80 mb-6">
+             {goal.targetDate && (
+               <div className="flex items-center gap-1.5 bg-secondary/30 px-2 py-1 rounded">
+                 <Calendar className="h-3.5 w-3.5" />
+                 <span>Target: {format(new Date(goal.targetDate), 'MMM d, yyyy')}</span>
+               </div>
+             )}
+             <div className="flex items-center gap-1.5 bg-secondary/30 px-2 py-1 rounded">
+                <span className="h-1.5 w-1.5 rounded-full bg-primary" />
+                <span className="capitalize">Status: {goal.state}</span>
+             </div>
+          </div>
+          
+          <div className="flex gap-2">
+            <Button onClick={() => setShowProgressForm(true)} className="gap-2">
+               <BarChart className="h-4 w-4" /> Log Progress
+            </Button>
+            <Button variant="outline" onClick={() => setShowEditForm(true)} className="gap-2">
+               <Edit className="h-4 w-4" /> Edit
+            </Button>
+            
+            {validTransitions.length > 0 && (
+               <select
+                 className="h-10 px-3 bg-secondary/50 border border-white/10 rounded-lg text-sm outline-none cursor-pointer hover:bg-secondary/80 transition-colors"
+                 value=""
+                 onChange={(e) => e.target.value && handleStateChange(e.target.value as GoalState)}
+               >
+                 <option value="">Status Change...</option>
+                 {validTransitions.map(s => (
+                   <option key={s} value={s}>{s}</option>
+                 ))}
+               </select>
+            )}
+
+            <div className="flex-1" />
+            
+            <Button variant="destructive" size="icon" onClick={handleDelete} title="Delete Goal">
+               <Trash2 className="h-4 w-4" />
+            </Button>
+          </div>
+        </div>
+      </div>
+      
+      <div className="flex-1 flex flex-col min-h-0">
+        <div className="px-6 pt-4 border-b border-white/10">
+           <Tabs 
+             activeTab={activeTab} 
+             onChange={setActiveTab}
+             tabs={[
+               { id: 'milestones', label: 'Milestones' },
+               { id: 'analytics', label: 'Analytics' },
+               { id: 'history', label: 'History' },
+             ]}
+           />
+        </div>
+        
+        <div className="flex-1 overflow-y-auto p-6 scrollbar-thin">
+           <TabsContent value="milestones" activeTab={activeTab}>
+              <MilestoneTree goalId={goal.id} />
+           </TabsContent>
+           
+           <TabsContent value="analytics" activeTab={activeTab}>
+              <GoalAnalytics goal={goal} />
+           </TabsContent>
+           
+           <TabsContent value="history" activeTab={activeTab}>
+              <ProgressHistory goalId={goal.id} />
+           </TabsContent>
+        </div>
+      </div>
+      
+      {/* Modals */}
+      {showEditForm && <GoalForm goal={goal} onClose={() => setShowEditForm(false)} />}
+      
+      {showProgressForm && (
+        <ProgressUpdateForm
+          entityId={goal.id}
+          entityType="goal"
+          currentProgress={goal.progress}
+          onClose={() => setShowProgressForm(false)}
+        />
+      )}
+    </div>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/GoalForms.tsx b/repository_after/goal-traking/app/components/GoalForms.tsx
new file mode 100644
index 00000000..ea1f84d5
--- /dev/null
+++ b/repository_after/goal-traking/app/components/GoalForms.tsx
@@ -0,0 +1,13 @@
+export * from './forms/GoalEditor';
+export * from './forms/MilestoneEditor';
+export * from './forms/ProgressLogger';
+
+// Alias for backward compatibility if needed, but components should update imports to use the named exports
+// or we can re-export them with aliases matching original names
+import { GoalEditor } from './forms/GoalEditor';
+import { MilestoneEditor } from './forms/MilestoneEditor';
+import { ProgressLogger } from './forms/ProgressLogger';
+
+export const GoalForm = GoalEditor;
+export const MilestoneForm = MilestoneEditor;
+export const ProgressUpdateForm = ProgressLogger;
diff --git a/repository_after/goal-traking/app/components/GoalList.tsx b/repository_after/goal-traking/app/components/GoalList.tsx
new file mode 100644
index 00000000..b1fde370
--- /dev/null
+++ b/repository_after/goal-traking/app/components/GoalList.tsx
@@ -0,0 +1,83 @@
+'use client';
+
+import React, { useState } from 'react';
+import { Filter } from 'lucide-react';
+import { useGoalStore } from '@/lib/store';
+import { Button } from '@/components/ui/Button';
+import { GoalCard } from '@/components/goals/GoalCard';
+import { GoalsFilter } from '@/components/goals/GoalsFilter';
+import { GoalStats } from '@/components/goals/GoalStats';
+
+interface GoalListProps {
+  onGoalSelect?: (goalId: string) => void;
+}
+
+export function GoalList({ onGoalSelect }: GoalListProps) {
+  const { filteredGoals, selectedGoalId, selectGoal, isLoading, milestones } = useGoalStore();
+  const [isFilterOpen, setIsFilterOpen] = useState(false);
+  
+  const handleSelect = React.useCallback((goalId: string) => {
+    selectGoal(goalId);
+    onGoalSelect?.(goalId);
+  }, [selectGoal, onGoalSelect]);
+  
+  if (isLoading) {
+    return (
+      <div className="flex flex-col items-center justify-center p-12 min-h-[400px]">
+        <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-primary mb-4" />
+        <p className="text-muted-foreground animate-pulse">Loading goals...</p>
+      </div>
+    );
+  }
+  
+  return (
+    <div className="space-y-6 animate-in fade-in duration-500">
+      
+      <GoalStats />
+
+      <div className="flex items-center justify-between mb-2">
+        <h2 className="text-xl font-semibold text-foreground">My Goals</h2>
+        <Button 
+          variant="outline" 
+          size="sm" 
+          onClick={() => setIsFilterOpen(true)}
+          className="gap-2"
+        >
+          <Filter className="h-4 w-4" />
+          Filter & Sort
+        </Button>
+      </div>
+
+      <GoalsFilter isOpen={isFilterOpen} onClose={() => setIsFilterOpen(false)} />
+
+      {filteredGoals.length === 0 ? (
+        <div className="flex flex-col items-center justify-center p-12 border border-dashed border-white/10 rounded-xl bg-slate-900/50">
+          <div className="p-4 bg-slate-800/50 rounded-full mb-4">
+             <Filter className="h-8 w-8 text-muted-foreground" />
+          </div>
+          <p className="text-lg font-medium mb-1">No goals found</p>
+          <p className="text-sm text-muted-foreground max-w-xs text-center">
+            Try adjusting your filters or create a new goal to get started.
+          </p>
+        </div>
+      ) : (
+        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
+          {filteredGoals.map((goal, index) => (
+            <div 
+               key={goal.id} 
+               className={`animate-in slide-up`} 
+               style={{ animationDelay: `${index * 50}ms`, animationFillMode: 'both' }}
+            >
+              <GoalCard
+                goal={goal}
+                milestonesCount={milestones.filter(m => m.goalId === goal.id).length}
+                isSelected={goal.id === selectedGoalId}
+                onClick={() => handleSelect(goal.id)}
+              />
+            </div>
+          ))}
+        </div>
+      )}
+    </div>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/analytics/GoalAnalytics.tsx b/repository_after/goal-traking/app/components/analytics/GoalAnalytics.tsx
new file mode 100644
index 00000000..6ac92a87
--- /dev/null
+++ b/repository_after/goal-traking/app/components/analytics/GoalAnalytics.tsx
@@ -0,0 +1,179 @@
+import React, { useMemo } from 'react';
+import { TrendingUp, AlertTriangle, CheckCircle, BarChart as BarChartIcon } from 'lucide-react';
+import { Goal } from '@/lib/types';
+import { useGoalStore } from '@/lib/store';
+import { computeVelocity, computeEstimationAccuracy, computeOutcomeQuality, predictCompletionProbability } from '@/lib/analytics';
+import { analyzeBlockedItems, buildDependencyGraph } from '@/lib/dependencies';
+import { Card } from '@/components/ui/Card';
+import { ProgressBar } from '@/components/ui/ProgressBar';
+
+interface GoalAnalyticsProps {
+  goal: Goal;
+}
+
+export function GoalAnalytics({ goal }: GoalAnalyticsProps) {
+  const { milestones, progressUpdates, dependencies, goals } = useGoalStore();
+  
+  const analytics = useMemo(() => {
+    const goalMilestones = milestones.filter(m => m.goalId === goal.id);
+    const goalUpdates = progressUpdates.filter(p => p.entityId === goal.id);
+    
+    // Velocity
+    const velocity = computeVelocity(goal.id, progressUpdates, goal.createdAt);
+    
+    // Estimation accuracy
+    const estimationAccuracy = goal.expectedOutcome && goal.actualOutcome
+      ? computeEstimationAccuracy(goal, progressUpdates)
+      : null;
+    
+    // Outcome quality (only for completed goals)
+    const outcomeQuality = goal.state === 'completed'
+      ? computeOutcomeQuality(goal, progressUpdates)
+      : null;
+    
+    // Dependency analysis
+    const graph = buildDependencyGraph(goals, milestones, dependencies);
+    const blockedItems = analyzeBlockedItems(graph, dependencies);
+    
+    // Check if this goal is blocked
+    const goalBlockedInfo = blockedItems.find(b => b.itemId === goal.id);
+    
+    // Completion prediction
+    const depWithBlocked = dependencies.map(d => ({
+      sourceId: d.sourceId,
+      targetId: d.targetId,
+      blocked: blockedItems.some(b => b.itemId === d.sourceId),
+    }));
+    
+    const completedGoals = goals.filter(g => g.state === 'completed').length;
+    const totalTerminalGoals = goals.filter(g => 
+      ['completed', 'failed', 'abandoned'].includes(g.state)
+    ).length;
+    const historicalRate = totalTerminalGoals > 0 
+      ? (completedGoals / totalTerminalGoals) * 100 
+      : 50;
+    
+    const prediction = predictCompletionProbability(
+      goal,
+      goalMilestones,
+      progressUpdates,
+      depWithBlocked,
+      historicalRate
+    );
+    
+    return {
+      velocity,
+      estimationAccuracy,
+      outcomeQuality,
+      blockedBy: goalBlockedInfo?.blockedBy || [],
+      prediction,
+      milestonesCount: goalMilestones.length,
+      completedMilestones: goalMilestones.filter(m => m.state === 'completed').length,
+    };
+  }, [goal, milestones, progressUpdates, dependencies, goals]);
+  
+  const velocityColor = {
+    accelerating: 'text-green-400',
+    stable: 'text-blue-400',
+    decelerating: 'text-amber-400',
+    stagnant: 'text-destructive',
+  };
+  
+  return (
+    <div className="space-y-4 animate-in fade-in slide-up">
+      {/* Velocity Card */}
+      <Card variant="glass" className="relative overflow-hidden">
+        <div className="flex items-start gap-4">
+          <div className="p-3 rounded-lg bg-blue-500/10 text-blue-400">
+            <TrendingUp className="h-6 w-6" />
+          </div>
+          <div>
+            <h4 className="text-sm font-medium text-muted-foreground">Velocity</h4>
+            <div className={`flex items-baseline gap-2 mt-1 ${velocityColor[analytics.velocity.accelerationTrend]}`}>
+              <span className="text-2xl font-bold">{analytics.velocity.progressPerDay.toFixed(1)}%</span>
+              <span className="text-xs font-medium uppercase tracking-wide">/ day</span>
+            </div>
+            <p className="text-xs text-muted-foreground mt-1 capitalize">
+              Trend: <span className={velocityColor[analytics.velocity.accelerationTrend]}>{analytics.velocity.accelerationTrend}</span>
+            </p>
+          </div>
+        </div>
+      </Card>
+
+      {/* Prediction Card */}
+      <Card variant="glass" className="relative overflow-hidden">
+         <div className="flex items-start gap-4 mb-4">
+           <div className={`p-3 rounded-lg ${
+             analytics.prediction.probability >= 70 ? 'bg-green-500/10 text-green-400' :
+             analytics.prediction.probability >= 40 ? 'bg-amber-500/10 text-amber-400' : 'bg-destructive/10 text-destructive'
+           }`}>
+             <BarChartIcon className="h-6 w-6" />
+           </div>
+           <div>
+             <h4 className="text-sm font-medium text-muted-foreground">Completion Forecast</h4>
+             <div className="flex items-baseline gap-2 mt-1">
+               <span className={`text-2xl font-bold ${
+                  analytics.prediction.probability >= 70 ? 'text-green-400' :
+                  analytics.prediction.probability >= 40 ? 'text-amber-400' : 'text-destructive'
+               }`}>
+                 {analytics.prediction.probability}%
+               </span>
+               <span className="text-xs text-muted-foreground">Probability</span>
+             </div>
+             {analytics.prediction.estimatedCompletionDate && (
+               <p className="text-xs text-muted-foreground mt-1">
+                 Est. Date: {new Date(analytics.prediction.estimatedCompletionDate).toLocaleDateString()}
+               </p>
+             )}
+           </div>
+         </div>
+         
+         {(analytics.prediction.riskFactors.length > 0 || analytics.prediction.positiveFactors.length > 0) && (
+           <div className="space-y-2 pt-3 border-t border-white/5">
+             {analytics.prediction.positiveFactors.map((f, i) => (
+               <div key={i} className="flex items-center gap-2 text-xs text-green-400">
+                 <CheckCircle className="h-3 w-3" /> {f}
+               </div>
+             ))}
+             {analytics.prediction.riskFactors.map((r, i) => (
+               <div key={i} className="flex items-center gap-2 text-xs text-destructive">
+                 <AlertTriangle className="h-3 w-3" /> {r}
+               </div>
+             ))}
+           </div>
+         )}
+      </Card>
+
+      {/* Blocked Items */}
+      {analytics.blockedBy.length > 0 && (
+        <Card className="bg-destructive/10 border-destructive/20">
+          <div className="flex items-center gap-2 text-destructive mb-2 font-medium">
+             <AlertTriangle className="h-4 w-4" /> Blocked By
+          </div>
+          <div className="space-y-1 pl-6">
+            {analytics.blockedBy.map(blocker => (
+              <p key={blocker.id} className="text-sm text-destructive/80">
+                â€¢ {blocker.title} <span className="text-[10px] opacity-70 border border-destructive/30 px-1 rounded uppercase bg-destructive/5">{blocker.state}</span>
+              </p>
+            ))}
+          </div>
+        </Card>
+      )}
+
+      {/* Outcome Quality (Completed) */}
+      {analytics.outcomeQuality && (
+        <Card className="bg-green-500/5 border-green-500/20">
+           <h4 className="text-sm font-medium text-green-400 mb-2">Outcome Score: {analytics.outcomeQuality.overallScore}/100</h4>
+           <div className="grid grid-cols-2 gap-2">
+             <div className="text-xs">
+               <span className="text-muted-foreground">Timeliness:</span> <span className="text-green-300">{analytics.outcomeQuality.timelinessScore}</span>
+             </div>
+             <div className="text-xs">
+               <span className="text-muted-foreground">Efficiency:</span> <span className="text-green-300">{analytics.outcomeQuality.efficiencyScore}</span>
+             </div>
+           </div>
+        </Card>
+      )}
+    </div>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/analytics/charts/ConsistencyHeatmap.tsx b/repository_after/goal-traking/app/components/analytics/charts/ConsistencyHeatmap.tsx
new file mode 100644
index 00000000..c4f24ca6
--- /dev/null
+++ b/repository_after/goal-traking/app/components/analytics/charts/ConsistencyHeatmap.tsx
@@ -0,0 +1,90 @@
+'use client';
+
+import React, { useMemo } from 'react';
+import { useGoalStore } from '@/lib/store';
+import { format, subDays, startOfDay, parseISO } from 'date-fns';
+import { Card } from '@/components/ui/Card';
+import { cn } from '@/lib/utils';
+
+
+export function ConsistencyHeatmap() {
+  const { progressUpdates } = useGoalStore();
+  
+  const data = useMemo(() => {
+    const now = new Date();
+    const weeks = 12; // About 3 months
+    const totalDays = weeks * 7;
+    const days = [];
+    
+    // We want to show from left to right (oldest to newest) inside the grid columns?
+    // Often heatmaps are col-based (weeks).
+    // Let's generate array of days.
+    
+    for (let i = totalDays - 1; i >= 0; i--) {
+      const date = subDays(now, i);
+      const dayStart = startOfDay(date);
+      const count = progressUpdates.filter(u => {
+        const updateDate = startOfDay(parseISO(u.createdAt));
+        return updateDate.getTime() === dayStart.getTime();
+      }).length;
+      days.push({ date, count });
+    }
+    
+    return days;
+  }, [progressUpdates]);
+  
+  const maxCount = Math.max(...data.map(d => d.count), 1);
+  
+  const getColor = (count: number) => {
+    if (count === 0) return 'bg-white/5';
+    const intensity = count / maxCount;
+    if (intensity > 0.75) return 'bg-green-500';
+    if (intensity > 0.5) return 'bg-green-600';
+    if (intensity > 0.25) return 'bg-green-700';
+    return 'bg-green-900';
+  };
+  
+  // Group into weeks (columns)
+  // Recharts doesn't do heatmaps well. Custom div grid is better.
+  const weeks = [];
+  for (let i = 0; i < data.length; i += 7) {
+    weeks.push(data.slice(i, i + 7));
+  }
+  
+  return (
+    <Card variant="glass" className="h flex flex-col h-[300px]">
+      <div className="mb-4">
+        <h3 className="text-lg font-semibold tracking-tight">Consistency</h3>
+        <p className="text-xs text-muted-foreground">Activity heatmap (last 12 weeks)</p>
+      </div>
+      
+      <div className="flex-1 flex items-center justify-center w-full min-h-0 overflow-x-auto pb-4">
+        <div className="flex gap-1.5">
+          {weeks.map((week, weekIndex) => (
+            <div key={weekIndex} className="flex flex-col gap-1.5">
+              {week.map((day, dayIndex) => (
+                <div
+                  key={dayIndex}
+                  className={cn("w-3.5 h-3.5 rounded-sm transition-colors hover:ring-1 hover:ring-white/50", getColor(day.count))}
+                  title={`${format(day.date, 'MMM dd')}: ${day.count} updates`}
+                />
+              ))}
+            </div>
+          ))}
+        </div>
+      </div>
+      
+      <div className="flex items-center gap-2 mt-2 text-[10px] text-muted-foreground justify-end px-4">
+         <span>Less</span>
+         <div className="flex gap-1">
+            <div className="w-2.5 h-2.5 rounded-sm bg-white/5" />
+            <div className="w-2.5 h-2.5 rounded-sm bg-green-900" />
+            <div className="w-2.5 h-2.5 rounded-sm bg-green-700" />
+            <div className="w-2.5 h-2.5 rounded-sm bg-green-600" />
+            <div className="w-2.5 h-2.5 rounded-sm bg-green-500" />
+         </div>
+         <span>More</span>
+      </div>
+    </Card>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/analytics/charts/MotivationTrend.tsx b/repository_after/goal-traking/app/components/analytics/charts/MotivationTrend.tsx
new file mode 100644
index 00000000..4d8adc65
--- /dev/null
+++ b/repository_after/goal-traking/app/components/analytics/charts/MotivationTrend.tsx
@@ -0,0 +1,122 @@
+'use client';
+
+import React, { useMemo } from 'react';
+import {
+  LineChart,
+  Line,
+  XAxis,
+  YAxis,
+  CartesianGrid,
+  Tooltip,
+  Legend,
+  ResponsiveContainer,
+} from 'recharts';
+import { useGoalStore } from '@/lib/store';
+import { format, subDays, eachDayOfInterval, parseISO, startOfDay } from 'date-fns';
+import { Card } from '@/components/ui/Card';
+
+export function MotivationTrendChart() {
+  const { progressUpdates } = useGoalStore();
+  
+  const data = useMemo(() => {
+    const now = new Date();
+    const days = 14; // Showing 2 weeks for better granularity
+    const startDate = subDays(now, days);
+    
+    const dateRange = eachDayOfInterval({ start: startDate, end: now });
+    
+    return dateRange.map(date => {
+      const dayStart = startOfDay(date);
+      const dayUpdates = progressUpdates.filter(u => {
+        const updateDate = startOfDay(parseISO(u.createdAt));
+        return updateDate.getTime() === dayStart.getTime() && (u.motivationLevel !== undefined || u.confidenceLevel !== undefined);
+      });
+      
+      const avgMotivation = dayUpdates.length > 0
+        ? dayUpdates.reduce((sum, u) => sum + (u.motivationLevel || 0), 0) / dayUpdates.length
+        : null;
+      
+      const avgConfidence = dayUpdates.length > 0
+        ? dayUpdates.reduce((sum, u) => sum + (u.confidenceLevel || 0), 0) / dayUpdates.length
+        : null;
+      
+      return {
+        date: format(date, 'MMM dd'),
+        motivation: avgMotivation ? Number(avgMotivation.toFixed(1)) : null,
+        confidence: avgConfidence ? Number(avgConfidence.toFixed(1)) : null,
+      };
+    });
+  }, [progressUpdates]);
+  
+  const hasData = data.some(d => d.motivation !== null || d.confidence !== null);
+  
+  if (!hasData) {
+    return (
+      <Card variant="glass" className="h-[300px] flex items-center justify-center">
+        <p className="text-muted-foreground text-center px-8">
+           Not enough data for Motivation Trend.<br/>
+           <span className="text-xs opacity-70">Log progress updates with motivation & confidence ratings.</span>
+        </p>
+      </Card>
+    );
+  }
+  
+  return (
+    <Card variant="glass" className="h-[300px] flex flex-col">
+      <div className="mb-2">
+        <h3 className="text-lg font-semibold tracking-tight">Psychometrics</h3>
+        <p className="text-xs text-muted-foreground">Motivation & Confidence over time</p>
+      </div>
+      
+      <div className="flex-1 w-full min-h-0">
+        <ResponsiveContainer width="100%" height="100%">
+          <LineChart data={data} margin={{ top: 5, right: 10, left: -20, bottom: 0 }}>
+            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.05)" vertical={false} />
+            <XAxis 
+              dataKey="date" 
+              stroke="rgba(255,255,255,0.3)" 
+              fontSize={10} 
+              tickLine={false}
+              axisLine={false}
+            />
+            <YAxis 
+              stroke="rgba(255,255,255,0.3)" 
+              fontSize={10} 
+              tickLine={false}
+              axisLine={false}
+              domain={[0, 10]}
+            />
+            <Tooltip
+              contentStyle={{ 
+                backgroundColor: 'hsl(var(--card))', 
+                border: '1px solid rgba(255,255,255,0.1)',
+                borderRadius: '8px',
+                fontSize: '12px'
+              }}
+              itemStyle={{ color: 'hsl(var(--foreground))' }}
+            />
+            <Legend wrapperStyle={{ fontSize: '10px' }} />
+            <Line
+              type="monotone"
+              dataKey="motivation"
+              stroke="#f59e0b" // amber
+              strokeWidth={2}
+              dot={{ r: 3, fill: '#f59e0b' }}
+              name="Motivation"
+              connectNulls
+            />
+            <Line
+              type="monotone"
+              dataKey="confidence"
+              stroke="#8b5cf6" // violet
+              strokeWidth={2}
+              dot={{ r: 3, fill: '#8b5cf6' }}
+              name="Confidence"
+              connectNulls
+            />
+          </LineChart>
+        </ResponsiveContainer>
+      </div>
+    </Card>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/analytics/charts/PriorityDistribution.tsx b/repository_after/goal-traking/app/components/analytics/charts/PriorityDistribution.tsx
new file mode 100644
index 00000000..cd26580f
--- /dev/null
+++ b/repository_after/goal-traking/app/components/analytics/charts/PriorityDistribution.tsx
@@ -0,0 +1,88 @@
+'use client';
+
+import React, { useMemo } from 'react';
+import {
+  BarChart,
+  Bar,
+  XAxis,
+  YAxis,
+  CartesianGrid,
+  Tooltip,
+  Legend,
+  ResponsiveContainer,
+} from 'recharts';
+import { useGoalStore } from '@/lib/store';
+import { Card } from '@/components/ui/Card';
+
+export function PriorityDistributionChart() {
+  const { goals } = useGoalStore();
+  
+  const data = useMemo(() => {
+    const activeGoals = goals.filter(g => !['completed', 'failed', 'abandoned'].includes(g.state));
+    
+    return ['critical', 'high', 'medium', 'low'].map(priority => {
+      const priorityGoals = activeGoals.filter(g => g.priority === priority);
+      const avgProgress = priorityGoals.length > 0
+        ? priorityGoals.reduce((sum, g) => sum + g.progress, 0) / priorityGoals.length
+        : 0;
+      
+      return {
+        priority: priority.charAt(0).toUpperCase() + priority.slice(1),
+        count: priorityGoals.length,
+        avgProgress: Math.round(avgProgress),
+      };
+    });
+  }, [goals]);
+  
+  return (
+    <Card variant="glass" className="h-[300px] flex flex-col">
+      <div className="mb-2">
+        <h3 className="text-lg font-semibold tracking-tight">Active Priorities</h3>
+        <p className="text-xs text-muted-foreground">Distribution of active goals by priority</p>
+      </div>
+      
+      <div className="flex-1 w-full min-h-0">
+        <ResponsiveContainer width="100%" height="100%">
+          <BarChart data={data} layout="vertical" margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
+            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.05)" horizontal={false} />
+            <XAxis type="number" hide />
+            <YAxis 
+               type="category" 
+               dataKey="priority" 
+               stroke="rgba(255,255,255,0.7)" 
+               fontSize={12} 
+               tickLine={false}
+               axisLine={false}
+               width={60}
+            />
+            <Tooltip
+              cursor={{ fill: 'rgba(255,255,255,0.05)' }}
+              contentStyle={{ 
+                backgroundColor: 'hsl(var(--card))', 
+                border: '1px solid rgba(255,255,255,0.1)',
+                borderRadius: '8px',
+                fontSize: '12px'
+              }}
+              itemStyle={{ color: 'hsl(var(--foreground))' }}
+            />
+            <Legend wrapperStyle={{ fontSize: '10px' }} />
+            <Bar 
+               dataKey="count" 
+               fill="hsl(var(--primary))" 
+               name="Count" 
+               radius={[0, 4, 4, 0]} 
+               barSize={20}
+            />
+            <Bar 
+               dataKey="avgProgress" 
+               fill="#10b981" 
+               name="Avg Progress" 
+               radius={[0, 4, 4, 0]} 
+               barSize={20}
+            />
+          </BarChart>
+        </ResponsiveContainer>
+      </div>
+    </Card>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/analytics/charts/ProgressTimeline.tsx b/repository_after/goal-traking/app/components/analytics/charts/ProgressTimeline.tsx
new file mode 100644
index 00000000..99dce0d8
--- /dev/null
+++ b/repository_after/goal-traking/app/components/analytics/charts/ProgressTimeline.tsx
@@ -0,0 +1,126 @@
+'use client';
+
+import React, { useMemo } from 'react';
+import {
+  AreaChart,
+  Area,
+  XAxis,
+  YAxis,
+  CartesianGrid,
+  Tooltip,
+  ResponsiveContainer,
+} from 'recharts';
+import { useGoalStore } from '@/lib/store';
+import { format, subDays, eachDayOfInterval, parseISO, startOfDay } from 'date-fns';
+import { Card } from '@/components/ui/Card';
+
+interface ProgressTimelineProps {
+  goalId?: string;
+  days?: number;
+}
+
+export function ProgressTimelineChart({ goalId, days = 30 }: ProgressTimelineProps) {
+  const { progressUpdates } = useGoalStore();
+  
+  const data = useMemo(() => {
+    const now = new Date();
+    const startDate = subDays(now, days);
+    
+    // Ensure we don't go back further than necessary if there's no data
+    const dateRange = eachDayOfInterval({ start: startDate, end: now });
+    
+    const relevantUpdates = goalId
+      ? progressUpdates.filter(u => u.entityId === goalId)
+      : progressUpdates;
+    
+    return dateRange.map(date => {
+      const dayStart = startOfDay(date);
+      const dayUpdates = relevantUpdates.filter(u => {
+        const updateDate = startOfDay(parseISO(u.createdAt));
+        return updateDate.getTime() === dayStart.getTime();
+      });
+      
+      // Get the last progress value for the day
+      const lastUpdate = dayUpdates.sort((a, b) => 
+        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
+      )[0];
+      
+      return {
+        date: format(date, 'MMM dd'),
+        // If no update on this day, use previous known value or null if start
+        progress: lastUpdate?.percentage || null,
+        timestamp: date.getTime(),
+      };
+    });
+  }, [progressUpdates, goalId, days]);
+  
+  // Fill gaps
+  const filledData = useMemo(() => {
+    let lastProgress = 0;
+    return data.map(d => {
+      if (d.progress !== null) {
+        lastProgress = d.progress;
+      }
+      return { ...d, progressValue: lastProgress };
+    });
+  }, [data]);
+
+  return (
+    <Card variant="glass" className="h-[350px] flex flex-col">
+      <div className="mb-4">
+        <h3 className="text-lg font-semibold tracking-tight">Progress Timeline</h3>
+        <p className="text-xs text-muted-foreground">Tracking overall progress over the last {days} days</p>
+      </div>
+      
+      <div className="flex-1 w-full min-h-0">
+        <ResponsiveContainer width="100%" height="100%">
+          <AreaChart data={filledData} margin={{ top: 10, right: 10, left: -20, bottom: 0 }}>
+            <defs>
+              <linearGradient id="colorProgress" x1="0" y1="0" x2="0" y2="1">
+                <stop offset="5%" stopColor="hsl(var(--primary))" stopOpacity={0.3}/>
+                <stop offset="95%" stopColor="hsl(var(--primary))" stopOpacity={0}/>
+              </linearGradient>
+            </defs>
+            <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.05)" vertical={false} />
+            <XAxis 
+              dataKey="date" 
+              stroke="rgba(255,255,255,0.3)" 
+              fontSize={10} 
+              tickLine={false}
+              axisLine={false}
+              minTickGap={30}
+            />
+            <YAxis 
+              stroke="rgba(255,255,255,0.3)" 
+              fontSize={10} 
+              tickLine={false}
+              axisLine={false}
+              domain={[0, 100]}
+              tickFormatter={(val) => `${val}%`}
+            />
+            <Tooltip
+              contentStyle={{ 
+                backgroundColor: 'hsl(var(--card))', 
+                border: '1px solid rgba(255,255,255,0.1)',
+                borderRadius: '8px',
+                fontSize: '12px'
+              }}
+              itemStyle={{ color: 'hsl(var(--foreground))' }}
+              labelStyle={{ color: 'hsl(var(--muted-foreground))', marginBottom: '4px' }}
+            />
+            <Area
+              type="monotone"
+              dataKey="progressValue"
+              stroke="hsl(var(--primary))"
+              fillOpacity={1}
+              fill="url(#colorProgress)"
+              strokeWidth={2}
+              name="Progress"
+              animationDuration={1000}
+            />
+          </AreaChart>
+        </ResponsiveContainer>
+      </div>
+    </Card>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/analytics/charts/StateDistribution.tsx b/repository_after/goal-traking/app/components/analytics/charts/StateDistribution.tsx
new file mode 100644
index 00000000..c927c17a
--- /dev/null
+++ b/repository_after/goal-traking/app/components/analytics/charts/StateDistribution.tsx
@@ -0,0 +1,92 @@
+'use client';
+
+import React, { useMemo } from 'react';
+import {
+  PieChart,
+  Pie,
+  Cell,
+  Tooltip,
+  ResponsiveContainer,
+  Legend
+} from 'recharts';
+import { useGoalStore } from '@/lib/store';
+import { Card } from '@/components/ui/Card';
+
+const COLORS = [
+  'hsl(var(--primary))', 
+  'hsl(var(--secondary))', 
+  'hsl(var(--accent))', 
+  'hsl(var(--destructive))', 
+  '#10b981', // emerald
+  '#f59e0b'  // amber
+];
+
+export function GoalStateDistributionChart() {
+  const { goals } = useGoalStore();
+  
+  const data = useMemo(() => {
+    const counts = goals.reduce((acc, goal) => {
+      acc[goal.state] = (acc[goal.state] || 0) + 1;
+      return acc;
+    }, {} as Record<string, number>);
+    
+    return Object.entries(counts).map(([state, count]) => ({
+      name: state.charAt(0).toUpperCase() + state.slice(1),
+      value: count,
+    })).sort((a, b) => b.value - a.value);
+  }, [goals]);
+  
+  if (data.length === 0) {
+    return (
+      <Card variant="glass" className="h-[300px] flex items-center justify-center">
+        <p className="text-muted-foreground">No data available</p>
+      </Card>
+    );
+  }
+  
+  return (
+    <Card variant="glass" className="h-[300px] flex flex-col">
+      <div className="mb-2">
+        <h3 className="text-lg font-semibold tracking-tight">Status Distribution</h3>
+      </div>
+      
+      <div className="flex-1 w-full min-h-0">
+        <ResponsiveContainer width="100%" height="100%">
+          <PieChart>
+            <Pie
+              data={data}
+              cx="50%"
+              cy="50%"
+              innerRadius={60}
+              outerRadius={80}
+              paddingAngle={5}
+              dataKey="value"
+              stroke="none"
+            >
+              {data.map((entry, index) => (
+                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
+              ))}
+            </Pie>
+            <Tooltip
+              contentStyle={{ 
+                backgroundColor: 'hsl(var(--card))', 
+                border: '1px solid rgba(255,255,255,0.1)',
+                borderRadius: '8px',
+                fontSize: '12px'
+              }}
+              itemStyle={{ color: 'hsl(var(--foreground))' }}
+            />
+            <Legend 
+              verticalAlign="middle" 
+              align="right"
+              layout="vertical"
+              iconType="circle"
+              iconSize={8}
+              wrapperStyle={{ fontSize: '12px', opacity: 0.8 }}
+            />
+          </PieChart>
+        </ResponsiveContainer>
+      </div>
+    </Card>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/analytics/charts/TrendSummary.tsx b/repository_after/goal-traking/app/components/analytics/charts/TrendSummary.tsx
new file mode 100644
index 00000000..6a9e5b8c
--- /dev/null
+++ b/repository_after/goal-traking/app/components/analytics/charts/TrendSummary.tsx
@@ -0,0 +1,117 @@
+'use client';
+
+import React, { useMemo } from 'react';
+import { Target, TrendingUp, AlertTriangle, Zap, CheckCircle2, TrendingDown, Minus } from 'lucide-react';
+import { useGoalStore } from '@/lib/store';
+import { computeTrendAnalysis } from '@/lib/analytics';
+import { Card } from '@/components/ui/Card';
+
+export function TrendSummaryCard() {
+  const { goals, progressUpdates } = useGoalStore();
+  
+  const trends = useMemo(() => {
+    return computeTrendAnalysis(goals, progressUpdates);
+  }, [goals, progressUpdates]);
+  
+  const motivationIcon = {
+    improving: <TrendingUp className="h-4 w-4 text-green-400" />,
+    declining: <TrendingDown className="h-4 w-4 text-destructive" />,
+    stable: <Minus className="h-4 w-4 text-blue-400" />,
+    volatile: <ActivityIcon className="h-4 w-4 text-amber-400" />,
+  };
+
+  const riskColor = {
+    low: 'text-green-400',
+    medium: 'text-amber-400',
+    high: 'text-orange-400',
+    critical: 'text-destructive',
+  };
+  
+  return (
+    <Card variant="glass" className="h-full">
+      <div className="mb-4">
+        <h3 className="text-lg font-semibold tracking-tight text-white">Trend Analysis</h3>
+        <p className="text-xs text-muted-foreground">AI-driven insights</p>
+      </div>
+      
+      <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
+         {/* Consistency */}
+         <div className="p-3 rounded-lg bg-secondary/20 border border-white/5">
+             <div className="flex items-center gap-2 mb-1">
+                <CheckCircle2 className="h-3.5 w-3.5 text-blue-400" />
+                <span className="text-xs text-muted-foreground">Consistency</span>
+             </div>
+             <p className="text-xl font-bold">{trends.consistencyScore}%</p>
+         </div>
+         
+         {/* Completion Reliability */}
+         <div className="p-3 rounded-lg bg-secondary/20 border border-white/5">
+             <div className="flex items-center gap-2 mb-1">
+                <Target className="h-3.5 w-3.5 text-green-400" />
+                <span className="text-xs text-muted-foreground">Reliability</span>
+             </div>
+             <p className="text-xl font-bold">{trends.completionReliability}%</p>
+         </div>
+
+         {/* Average Velocity */}
+         <div className="p-3 rounded-lg bg-secondary/20 border border-white/5">
+             <div className="flex items-center gap-2 mb-1">
+                <Zap className="h-3.5 w-3.5 text-yellow-400" />
+                <span className="text-xs text-muted-foreground">Velocity</span>
+             </div>
+             <p className="text-xl font-bold">{trends.averageVelocity}<span className="text-xs font-normal opacity-70">/day</span></p>
+         </div>
+
+         {/* Motivation Trend */}
+         <div className="p-3 rounded-lg bg-secondary/20 border border-white/5">
+             <div className="flex items-center gap-2 mb-1">
+                <TrendingUp className="h-3.5 w-3.5 text-purple-400" />
+                <span className="text-xs text-muted-foreground">Motivation</span>
+             </div>
+             <div className="flex items-center gap-2">
+               <span className="text-sm font-medium capitalize">{trends.motivationTrend}</span>
+               {motivationIcon[trends.motivationTrend]}
+             </div>
+         </div>
+
+         {/* Burnout Risk */}
+         <div className="p-3 rounded-lg bg-secondary/20 border border-white/5">
+             <div className="flex items-center gap-2 mb-1">
+                <AlertTriangle className="h-3.5 w-3.5 text-destructive" />
+                <span className="text-xs text-muted-foreground">Burnout Risk</span>
+             </div>
+             <p className={`text-sm font-bold uppercase ${riskColor[trends.burnoutRisk]}`}>
+               {trends.burnoutRisk}
+             </p>
+         </div>
+         
+         {/* Optimism Bias */}
+         {trends.optimismBias !== undefined && (
+            <div className="p-3 rounded-lg bg-secondary/20 border border-white/5">
+               <div className="flex items-center gap-2 mb-1">
+                  <TrendingUp className="h-3.5 w-3.5 text-cyan-400" />
+                  <span className="text-xs text-muted-foreground">Bias</span>
+               </div>
+               <p className={`text-lg font-bold ${trends.optimismBias > 10 ? 'text-amber-400' : 'text-green-400'}`}>
+                 {trends.optimismBias > 0 ? '+' : ''}{trends.optimismBias}%
+               </p>
+            </div>
+         )}
+      </div>
+
+      {trends.recoveryPattern && (
+        <div className="mt-4 p-3 rounded bg-blue-500/10 border border-blue-500/20 text-xs text-blue-200">
+           ðŸ’¡ Pattern Detected: <span className="font-medium">{trends.recoveryPattern}</span>
+        </div>
+      )}
+    </Card>
+  );
+}
+
+function ActivityIcon({ className }: { className?: string }) {
+  return (
+    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
+      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
+    </svg>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/forms/DataExportModal.tsx b/repository_after/goal-traking/app/components/forms/DataExportModal.tsx
new file mode 100644
index 00000000..2ec38e38
--- /dev/null
+++ b/repository_after/goal-traking/app/components/forms/DataExportModal.tsx
@@ -0,0 +1,172 @@
+import React, { useState } from 'react';
+import { Download, FileJson, FileText, Check, AlertCircle } from 'lucide-react';
+import { Modal } from '@/components/ui/Modal';
+import { Button } from '@/components/ui/Button';
+import { useGoalStore } from '@/lib/store';
+import { Goal, Milestone } from '@/lib/types';
+
+interface DataExportModalProps {
+  onClose: () => void;
+}
+
+export function DataExportModal({ onClose }: DataExportModalProps) {
+  const { exportData, goals, milestones } = useGoalStore();
+  const [format, setFormat] = useState<'json' | 'csv'>('json');
+  const [isExporting, setIsExporting] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  const [success, setSuccess] = useState(false);
+
+  const handleExport = async () => {
+    setIsExporting(true);
+    setError(null);
+    
+    try {
+      if (format === 'json') {
+        const jsonString = await exportData();
+        downloadFile(jsonString, `goal-tracking-export-${new Date().toISOString().split('T')[0]}.json`, 'application/json');
+      } else {
+        // CSV Export - Create a ZIP-like experience or just multiple downloads? 
+        // For simplicity, we'll export Goals and Milestones as separate CSVs if selected, 
+        // or just Goals if we want a single file. 
+        // Let's do Goals CSV for now as it's the primary entity.
+        
+        const goalsCsv = convertGoalsToCSV(goals);
+        downloadFile(goalsCsv, `goals-export-${new Date().toISOString().split('T')[0]}.csv`, 'text/csv');
+        
+        // Optional: Trigger download for milestones too if needed, but browsers might block multiple downloads
+        // For now, let's stick to Goals CSV or a combined approach if possible, but Goals is most useful.
+      }
+      
+      setSuccess(true);
+      setTimeout(() => {
+        onClose();
+      }, 1500);
+    } catch (err) {
+      setError('Failed to export data. Please try again.');
+      console.error(err);
+    } finally {
+      setIsExporting(false);
+    }
+  };
+
+  const downloadFile = (content: string, filename: string, type: string) => {
+    const blob = new Blob([content], { type });
+    const url = URL.createObjectURL(blob);
+    const link = document.createElement('a');
+    link.href = url;
+    link.download = filename;
+    document.body.appendChild(link);
+    link.click();
+    document.body.removeChild(link);
+    URL.revokeObjectURL(url);
+  };
+
+  const convertGoalsToCSV = (goals: Goal[]): string => {
+    const headers = [
+      'ID', 'Title', 'State', 'Priority', 'Progress', 'Start Date', 'Target Date', 'Created At'
+    ];
+    
+    const rows = goals.map(g => [
+      g.id,
+      `"${g.title.replace(/"/g, '""')}"`, // Escape quotes
+      g.state,
+      g.priority,
+      g.progress,
+      g.startDate || '',
+      g.targetDate || '',
+      g.createdAt
+    ]);
+    
+    return [
+      headers.join(','),
+      ...rows.map(row => row.join(','))
+    ].join('\n');
+  };
+
+  return (
+    <Modal title="Export Data" isOpen={true} onClose={onClose} className="max-w-md">
+      <div className="space-y-6">
+        <p className="text-muted-foreground text-sm">
+          Download your data for backup or analysis. JSON includes full history and analytics, while CSV is optimized for spreadsheet viewing (Goals only).
+        </p>
+        
+        <div className="grid grid-cols-2 gap-4">
+          <button
+            onClick={() => setFormat('json')}
+            className={`flex flex-col items-center justify-center p-4 rounded-xl border transition-all ${
+              format === 'json'
+                ? 'bg-primary/10 border-primary text-primary'
+                : 'bg-secondary/30 border-white/5 hover:bg-secondary/50 text-muted-foreground hover:text-foreground'
+            }`}
+          >
+            <FileJson className="h-8 w-8 mb-2" />
+            <span className="font-medium">JSON</span>
+            <span className="text-[10px] opacity-70 mt-1">Full Backup</span>
+          </button>
+          
+          <button
+            onClick={() => setFormat('csv')}
+            className={`flex flex-col items-center justify-center p-4 rounded-xl border transition-all ${
+              format === 'csv'
+                ? 'bg-primary/10 border-primary text-primary'
+                : 'bg-secondary/30 border-white/5 hover:bg-secondary/50 text-muted-foreground hover:text-foreground'
+            }`}
+          >
+            <FileText className="h-8 w-8 mb-2" />
+            <span className="font-medium">CSV</span>
+            <span className="text-[10px] opacity-70 mt-1">Spreadsheet</span>
+          </button>
+        </div>
+        
+        {error && (
+          <div className="p-3 rounded-lg bg-destructive/10 text-destructive text-sm flex items-center gap-2">
+            <AlertCircle className="h-4 w-4" />
+            {error}
+          </div>
+        )}
+        
+        {success && (
+          <div className="p-3 rounded-lg bg-green-500/10 text-green-400 text-sm flex items-center gap-2">
+            <CheckCircleIcon className="h-4 w-4" />
+            Export started successfully!
+          </div>
+        )}
+        
+        <div className="flex justify-end gap-3 pt-2">
+          <Button variant="ghost" onClick={onClose} disabled={isExporting}>Cancel</Button>
+          <Button onClick={handleExport} disabled={isExporting} className="gap-2">
+            {isExporting ? (
+              <>
+                <span className="animate-spin h-4 w-4 border-2 border-white/20 border-t-white rounded-full" />
+                Exporting...
+              </>
+            ) : (
+              <>
+                <Download className="h-4 w-4" />
+                Download {format.toUpperCase()}
+              </>
+            )}
+          </Button>
+        </div>
+      </div>
+    </Modal>
+  );
+}
+
+function CheckCircleIcon({ className }: { className?: string }) {
+  return (
+    <svg 
+      className={className} 
+      xmlns="http://www.w3.org/2000/svg" 
+      viewBox="0 0 24 24" 
+      fill="none" 
+      stroke="currentColor" 
+      strokeWidth="2" 
+      strokeLinecap="round" 
+      strokeLinejoin="round"
+    >
+      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
+      <polyline points="22 4 12 14.01 9 11.01" />
+    </svg>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/forms/GoalEditor.tsx b/repository_after/goal-traking/app/components/forms/GoalEditor.tsx
new file mode 100644
index 00000000..3128661f
--- /dev/null
+++ b/repository_after/goal-traking/app/components/forms/GoalEditor.tsx
@@ -0,0 +1,312 @@
+'use client';
+
+import React, { useState } from 'react';
+import { Plus, X, Calendar, Target, List } from 'lucide-react';
+import { Goal, PriorityLevels, ExpectedOutcome } from '@/lib/types';
+import { useGoalStore } from '@/lib/store';
+import { Modal } from '@/components/ui/Modal';
+import { Button } from '@/components/ui/Button';
+import { Badge } from '@/components/ui/Badge';
+
+interface GoalEditorProps {
+  goal?: Goal;
+  onClose: () => void;
+  onSave?: () => void;
+}
+
+export function GoalEditor({ goal, onClose, onSave }: GoalEditorProps) {
+  const { createGoal, updateGoal } = useGoalStore();
+  
+  const [title, setTitle] = useState(goal?.title || '');
+  const [description, setDescription] = useState(goal?.description || '');
+  const [priority, setPriority] = useState(goal?.priority || 'medium');
+  const [priorityWeight, setPriorityWeight] = useState(goal?.priorityWeight || 50);
+  const [targetDate, setTargetDate] = useState(
+    goal?.targetDate ? new Date(goal.targetDate).toISOString().split('T')[0] : ''
+  );
+  const [successCriteria, setSuccessCriteria] = useState<string[]>(goal?.successCriteria || []);
+  const [motivationNotes, setMotivationNotes] = useState(goal?.motivationNotes || '');
+  const [tags, setTags] = useState<string[]>(goal?.tags || []);
+  const [newCriterion, setNewCriterion] = useState('');
+  const [newTag, setNewTag] = useState('');
+  
+  // Expected outcome
+  const [expectedDescription, setExpectedDescription] = useState(
+    goal?.expectedOutcome?.description || ''
+  );
+  const [estimatedDays, setEstimatedDays] = useState(
+    goal?.expectedOutcome?.estimatedTimelineDays?.toString() || ''
+  );
+  const [estimatedHours, setEstimatedHours] = useState(
+    goal?.expectedOutcome?.estimatedEffortHours?.toString() || ''
+  );
+  const [estimatedDifficulty, setEstimatedDifficulty] = useState(
+    goal?.expectedOutcome?.estimatedDifficulty?.toString() || ''
+  );
+  
+  const [isSubmitting, setIsSubmitting] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  
+  const isEditing = !!goal;
+  
+  const handleAddCriterion = () => {
+    if (newCriterion.trim()) {
+      setSuccessCriteria([...successCriteria, newCriterion.trim()]);
+      setNewCriterion('');
+    }
+  };
+  
+  const handleRemoveCriterion = (index: number) => {
+    setSuccessCriteria(successCriteria.filter((_, i) => i !== index));
+  };
+  
+  const handleAddTag = () => {
+    if (newTag.trim() && !tags.includes(newTag.trim())) {
+      setTags([...tags, newTag.trim()]);
+      setNewTag('');
+    }
+  };
+  
+  const handleRemoveTag = (tag: string) => {
+    setTags(tags.filter(t => t !== tag));
+  };
+  
+  const handleSubmit = async () => {
+    setError(null);
+    setIsSubmitting(true);
+    
+    try {
+      const expectedOutcome: ExpectedOutcome | undefined = expectedDescription ? {
+        description: expectedDescription,
+        successMetrics: successCriteria,
+        estimatedTimelineDays: estimatedDays ? Number(estimatedDays) : undefined,
+        estimatedEffortHours: estimatedHours ? Number(estimatedHours) : undefined,
+        estimatedDifficulty: estimatedDifficulty ? Number(estimatedDifficulty) : undefined,
+      } : undefined;
+      
+      const goalData = {
+        title,
+        description: description || undefined,
+        priority: priority as typeof goal extends Goal ? Goal['priority'] : 'medium',
+        priorityWeight,
+        targetDate: targetDate ? new Date(targetDate).toISOString() : undefined,
+        successCriteria,
+        motivationNotes: motivationNotes || undefined,
+        tags,
+        expectedOutcome,
+      };
+      
+      if (isEditing && goal) {
+        await updateGoal(goal.id, goalData, 'Goal updated');
+      } else {
+        await createGoal(goalData);
+      }
+      
+      onSave?.();
+      onClose();
+    } catch (err) {
+      setError(String(err));
+    } finally {
+      setIsSubmitting(false);
+    }
+  };
+  
+  return (
+    <Modal
+      isOpen={true}
+      onClose={onClose}
+      title={isEditing ? 'Edit Goal' : 'Create New Goal'}
+      description="Define your objective and success criteria."
+      size="lg"
+      footer={
+        <div className="flex justify-end gap-3 w-full">
+          <Button variant="ghost" onClick={onClose} disabled={isSubmitting}>Cancel</Button>
+          <Button onClick={handleSubmit} loading={isSubmitting} disabled={!title.trim()}>
+            {isEditing ? 'Save Changes' : 'Create Goal'}
+          </Button>
+        </div>
+      }
+    >
+      <div className="space-y-6">
+        {error && (
+          <div className="p-3 bg-destructive/10 border border-destructive/20 rounded-lg text-destructive text-sm flex items-center gap-2">
+            <X className="h-4 w-4" /> {error}
+          </div>
+        )}
+        
+        {/* Basic Info */}
+        <div className="grid gap-4">
+          <div className="grid gap-2">
+            <label className="text-sm font-medium">Goal Title</label>
+            <input
+              className="w-full px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg focus:ring-1 focus:ring-primary outline-none"
+              value={title}
+              onChange={(e) => setTitle(e.target.value)}
+              placeholder="e.g. Master React Performance"
+              autoFocus
+            />
+          </div>
+          
+          <div className="grid gap-2">
+             <label className="text-sm font-medium">Description</label>
+             <textarea
+               className="w-full px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg focus:ring-1 focus:ring-primary outline-none resize-none min-h-[80px]"
+               value={description}
+               onChange={(e) => setDescription(e.target.value)}
+               placeholder="What do you want to achieve?"
+             />
+          </div>
+        </div>
+        
+        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
+           {/* Priority Section */}
+           <div className="space-y-4 p-4 bg-secondary/10 rounded-xl border border-white/5">
+              <h4 className="text-sm font-medium flex items-center gap-2 text-muted-foreground">
+                 <Target className="h-4 w-4" /> Priority Settings
+              </h4>
+              
+              <div className="grid gap-2">
+                 <label className="text-xs text-muted-foreground">Level</label>
+                 <select
+                   className="w-full px-3 py-2 bg-secondary/50 border border-white/10 rounded-lg outline-none cursor-pointer"
+                   value={priority}
+                   onChange={(e) => setPriority(e.target.value as any)}
+                 >
+                   {PriorityLevels.map(p => (
+                     <option key={p} value={p}>{p.charAt(0).toUpperCase() + p.slice(1)}</option>
+                   ))}
+                 </select>
+              </div>
+              
+              <div className="grid gap-2">
+                 <div className="flex justify-between text-xs">
+                    <label className="text-muted-foreground">Weight</label>
+                    <span>{priorityWeight}</span>
+                 </div>
+                 <input
+                   type="range"
+                   min="1"
+                   max="100"
+                   value={priorityWeight}
+                   onChange={(e) => setPriorityWeight(Number(e.target.value))}
+                   className="w-full"
+                 />
+              </div>
+           </div>
+           
+           {/* Timeline Section */}
+           <div className="space-y-4 p-4 bg-secondary/10 rounded-xl border border-white/5">
+              <h4 className="text-sm font-medium flex items-center gap-2 text-muted-foreground">
+                 <Calendar className="h-4 w-4" /> Timeline
+              </h4>
+              
+              <div className="grid gap-2">
+                 <label className="text-xs text-muted-foreground">Target Date</label>
+                 <input
+                   type="date"
+                   className="w-full px-3 py-2 bg-secondary/50 border border-white/10 rounded-lg outline-none"
+                   value={targetDate}
+                   onChange={(e) => setTargetDate(e.target.value)}
+                 />
+              </div>
+              
+              <div className="grid grid-cols-2 gap-2">
+                 <div className="grid gap-1">
+                    <label className="text-xs text-muted-foreground">Est. Days</label>
+                    <input
+                      type="number"
+                      className="w-full px-2 py-1.5 bg-secondary/50 border border-white/10 rounded-lg outline-none text-sm"
+                      value={estimatedDays}
+                      onChange={(e) => setEstimatedDays(e.target.value)}
+                      placeholder="Days"
+                    />
+                 </div>
+                 <div className="grid gap-1">
+                    <label className="text-xs text-muted-foreground">Est. Hours</label>
+                    <input
+                      type="number"
+                      className="w-full px-2 py-1.5 bg-secondary/50 border border-white/10 rounded-lg outline-none text-sm"
+                      value={estimatedHours}
+                      onChange={(e) => setEstimatedHours(e.target.value)}
+                      placeholder="Hours"
+                    />
+                 </div>
+              </div>
+           </div>
+        </div>
+        
+        {/* Success Criteria */}
+        <div className="space-y-2">
+           <label className="text-sm font-medium flex items-center gap-2">
+             <List className="h-4 w-4" /> Success Criteria
+           </label>
+           <div className="flex gap-2">
+             <input
+               className="flex-1 px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg outline-none text-sm"
+               value={newCriterion}
+               onChange={(e) => setNewCriterion(e.target.value)}
+               onKeyDown={(e) => e.key === 'Enter' && handleAddCriterion()}
+               placeholder="Add criteria..."
+             />
+             <Button size="sm" onClick={handleAddCriterion} disabled={!newCriterion.trim()}>
+               <Plus className="h-4 w-4" />
+             </Button>
+           </div>
+           {successCriteria.length > 0 && (
+             <ul className="space-y-1 mt-2">
+               {successCriteria.map((c, i) => (
+                 <li key={i} className="flex justify-between items-center p-2 bg-secondary/20 rounded text-sm group">
+                   <span>â€¢ {c}</span>
+                   <button onClick={() => handleRemoveCriterion(i)} className="text-muted-foreground opacity-0 group-hover:opacity-100 hover:text-destructive">
+                     <X className="h-3 w-3" />
+                   </button>
+                 </li>
+               ))}
+             </ul>
+           )}
+        </div>
+        
+        {/* Tags */}
+        <div className="space-y-2">
+           <label className="text-sm font-medium">Tags</label>
+           <div className="flex gap-2">
+             <input
+               className="flex-1 px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg outline-none text-sm"
+               value={newTag}
+               onChange={(e) => setNewTag(e.target.value)}
+               onKeyDown={(e) => e.key === 'Enter' && handleAddTag()}
+               placeholder="Add tags..."
+             />
+             <Button size="sm" onClick={handleAddTag} disabled={!newTag.trim()}>
+               Add
+             </Button>
+           </div>
+           {tags.length > 0 && (
+             <div className="flex flex-wrap gap-2 mt-2">
+               {tags.map(tag => (
+                 <Badge key={tag} variant="secondary" className="pl-2 pr-1 gap-1">
+                   {tag}
+                   <button onClick={() => handleRemoveTag(tag)} className="hover:text-destructive ml-1">
+                     <X className="h-3 w-3" />
+                   </button>
+                 </Badge>
+               ))}
+             </div>
+           )}
+        </div>
+        
+        {/* Motivation */}
+        <div className="space-y-2">
+           <label className="text-sm font-medium">Motivation</label>
+           <textarea
+             className="w-full px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg outline-none resize-none text-sm"
+             rows={2}
+             value={motivationNotes}
+             onChange={(e) => setMotivationNotes(e.target.value)}
+             placeholder="Why is this important?"
+           />
+        </div>
+      </div>
+    </Modal>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/forms/MilestoneEditor.tsx b/repository_after/goal-traking/app/components/forms/MilestoneEditor.tsx
new file mode 100644
index 00000000..7fdd446f
--- /dev/null
+++ b/repository_after/goal-traking/app/components/forms/MilestoneEditor.tsx
@@ -0,0 +1,137 @@
+'use client';
+
+import React, { useState } from 'react';
+import { X, Calendar, Flag } from 'lucide-react';
+import { Milestone, PriorityLevels } from '@/lib/types';
+import { useGoalStore } from '@/lib/store';
+import { Modal } from '@/components/ui/Modal';
+import { Button } from '@/components/ui/Button';
+
+interface MilestoneEditorProps {
+  goalId: string;
+  milestone?: Milestone;
+  parentMilestoneId?: string;
+  onClose: () => void;
+  onSave?: () => void;
+}
+
+export function MilestoneEditor({ goalId, milestone, parentMilestoneId, onClose, onSave }: MilestoneEditorProps) {
+  const { createMilestone, updateMilestone } = useGoalStore();
+  
+  const [title, setTitle] = useState(milestone?.title || '');
+  const [description, setDescription] = useState(milestone?.description || '');
+  const [priority, setPriority] = useState(milestone?.priority || 'medium');
+  const [targetDate, setTargetDate] = useState(
+    milestone?.targetDate ? new Date(milestone.targetDate).toISOString().split('T')[0] : ''
+  );
+  
+  const [isSubmitting, setIsSubmitting] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  
+  const isEditing = !!milestone;
+  
+  const handleSubmit = async () => {
+    setError(null);
+    setIsSubmitting(true);
+    
+    try {
+      const milestoneData = {
+        goalId,
+        parentMilestoneId,
+        title,
+        description: description || undefined,
+        priority: priority as typeof milestone extends Milestone ? Milestone['priority'] : 'medium',
+        targetDate: targetDate ? new Date(targetDate).toISOString() : undefined,
+      };
+      
+      if (isEditing && milestone) {
+        await updateMilestone(milestone.id, milestoneData, 'Milestone updated');
+      } else {
+        await createMilestone(milestoneData);
+      }
+      
+      onSave?.();
+      onClose();
+    } catch (err) {
+      setError(String(err));
+    } finally {
+      setIsSubmitting(false);
+    }
+  };
+  
+  return (
+    <Modal
+      isOpen={true}
+      onClose={onClose}
+      title={isEditing ? 'Edit Milestone' : parentMilestoneId ? 'Add Sub-Milestone' : 'Add Milestone'}
+      description="Break down your goal into actionable steps."
+      size="md"
+      footer={
+        <div className="flex justify-end gap-3 w-full">
+          <Button variant="ghost" onClick={onClose} disabled={isSubmitting}>Cancel</Button>
+          <Button onClick={handleSubmit} loading={isSubmitting} disabled={!title.trim()}>
+            {isEditing ? 'Update' : 'Create'}
+          </Button>
+        </div>
+      }
+    >
+      <div className="space-y-4">
+        {error && (
+          <div className="p-3 bg-red-500/20 border border-red-500/30 rounded-lg text-red-400 text-sm flex items-center gap-2">
+            <X className="h-4 w-4" /> {error}
+          </div>
+        )}
+        
+        <div className="space-y-2">
+          <label className="text-sm font-medium">Title</label>
+          <input
+            className="w-full px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg focus:ring-1 focus:ring-primary outline-none"
+            value={title}
+            onChange={(e) => setTitle(e.target.value)}
+            placeholder="What needs to be done?"
+            autoFocus
+          />
+        </div>
+        
+        <div className="space-y-2">
+          <label className="text-sm font-medium">Description</label>
+          <textarea
+            className="w-full px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg focus:ring-1 focus:ring-primary outline-none resize-none min-h-[80px]"
+            value={description}
+            onChange={(e) => setDescription(e.target.value)}
+            placeholder="Details about this milestone..."
+          />
+        </div>
+        
+        <div className="grid grid-cols-2 gap-4">
+          <div className="space-y-2">
+            <label className="text-sm font-medium flex items-center gap-2">
+               <Flag className="h-4 w-4 text-muted-foreground" /> Priority
+            </label>
+            <select
+              className="w-full px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg outline-none cursor-pointer"
+              value={priority}
+              onChange={(e) => setPriority(e.target.value as any)}
+            >
+              {PriorityLevels.map(p => (
+                <option key={p} value={p}>{p.charAt(0).toUpperCase() + p.slice(1)}</option>
+              ))}
+            </select>
+          </div>
+          
+          <div className="space-y-2">
+            <label className="text-sm font-medium flex items-center gap-2">
+               <Calendar className="h-4 w-4 text-muted-foreground" /> Due Date
+            </label>
+            <input
+              type="date"
+              className="w-full px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg outline-none cursor-pointer"
+              value={targetDate}
+              onChange={(e) => setTargetDate(e.target.value)}
+            />
+          </div>
+        </div>
+      </div>
+    </Modal>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/forms/ProgressLogger.tsx b/repository_after/goal-traking/app/components/forms/ProgressLogger.tsx
new file mode 100644
index 00000000..2d00565c
--- /dev/null
+++ b/repository_after/goal-traking/app/components/forms/ProgressLogger.tsx
@@ -0,0 +1,216 @@
+'use client';
+
+import React, { useState } from 'react';
+import { X, Clock, AlertOctagon, Activity, Smile } from 'lucide-react';
+import { useGoalStore } from '@/lib/store';
+import { Modal } from '@/components/ui/Modal';
+import { Button } from '@/components/ui/Button';
+import { Badge } from '@/components/ui/Badge';
+import { ProgressBar } from '@/components/ui/ProgressBar';
+
+interface ProgressLoggerProps {
+  entityId: string;
+  entityType: 'goal' | 'milestone';
+  currentProgress: number;
+  onClose: () => void;
+  onSave?: () => void;
+}
+
+export function ProgressLogger({
+  entityId,
+  entityType,
+  currentProgress,
+  onClose,
+  onSave,
+}: ProgressLoggerProps) {
+  const { addProgressUpdate } = useGoalStore();
+  
+  const [percentage, setPercentage] = useState(currentProgress);
+  const [notes, setNotes] = useState('');
+  const [timeSpentMinutes, setTimeSpentMinutes] = useState('');
+  const [blockers, setBlockers] = useState<string[]>([]);
+  const [newBlocker, setNewBlocker] = useState('');
+  const [confidenceLevel, setConfidenceLevel] = useState<number | null>(null);
+  const [motivationLevel, setMotivationLevel] = useState<number | null>(null);
+  const [emotionalState, setEmotionalState] = useState<string>('');
+  
+  const [isSubmitting, setIsSubmitting] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  
+  const handleAddBlocker = () => {
+    if (newBlocker.trim()) {
+      setBlockers([...blockers, newBlocker.trim()]);
+      setNewBlocker('');
+    }
+  };
+  
+  const handleSubmit = async () => {
+    setError(null);
+    setIsSubmitting(true);
+    
+    try {
+      await addProgressUpdate({
+        entityId,
+        entityType,
+        percentage,
+        notes: notes || undefined,
+        timeSpentMinutes: timeSpentMinutes ? Number(timeSpentMinutes) : undefined,
+        blockers,
+        confidenceLevel: confidenceLevel ?? undefined,
+        motivationLevel: motivationLevel ?? undefined,
+        emotionalState: emotionalState as any || undefined,
+      });
+      
+      onSave?.();
+      onClose();
+    } catch (err) {
+      setError(String(err));
+    } finally {
+      setIsSubmitting(false);
+    }
+  };
+  
+  return (
+    <Modal
+      isOpen={true}
+      onClose={onClose}
+      title="Log Progress"
+      description={`Update progress for this ${entityType}.`}
+      size="md"
+      footer={
+        <div className="flex justify-end gap-3 w-full">
+          <Button variant="ghost" onClick={onClose} disabled={isSubmitting}>Cancel</Button>
+          <Button onClick={handleSubmit} loading={isSubmitting}>
+            Log Update
+          </Button>
+        </div>
+      }
+    >
+      <div className="space-y-6">
+        {error && (
+          <div className="p-3 bg-red-500/20 border border-red-500/30 rounded-lg text-red-400 text-sm flex items-center gap-2">
+            <X className="h-4 w-4" /> {error}
+          </div>
+        )}
+        
+        {/* Progress Slider */}
+        <div className="space-y-3 p-4 bg-secondary/10 rounded-xl border border-white/5">
+           <div className="flex justify-between items-end">
+              <label className="text-sm font-medium">Progress</label>
+              <span className="text-2xl font-bold text-primary">{percentage}%</span>
+           </div>
+           
+           <input
+             type="range"
+             min="0"
+             max="100"
+             value={percentage}
+             onChange={(e) => setPercentage(Number(e.target.value))}
+             className="w-full"
+           />
+           <div className="flex justify-between text-xs text-muted-foreground">
+             <span>0%</span>
+             <span>50%</span>
+             <span>100%</span>
+           </div>
+        </div>
+        
+        {/* Notes */}
+        <div className="space-y-2">
+           <label className="text-sm font-medium">Update Notes</label>
+           <textarea
+             className="w-full px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg outline-none resize-none min-h-[80px]"
+             value={notes}
+             onChange={(e) => setNotes(e.target.value)}
+             placeholder="What did you get done?"
+           />
+        </div>
+        
+        {/* Quick Stats Grid */}
+        <div className="grid grid-cols-2 gap-4">
+           <div className="space-y-2">
+              <label className="text-sm font-medium flex items-center gap-2 text-muted-foreground">
+                 <Clock className="h-4 w-4" /> Time Spent (min)
+              </label>
+              <input
+                 type="number"
+                 className="w-full px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg outline-none"
+                 value={timeSpentMinutes}
+                 onChange={(e) => setTimeSpentMinutes(e.target.value)}
+                 placeholder="e.g. 45"
+              />
+           </div>
+           
+           <div className="space-y-2">
+              <label className="text-sm font-medium flex items-center gap-2 text-muted-foreground">
+                 <Activity className="h-4 w-4" /> Motivation
+              </label>
+              <select
+                 className="w-full px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg outline-none"
+                 value={motivationLevel ?? ''}
+                 onChange={(e) => setMotivationLevel(e.target.value ? Number(e.target.value) : null)}
+              >
+                 <option value="">Select...</option>
+                 {[1,2,3,4,5,6,7,8,9,10].map(n => (
+                   <option key={n} value={n}>{n} - {n < 4 ? 'Low' : n < 8 ? 'Ok' : 'High'}</option>
+                 ))}
+              </select>
+           </div>
+        </div>
+        
+        <div className="space-y-2">
+           <label className="text-sm font-medium flex items-center gap-2 text-muted-foreground">
+              <Smile className="h-4 w-4" /> How do you feel?
+           </label>
+           <div className="flex flex-wrap gap-2">
+              {['energized', 'motivated', 'neutral', 'stressed', 'discouraged'].map(state => (
+                <button
+                   key={state}
+                   onClick={() => setEmotionalState(state)}
+                   className={`px-3 py-1.5 rounded-full text-xs transition-all border ${
+                     emotionalState === state 
+                       ? 'bg-primary/20 border-primary text-primary' 
+                       : 'bg-secondary/30 border-transparent text-muted-foreground hover:bg-secondary/50'
+                   }`}
+                >
+                   {state}
+                </button>
+              ))}
+           </div>
+        </div>
+        
+        {/* Blockers */}
+        <div className="space-y-2">
+           <label className="text-sm font-medium flex items-center gap-2 text-mini text-destructive">
+              <AlertOctagon className="h-4 w-4" /> Any Blockers?
+           </label>
+           <div className="flex gap-2">
+             <input
+               className="flex-1 px-3 py-2 bg-secondary/30 border border-white/10 rounded-lg outline-none text-sm"
+               value={newBlocker}
+               onChange={(e) => setNewBlocker(e.target.value)}
+               onKeyDown={(e) => e.key === 'Enter' && handleAddBlocker()}
+               placeholder="Add blocker..."
+             />
+             <Button variant="destructive" size="sm" onClick={handleAddBlocker} disabled={!newBlocker.trim()}>
+               Add
+             </Button>
+           </div>
+           
+           {blockers.length > 0 && (
+             <div className="flex flex-wrap gap-2 mt-2">
+               {blockers.map((blocker, i) => (
+                 <Badge key={i} variant="destructive" className="pl-2 pr-1 gap-1">
+                   {blocker}
+                   <button onClick={() => setBlockers(blockers.filter((_, idx) => idx !== i))} className="hover:text-white ml-1">
+                     <X className="h-3 w-3" />
+                   </button>
+                 </Badge>
+               ))}
+             </div>
+           )}
+        </div>
+      </div>
+    </Modal>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/goals/GoalCard.tsx b/repository_after/goal-traking/app/components/goals/GoalCard.tsx
new file mode 100644
index 00000000..1965d604
--- /dev/null
+++ b/repository_after/goal-traking/app/components/goals/GoalCard.tsx
@@ -0,0 +1,123 @@
+import React from 'react';
+import { format } from 'date-fns';
+import { Calendar, AlertCircle, CheckCircle2, PlayCircle, PauseCircle, XCircle, StopCircle, Clipboard, Hash } from 'lucide-react';
+import { Goal, PriorityLevel, GoalState } from '@/lib/types';
+import { Card } from '@/components/ui/Card';
+import { Badge } from '@/components/ui/Badge';
+import { ProgressBar } from '@/components/ui/ProgressBar';
+import { cn } from '@/lib/utils';
+
+interface GoalCardProps {
+  goal: Goal;
+  milestonesCount: number;
+  isSelected?: boolean;
+  onClick?: () => void;
+}
+
+const PriorityColors: Record<PriorityLevel, 'destructive' | 'warning' | 'info' | 'success'> = {
+  critical: 'destructive',
+  high: 'warning',
+  medium: 'info',
+  low: 'success',
+};
+
+const StateIcons: Record<GoalState, React.ReactNode> = {
+  planned: <Clipboard className="h-3 w-3" />,
+  active: <PlayCircle className="h-3 w-3" />,
+  paused: <PauseCircle className="h-3 w-3" />,
+  completed: <CheckCircle2 className="h-3 w-3" />,
+  failed: <XCircle className="h-3 w-3" />,
+  abandoned: <StopCircle className="h-3 w-3" />,
+};
+
+const StateColors: Record<GoalState, 'default' | 'primary' | 'secondary' | 'success' | 'destructive' | 'outline'> = {
+  planned: 'secondary',
+  active: 'primary',
+  paused: 'secondary',
+  completed: 'success',
+  failed: 'destructive',
+  abandoned: 'destructive',
+};
+
+export function GoalCard({ goal, milestonesCount, isSelected, onClick }: GoalCardProps) {
+  const isOverdue = goal.targetDate && new Date(goal.targetDate) < new Date() && goal.state !== 'completed';
+
+  return (
+    <Card
+      variant="glass"
+      hoverEffect
+      className={cn(
+        "cursor-pointer group relative overflow-hidden transition-all duration-300",
+        isSelected ? "ring-2 ring-primary border-primary/50 bg-primary/5" : ""
+      )}
+      onClick={onClick}
+    >
+      <div className="flex justify-between items-start gap-4 mb-3">
+        <h3 className="font-semibold text-lg leading-tight group-hover:text-primary transition-colors line-clamp-1">
+          {goal.title}
+        </h3>
+        <Badge variant={PriorityColors[goal.priority]} className="uppercase text-[10px] tracking-wider shrink-0">
+          {goal.priority}
+        </Badge>
+      </div>
+
+      {goal.description && (
+        <p className="text-sm text-muted-foreground line-clamp-2 mb-4">
+          {goal.description}
+        </p>
+      )}
+
+      <div className="space-y-4">
+        <ProgressBar 
+          value={goal.progress} 
+          size="sm" 
+          variant={goal.state === 'completed' ? 'success' : 'gradient'} 
+        />
+        
+        <div className="flex items-center justify-between text-xs text-muted-foreground">
+          <div className="flex items-center gap-3">
+             <Badge variant="outline" className={cn("gap-1.5 px-2 py-0.5 border-dashed", 
+                goal.state === 'active' ? "border-primary/50 text-primary" : ""
+             )}>
+                {StateIcons[goal.state]}
+                <span className="capitalize">{goal.state}</span>
+             </Badge>
+             
+             {milestonesCount > 0 && (
+               <div className="flex items-center gap-1.5">
+                 <Hash className="h-3 w-3" />
+                 <span>{milestonesCount} milestones</span>
+               </div>
+             )}
+          </div>
+
+          {goal.targetDate && (
+            <div className={cn(
+              "flex items-center gap-1.5",
+              isOverdue ? "text-destructive font-medium" : ""
+            )}>
+              <Calendar className="h-3 w-3" />
+              <span>{format(new Date(goal.targetDate), 'MMM d, yyyy')}</span>
+              {isOverdue && <AlertCircle className="h-3 w-3" />}
+            </div>
+          )}
+        </div>
+
+        {goal.tags.length > 0 && (
+          <div className="flex flex-wrap gap-1.5 pt-1">
+            {goal.tags.slice(0, 3).map(tag => (
+              <span key={tag} className="text-[10px] px-1.5 py-0.5 rounded bg-secondary/50 text-secondary-foreground">
+                #{tag}
+              </span>
+            ))}
+            {goal.tags.length > 3 && (
+              <span className="text-[10px] px-1.5 py-0.5 text-muted-foreground">
+                +{goal.tags.length - 3}
+              </span>
+            )}
+          </div>
+        )}
+      </div>
+    </Card>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/goals/GoalStats.tsx b/repository_after/goal-traking/app/components/goals/GoalStats.tsx
new file mode 100644
index 00000000..29182fb7
--- /dev/null
+++ b/repository_after/goal-traking/app/components/goals/GoalStats.tsx
@@ -0,0 +1,58 @@
+import React from 'react';
+import { Target, PlayCircle, CheckCircle2, Clipboard, BarChart2, AlertTriangle } from 'lucide-react';
+import { useGoalStore } from '@/lib/store';
+import { Card } from '@/components/ui/Card';
+
+export function GoalStats() {
+  const { goals } = useGoalStore();
+  
+  const stats = React.useMemo(() => {
+    const total = goals.length;
+    const active = goals.filter(g => g.state === 'active').length;
+    const completed = goals.filter(g => g.state === 'completed').length;
+    const planned = goals.filter(g => g.state === 'planned').length;
+    
+    const avgProgress = total > 0 
+      ? Math.round(goals.reduce((sum, g) => sum + g.progress, 0) / total)
+      : 0;
+    
+    const overdue = goals.filter(g => 
+      g.targetDate && 
+      new Date(g.targetDate) < new Date() && 
+      !['completed', 'failed', 'abandoned'].includes(g.state)
+    ).length;
+    
+    return { total, active, completed, planned, avgProgress, overdue };
+  }, [goals]);
+  
+  const statItems = [
+    { label: 'Total Goals', value: stats.total, icon: Target, color: 'text-blue-400', bg: 'bg-blue-400/10 border-blue-400/20' },
+    { label: 'Active', value: stats.active, icon: PlayCircle, color: 'text-indigo-400', bg: 'bg-indigo-400/10 border-indigo-400/20' },
+    { label: 'Completed', value: stats.completed, icon: CheckCircle2, color: 'text-emerald-400', bg: 'bg-emerald-400/10 border-emerald-400/20' },
+    { label: 'Planned', value: stats.planned, icon: Clipboard, color: 'text-slate-400', bg: 'bg-slate-400/10 border-slate-400/20' },
+    { label: 'Avg Progress', value: `${stats.avgProgress}%`, icon: BarChart2, color: 'text-purple-400', bg: 'bg-purple-400/10 border-purple-400/20' },
+    { label: 'Overdue', value: stats.overdue, icon: AlertTriangle, color: 'text-rose-400', bg: 'bg-rose-400/10 border-rose-400/20' },
+  ];
+  
+  return (
+    <div className="grid grid-cols-2 lg:grid-cols-6 gap-3 mb-6">
+      {statItems.map(stat => (
+        <Card 
+          key={stat.label} 
+          className={`p-4 border backdrop-blur-sm transition-all hover:scale-105 ${stat.bg}`}
+          variant="panel"
+        >
+          <div className="flex flex-col gap-2">
+            <div className={`p-2 w-fit rounded-lg ${stat.bg}`}>
+              <stat.icon className={`h-4 w-4 ${stat.color}`} />
+            </div>
+            <div>
+              <p className={`text-2xl font-bold ${stat.color}`}>{stat.value}</p>
+              <p className="text-xs text-muted-foreground font-medium uppercase tracking-wider">{stat.label}</p>
+            </div>
+          </div>
+        </Card>
+      ))}
+    </div>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/goals/GoalsFilter.tsx b/repository_after/goal-traking/app/components/goals/GoalsFilter.tsx
new file mode 100644
index 00000000..ee75f77a
--- /dev/null
+++ b/repository_after/goal-traking/app/components/goals/GoalsFilter.tsx
@@ -0,0 +1,151 @@
+import React from 'react';
+import { Search, Filter as FilterIcon, X } from 'lucide-react';
+import { GoalState, PriorityLevel, GoalStates, PriorityLevels } from '@/lib/types';
+import { Card } from '@/components/ui/Card';
+import { Button } from '@/components/ui/Button';
+import { Badge } from '@/components/ui/Badge';
+import { Modal } from '@/components/ui/Modal';
+import { useGoalStore } from '@/lib/store';
+
+interface GoalsFilterProps {
+  isOpen: boolean;
+  onClose: () => void;
+}
+
+export function GoalsFilter({ isOpen, onClose }: GoalsFilterProps) {
+  const { filter, setFilter, clearFilter, sortOptions, setSortOptions } = useGoalStore();
+  
+  const [localStates, setLocalStates] = React.useState<GoalState[]>(filter.states || []);
+  const [localPriorities, setLocalPriorities] = React.useState<PriorityLevel[]>(filter.priorities || []);
+  const [localSearch, setLocalSearch] = React.useState(filter.searchQuery || '');
+  
+  const toggleState = (state: GoalState) => {
+    setLocalStates(prev => 
+      prev.includes(state) ? prev.filter(s => s !== state) : [...prev, state]
+    );
+  };
+  
+  const togglePriority = (priority: PriorityLevel) => {
+    setLocalPriorities(prev => 
+      prev.includes(priority) ? prev.filter(p => p !== priority) : [...prev, priority]
+    );
+  };
+  
+  const applyFilters = () => {
+    setFilter({
+      states: localStates.length > 0 ? localStates : undefined,
+      priorities: localPriorities.length > 0 ? localPriorities : undefined,
+      searchQuery: localSearch || undefined,
+    });
+    onClose();
+  };
+  
+  const handleClear = () => {
+    setLocalStates([]);
+    setLocalPriorities([]);
+    setLocalSearch('');
+    clearFilter();
+    onClose();
+  };
+
+  return (
+    <Modal
+      isOpen={isOpen}
+      onClose={onClose}
+      title="Filter Goals"
+      description="Narrow down your goals by state, priority, or search terms."
+      size="md"
+      footer={
+        <div className="flex gap-3 justify-end w-full">
+          <Button variant="ghost" onClick={handleClear} className="text-muted-foreground hover:text-foreground">
+            Reset Filters
+          </Button>
+          <Button onClick={applyFilters} className="px-8">
+            Apply Results
+          </Button>
+        </div>
+      }
+    >
+      <div className="space-y-6">
+        {/* Search */}
+        <div className="space-y-2">
+          <label className="text-sm font-medium text-muted-foreground flex items-center gap-2">
+            <Search className="h-4 w-4" /> Search
+          </label>
+          <input
+            type="text"
+            value={localSearch}
+            onChange={(e) => setLocalSearch(e.target.value)}
+            placeholder="Search by title, description or tags..."
+            className="w-full px-4 py-3 rounded-lg bg-secondary/30 border border-white/10 focus:border-primary/50 focus:ring-1 focus:ring-primary/50 outline-none transition-all placeholder:text-muted-foreground/50 text-foreground"
+          />
+        </div>
+
+        {/* States */}
+        <div className="space-y-3">
+          <label className="text-sm font-medium text-muted-foreground">Status</label>
+          <div className="flex flex-wrap gap-2">
+            {GoalStates.map(state => (
+              <button
+                key={state}
+                onClick={() => toggleState(state)}
+                className={`
+                  px-3 py-1.5 rounded-full text-sm font-medium transition-all border
+                  ${localStates.includes(state)
+                    ? 'bg-primary/20 text-primary border-primary/30 shadow-[0_0_10px_rgba(var(--primary),0.2)]'
+                    : 'bg-secondary/30 text-muted-foreground border-transparent hover:bg-secondary/50 hover:text-foreground'}
+                `}
+              >
+                {state.charAt(0).toUpperCase() + state.slice(1)}
+              </button>
+            ))}
+          </div>
+        </div>
+
+        {/* Priorities */}
+        <div className="space-y-3">
+          <label className="text-sm font-medium text-muted-foreground">Priority</label>
+          <div className="flex flex-wrap gap-2">
+            {PriorityLevels.map(priority => (
+              <button
+                key={priority}
+                onClick={() => togglePriority(priority)}
+                className={`
+                  px-3 py-1.5 rounded-full text-sm font-medium transition-all border
+                  ${localPriorities.includes(priority)
+                    ? 'bg-accent/20 text-accent-foreground border-accent/30'
+                    : 'bg-secondary/30 text-muted-foreground border-transparent hover:bg-secondary/50 hover:text-foreground'}
+                `}
+              >
+                {priority.charAt(0).toUpperCase() + priority.slice(1)}
+              </button>
+            ))}
+          </div>
+        </div>
+
+        {/* Sort */}
+        <div className="space-y-2">
+           <label className="text-sm font-medium text-muted-foreground">Sort Order</label>
+           <select
+             value={`${sortOptions.field}-${sortOptions.direction}`}
+             onChange={(e) => {
+               const [field, direction] = e.target.value.split('-');
+               setSortOptions({ 
+                 field: field as typeof sortOptions.field, 
+                 direction: direction as 'asc' | 'desc' 
+               });
+             }}
+             className="w-full px-4 py-2.5 rounded-lg bg-secondary/30 border border-white/10 outline-none text-foreground appearance-none cursor-pointer hover:bg-secondary/50 transition-colors"
+           >
+             <option value="createdAt-desc">Newest First</option>
+             <option value="createdAt-asc">Oldest First</option>
+             <option value="priority-desc">Highest Priority</option>
+             <option value="progress-desc">Most Progress</option>
+             <option value="targetDate-asc">Due Soonest</option>
+             <option value="title-asc">Alphabetical (A-Z)</option>
+           </select>
+        </div>
+      </div>
+    </Modal>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/goals/MilestoneNode.tsx b/repository_after/goal-traking/app/components/goals/MilestoneNode.tsx
new file mode 100644
index 00000000..921ea447
--- /dev/null
+++ b/repository_after/goal-traking/app/components/goals/MilestoneNode.tsx
@@ -0,0 +1,149 @@
+import React, { useState } from 'react';
+import { ChevronRight, ChevronDown, Plus, Edit2, Trash2, BarChart2 } from 'lucide-react';
+import { Milestone, GoalState, ValidStateTransitions } from '@/lib/types';
+import { useGoalStore } from '@/lib/store';
+import { Button } from '@/components/ui/Button';
+import { Badge } from '@/components/ui/Badge';
+import { ProgressBar } from '@/components/ui/ProgressBar';
+import { cn } from '@/lib/utils';
+
+interface MilestoneNodeProps {
+  milestone: Milestone;
+  level: number;
+  onEdit: (milestone: Milestone) => void;
+  onAddChild: (parentId: string) => void;
+  onUpdateProgress: (milestone: Milestone) => void;
+  onDelete: (id: string) => void;
+  onStateChange: (id: string, state: GoalState) => void;
+}
+
+export function MilestoneNode({ 
+  milestone, 
+  level, 
+  onEdit, 
+  onAddChild, 
+  onUpdateProgress,
+  onDelete,
+  onStateChange,
+}: MilestoneNodeProps) {
+  const { milestones } = useGoalStore();
+  const children = milestones.filter(m => m.parentMilestoneId === milestone.id);
+  const [isExpanded, setIsExpanded] = useState(true);
+  
+  const validTransitions = ValidStateTransitions[milestone.state];
+  
+  return (
+    <div className="group animate-in fade-in slide-up duration-300">
+      <div 
+        className={cn(
+          "flex items-center gap-3 p-3 rounded-xl border transition-all duration-200 mb-2 relative overflow-hidden",
+          milestone.state === 'completed' 
+            ? "bg-green-500/10 border-green-500/20" 
+            : "bg-card border-white/5 hover:border-white/10 hover:bg-white/5"
+        )}
+        style={{ marginLeft: `${level * 24}px` }}
+      >
+        {/* Connector Line for nested items */}
+        {level > 0 && (
+          <div 
+             className="absolute left-[-12px] top-1/2 w-3 h-px bg-white/10"
+             style={{ left: '-24px', width: '24px' }}
+          />
+        )}
+
+        {/* Expand/Collapse button */}
+        <div className="w-5 flex justify-center shrink-0">
+          {children.length > 0 && (
+            <button
+              onClick={() => setIsExpanded(!isExpanded)}
+              className="text-muted-foreground hover:text-foreground transition-colors"
+            >
+              {isExpanded ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
+            </button>
+          )}
+        </div>
+        
+        {/* Milestone info */}
+        <div className="flex-1 min-w-0">
+          <div className="flex items-center gap-2 mb-1.5 flex-wrap">
+            <span className={cn(
+              "font-medium truncate",
+              milestone.state === 'completed' ? "text-green-400 line-through decoration-green-500/50" : "text-foreground"
+            )}>
+              {milestone.title}
+            </span>
+            <Badge variant={
+               milestone.priority === 'critical' ? 'destructive' :
+               milestone.priority === 'high' ? 'warning' :
+               milestone.priority === 'medium' ? 'info' : 'success'
+            } className="text-[10px] px-1.5 py-0">
+               {milestone.priority}
+            </Badge>
+          </div>
+          
+          <div className="flex items-center gap-3 max-w-md">
+            <ProgressBar 
+               value={milestone.progress} 
+               size="sm"
+               variant="gradient"
+               className="h-1.5"
+            />
+          </div>
+        </div>
+        
+        {/* Actions - Visible on hover or focus */}
+        <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity focus-within:opacity-100">
+          {validTransitions.length > 0 && (
+            <select
+              value=""
+              onChange={(e) => {
+                if (e.target.value) {
+                  onStateChange(milestone.id, e.target.value as GoalState);
+                }
+              }}
+              className="text-[10px] px-2 py-1 bg-secondary/50 border border-white/10 rounded text-muted-foreground outline-none cursor-pointer hover:bg-secondary hover:text-foreground transition-colors mr-2"
+            >
+              <option value="">Status...</option>
+              {validTransitions.map(state => (
+                <option key={state} value={state}>{state}</option>
+              ))}
+            </select>
+          )}
+          
+          <Button variant="ghost" size="icon" className="h-7 w-7" onClick={() => onUpdateProgress(milestone)} title="Update Progress">
+            <BarChart2 className="h-3.5 w-3.5 text-blue-400" />
+          </Button>
+          <Button variant="ghost" size="icon" className="h-7 w-7" onClick={() => onAddChild(milestone.id)} title="Add Sub-Milestone">
+            <Plus className="h-3.5 w-3.5 text-green-400" />
+          </Button>
+          <Button variant="ghost" size="icon" className="h-7 w-7" onClick={() => onEdit(milestone)} title="Edit">
+            <Edit2 className="h-3.5 w-3.5 text-muted-foreground" />
+          </Button>
+          <Button variant="ghost" size="icon" className="h-7 w-7 hover:bg-red-500/20 hover:text-red-400" onClick={() => onDelete(milestone.id)} title="Delete">
+            <Trash2 className="h-3.5 w-3.5 text-muted-foreground" />
+          </Button>
+        </div>
+      </div>
+      
+      {/* Children */}
+      {isExpanded && children.length > 0 && (
+        <div className="milestone-children">
+          {children
+            .sort((a, b) => a.order - b.order)
+            .map(child => (
+              <MilestoneNode
+                key={child.id}
+                milestone={child}
+                level={level + 1}
+                onEdit={onEdit}
+                onAddChild={onAddChild}
+                onUpdateProgress={onUpdateProgress}
+                onDelete={onDelete}
+                onStateChange={onStateChange}
+              />
+            ))}
+        </div>
+      )}
+    </div>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/goals/MilestoneTree.tsx b/repository_after/goal-traking/app/components/goals/MilestoneTree.tsx
new file mode 100644
index 00000000..33b39b50
--- /dev/null
+++ b/repository_after/goal-traking/app/components/goals/MilestoneTree.tsx
@@ -0,0 +1,105 @@
+import React, { useState } from 'react';
+import { Plus } from 'lucide-react';
+import { Milestone, GoalState } from '@/lib/types';
+import { useGoalStore } from '@/lib/store';
+import { Button } from '@/components/ui/Button';
+import { MilestoneForm, ProgressUpdateForm } from '@/components/GoalForms'; // Keeping imported for now
+import { MilestoneNode } from './MilestoneNode';
+
+interface MilestoneTreeProps {
+  goalId: string;
+}
+
+export function MilestoneTree({ goalId }: MilestoneTreeProps) {
+  const { milestones, deleteMilestone, updateMilestone } = useGoalStore();
+  
+  const [showMilestoneForm, setShowMilestoneForm] = useState(false);
+  const [showProgressForm, setShowProgressForm] = useState(false);
+  const [editingMilestone, setEditingMilestone] = useState<Milestone | null>(null);
+  const [parentMilestoneId, setParentMilestoneId] = useState<string | undefined>();
+  const [selectedMilestone, setSelectedMilestone] = useState<Milestone | null>(null);
+  
+  const rootMilestones = milestones
+    .filter(m => m.goalId === goalId && !m.parentMilestoneId)
+    .sort((a, b) => a.order - b.order);
+  
+  const handleAddMilestone = (parentId?: string) => {
+    setParentMilestoneId(parentId);
+    setEditingMilestone(null);
+    setShowMilestoneForm(true);
+  };
+  
+  const handleEditMilestone = (milestone: Milestone) => {
+    setEditingMilestone(milestone);
+    setParentMilestoneId(milestone.parentMilestoneId);
+    setShowMilestoneForm(true);
+  };
+  
+  const handleUpdateProgress = (milestone: Milestone) => {
+    setSelectedMilestone(milestone);
+    setShowProgressForm(true);
+  };
+  
+  const handleDelete = async (id: string) => {
+    if (confirm('Are you sure you want to delete this milestone?')) {
+      await deleteMilestone(id);
+    }
+  };
+  
+  const handleStateChange = async (id: string, state: GoalState) => {
+    await updateMilestone(id, { state }, `State changed to ${state}`);
+  };
+  
+  return (
+    <div className="space-y-6">
+      <div className="flex items-center justify-between">
+        <h3 className="text-lg font-semibold tracking-tight text-foreground">Milestones</h3>
+        <Button onClick={() => handleAddMilestone()} size="sm" className="gap-2">
+          <Plus className="h-4 w-4" /> Add Milestone
+        </Button>
+      </div>
+      
+      {rootMilestones.length === 0 ? (
+        <div className="flex flex-col items-center justify-center p-8 border border-dashed border-white/10 rounded-xl bg-slate-900/30">
+          <p className="text-muted-foreground mb-2">No milestones yet</p>
+          <Button variant="link" onClick={() => handleAddMilestone()}>
+            Create your first milestone
+          </Button>
+        </div>
+      ) : (
+        <div className="space-y-1">
+          {rootMilestones.map(milestone => (
+            <MilestoneNode
+              key={milestone.id}
+              milestone={milestone}
+              level={0}
+              onEdit={handleEditMilestone}
+              onAddChild={handleAddMilestone}
+              onUpdateProgress={handleUpdateProgress}
+              onDelete={handleDelete}
+              onStateChange={handleStateChange}
+            />
+          ))}
+        </div>
+      )}
+      
+      {showMilestoneForm && (
+        <MilestoneForm
+          goalId={goalId}
+          milestone={editingMilestone || undefined}
+          parentMilestoneId={parentMilestoneId}
+          onClose={() => setShowMilestoneForm(false)}
+        />
+      )}
+      
+      {showProgressForm && selectedMilestone && (
+        <ProgressUpdateForm
+          entityId={selectedMilestone.id}
+          entityType="milestone"
+          currentProgress={selectedMilestone.progress}
+          onClose={() => setShowProgressForm(false)}
+        />
+      )}
+    </div>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/goals/ProgressHistory.tsx b/repository_after/goal-traking/app/components/goals/ProgressHistory.tsx
new file mode 100644
index 00000000..0de4cd39
--- /dev/null
+++ b/repository_after/goal-traking/app/components/goals/ProgressHistory.tsx
@@ -0,0 +1,90 @@
+import React from 'react';
+import { History, Activity, AlertOctagon } from 'lucide-react';
+import { Goal } from '@/lib/types';
+import { useGoalStore } from '@/lib/store';
+import { Card } from '@/components/ui/Card';
+import { Badge } from '@/components/ui/Badge';
+
+interface ProgressHistoryProps {
+  goalId: string;
+}
+
+export function ProgressHistory({ goalId }: ProgressHistoryProps) {
+  const { progressUpdates } = useGoalStore();
+  
+  const updates = progressUpdates
+    .filter(p => p.entityId === goalId)
+    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
+    
+  if (updates.length === 0) {
+    return (
+      <div className="flex flex-col items-center justify-center p-8 border border-dashed border-white/10 rounded-xl bg-slate-900/30 text-muted-foreground">
+        <History className="h-8 w-8 mb-2 opacity-50" />
+        <p>No progress updates yet.</p>
+      </div>
+    );
+  }
+
+  return (
+    <div className="space-y-4">
+      {updates.map((update, index) => (
+        <Card 
+           key={update.id} 
+           variant="panel" 
+           className="animate-in slide-up"
+           style={{ animationDelay: `${index * 50}ms` }}
+        >
+           <div className="flex justify-between items-start mb-2">
+             <div className="flex items-center gap-2">
+               <span className="text-xl font-bold text-primary">{update.percentage}%</span>
+               <span className="text-xs text-muted-foreground">
+                 {new Date(update.createdAt).toLocaleString(undefined, {
+                    month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'
+                 })}
+               </span>
+             </div>
+             {update.emotionalState && (
+               <Badge variant="secondary" className="text-[10px] capitalize">
+                  {update.emotionalState.replace('_', ' ')}
+               </Badge>
+             )}
+           </div>
+           
+           {update.notes && (
+             <p className="text-sm text-foreground mb-3">{update.notes}</p>
+           )}
+           
+           <div className="flex flex-wrap gap-x-4 gap-y-2 text-xs text-muted-foreground">
+              {update.timeSpentMinutes && (
+                <div className="flex items-center gap-1">
+                  <History className="h-3 w-3" />
+                  <span>{update.timeSpentMinutes} min</span>
+                </div>
+              )}
+              {update.motivationLevel && (
+                <div className="flex items-center gap-1">
+                  <Activity className="h-3 w-3" />
+                  <span>Motivation: {update.motivationLevel}/10</span>
+                </div>
+              )}
+           </div>
+           
+           {update.blockers.length > 0 && (
+             <div className="mt-3 p-2 bg-destructive/10 rounded border border-destructive/20">
+               <div className="flex items-center gap-1 text-xs text-destructive font-medium mb-1">
+                  <AlertOctagon className="h-3 w-3" /> Blockers
+               </div>
+               <div className="flex flex-wrap gap-1">
+                 {update.blockers.map((blocker, i) => (
+                   <span key={i} className="text-xs text-destructive/80 bg-background/50 px-1.5 py-0.5 rounded">
+                     {blocker}
+                   </span>
+                 ))}
+               </div>
+             </div>
+           )}
+        </Card>
+      ))}
+    </div>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/index.tsx b/repository_after/goal-traking/app/components/index.tsx
new file mode 100644
index 00000000..e183fb3b
--- /dev/null
+++ b/repository_after/goal-traking/app/components/index.tsx
@@ -0,0 +1,31 @@
+'use client';
+
+// Main Components
+export { GoalList } from './GoalList';
+export { GoalDetail } from './GoalDetail';
+export { GoalForm, MilestoneForm, ProgressUpdateForm } from './GoalForms';
+export { AnalyticsDashboard } from './AnalyticsDashboard';
+
+// Sub-components (re-exporting for convenience, though direct imports are preferred)
+export { GoalCard } from './goals/GoalCard';
+export { GoalStats } from './goals/GoalStats';
+export { GoalsFilter } from './goals/GoalsFilter';
+export { MilestoneTree } from './goals/MilestoneTree';
+export { MilestoneNode } from './goals/MilestoneNode';
+export { GoalAnalytics } from './analytics/GoalAnalytics';
+
+// UI Primitives
+export { Card } from './ui/Card';
+export { Button } from './ui/Button';
+export { Badge } from './ui/Badge';
+export { ProgressBar } from './ui/ProgressBar';
+export { Modal } from './ui/Modal';
+export { Tabs } from './ui/Tabs';
+
+// Charts
+export { ProgressTimelineChart } from './analytics/charts/ProgressTimeline';
+export { GoalStateDistributionChart } from './analytics/charts/StateDistribution';
+export { ConsistencyHeatmap } from './analytics/charts/ConsistencyHeatmap';
+export { MotivationTrendChart } from './analytics/charts/MotivationTrend';
+export { PriorityDistributionChart } from './analytics/charts/PriorityDistribution';
+export { TrendSummaryCard } from './analytics/charts/TrendSummary';
diff --git a/repository_after/goal-traking/app/components/layout/AppLayout.tsx b/repository_after/goal-traking/app/components/layout/AppLayout.tsx
new file mode 100644
index 00000000..8b85b07d
--- /dev/null
+++ b/repository_after/goal-traking/app/components/layout/AppLayout.tsx
@@ -0,0 +1,31 @@
+'use client';
+
+import React from 'react';
+import { Navbar } from './Navbar';
+
+interface AppLayoutProps {
+  children: React.ReactNode;
+  activeView: 'goals' | 'analytics' | 'settings';
+  onViewChange: (view: 'goals' | 'analytics' | 'settings') => void;
+  onCreateClick: () => void;
+  onExportClick: () => void;
+}
+
+export function AppLayout({ children, activeView, onViewChange, onCreateClick, onExportClick }: AppLayoutProps) {
+  return (
+    <div className="min-h-screen bg-background text-foreground bg-[radial-gradient(ellipse_at_top,_var(--tw-gradient-stops))] from-slate-900 via-[#0a0f1e] to-black selection:bg-primary/30">
+      <div className="fixed inset-0 bg-[url('/grid.svg')] bg-center [mask-image:linear-gradient(180deg,white,rgba(255,255,255,0))]" />
+      
+      <Navbar 
+        activeView={activeView} 
+        onViewChange={onViewChange}
+        onCreateClick={onCreateClick}
+        onExportClick={onExportClick}
+      />
+      
+      <main className="pt-24 pb-12 container mx-auto px-4 relative z-10">
+        {children}
+      </main>
+    </div>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/layout/Navbar.tsx b/repository_after/goal-traking/app/components/layout/Navbar.tsx
new file mode 100644
index 00000000..8ae295f9
--- /dev/null
+++ b/repository_after/goal-traking/app/components/layout/Navbar.tsx
@@ -0,0 +1,86 @@
+'use client';
+
+import React from 'react';
+import { LayoutDashboard, Target, Settings, Bell, Search, PlusCircle, Download } from 'lucide-react';
+import { Button } from '@/components/ui/Button';
+
+interface NavbarProps {
+  activeView: 'goals' | 'analytics' | 'settings';
+  onViewChange: (view: 'goals' | 'analytics' | 'settings') => void;
+  onCreateClick: () => void;
+  onExportClick: () => void;
+}
+
+export function Navbar({ activeView, onViewChange, onCreateClick, onExportClick }: NavbarProps) {
+  return (
+    <nav className="h-16 border-b border-white/10 bg-slate-900/50 backdrop-blur-xl fixed top-0 left-0 right-0 z-40">
+      <div className="container mx-auto h-full px-4 flex items-center justify-between">
+        {/* Logo & Nav */}
+        <div className="flex items-center gap-8">
+          <div className="flex items-center gap-2 font-bold text-xl tracking-tight">
+             <div className="bg-primary/20 text-primary p-1.5 rounded-lg">
+               <Target className="h-5 w-5" />
+             </div>
+             <span className="bg-gradient-to-r from-white to-white/60 bg-clip-text text-transparent">
+               GoalTrack
+             </span>
+          </div>
+          
+          <div className="hidden md:flex items-center gap-1 bg-secondary/30 p-1 rounded-lg border border-white/5">
+            <button
+              onClick={() => onViewChange('goals')}
+              className={`px-4 py-1.5 rounded-md text-sm font-medium transition-all ${
+                activeView === 'goals' 
+                  ? 'bg-secondary text-foreground shadow-sm' 
+                  : 'text-muted-foreground hover:text-foreground hover:bg-white/5'
+              }`}
+            >
+              Goals
+            </button>
+            <button
+              onClick={() => onViewChange('analytics')}
+              className={`px-4 py-1.5 rounded-md text-sm font-medium transition-all ${
+                activeView === 'analytics' 
+                  ? 'bg-secondary text-foreground shadow-sm' 
+                  : 'text-muted-foreground hover:text-foreground hover:bg-white/5'
+              }`}
+            >
+              Analytics
+            </button>
+          </div>
+        </div>
+
+        {/* Right Actions */}
+        <div className="flex items-center gap-4">
+          <div className="hidden md:flex relative group">
+             <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground group-focus-within:text-foreground transition-colors" />
+             <input 
+               placeholder="Quick search..." 
+               className="h-9 w-64 bg-secondary/30 border border-transparent rounded-full pl-9 pr-4 text-sm outline-none focus:bg-secondary/50 focus:border-white/10 transition-all placeholder:text-muted-foreground/50"
+             />
+             <div className="absolute right-3 top-1/2 -translate-y-1/2 flex gap-1">
+                <span className="text-[10px] bg-white/5 px-1.5 rounded py-0.5 text-muted-foreground border border-white/5">âŒ˜K</span>
+             </div>
+          </div>
+          
+          <button 
+            onClick={onExportClick}
+            className="p-2 text-muted-foreground hover:text-foreground transition-colors hover:bg-white/5 rounded-full" 
+            title="Export Data"
+          >
+             <Download className="h-5 w-5" />
+          </button>
+          
+          <div className="h-6 w-px bg-white/10 mx-1" />
+          
+          <Button onClick={onCreateClick} className="gap-2 shadow-[0_0_15px_rgba(var(--primary),0.3)]">
+             <PlusCircle className="h-4 w-4" />
+             <span className="hidden sm:inline">New Goal</span>
+          </Button>
+          
+          <button className="h-8 w-8 rounded-full bg-gradient-to-tr from-primary to-purple-500 border border-white/20 shadow-inner" />
+        </div>
+      </div>
+    </nav>
+  );
+}
diff --git a/repository_after/goal-traking/app/components/ui/Badge.tsx b/repository_after/goal-traking/app/components/ui/Badge.tsx
new file mode 100644
index 00000000..e9af814a
--- /dev/null
+++ b/repository_after/goal-traking/app/components/ui/Badge.tsx
@@ -0,0 +1,31 @@
+import React from 'react';
+import { cn } from '@/lib/utils';
+
+interface BadgeProps extends React.HTMLAttributes<HTMLDivElement> {
+  variant?: 'default' | 'secondary' | 'destructive' | 'outline' | 'success' | 'warning' | 'info';
+}
+
+export const Badge = React.forwardRef<HTMLDivElement, BadgeProps>(
+  ({ className, variant = 'default', ...props }, ref) => {
+    return (
+      <div
+        ref={ref}
+        className={cn(
+          "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent",
+          {
+            "bg-primary text-primary-foreground hover:bg-primary/80": variant === 'default',
+            "bg-secondary text-secondary-foreground hover:bg-secondary/80": variant === 'secondary',
+            "bg-destructive text-destructive-foreground hover:bg-destructive/80": variant === 'destructive',
+            "text-foreground border-border hover:bg-accent hover:text-accent-foreground": variant === 'outline',
+            "bg-green-500/15 text-green-400 border-green-500/30 hover:bg-green-500/25": variant === 'success',
+            "bg-amber-500/15 text-amber-400 border-amber-500/30 hover:bg-amber-500/25": variant === 'warning',
+            "bg-blue-500/15 text-blue-400 border-blue-500/30 hover:bg-blue-500/25": variant === 'info',
+          },
+          className
+        )}
+        {...props}
+      />
+    );
+  }
+);
+Badge.displayName = "Badge";
diff --git a/repository_after/goal-traking/app/components/ui/Button.tsx b/repository_after/goal-traking/app/components/ui/Button.tsx
new file mode 100644
index 00000000..96926988
--- /dev/null
+++ b/repository_after/goal-traking/app/components/ui/Button.tsx
@@ -0,0 +1,46 @@
+import React from 'react';
+import { cn } from '@/lib/utils';
+
+interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
+  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
+  size?: 'default' | 'sm' | 'lg' | 'icon';
+  loading?: boolean;
+}
+
+export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
+  ({ className, variant = 'default', size = 'default', loading = false, children, disabled, ...props }, ref) => {
+    return (
+      <button
+        ref={ref}
+        disabled={disabled || loading}
+        className={cn(
+          "inline-flex items-center justify-center rounded-lg text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring disabled:opacity-50 disabled:pointer-events-none active:scale-95",
+          {
+            "bg-primary text-primary-foreground hover:bg-primary/90 shadow-[0_0_20px_rgba(124,58,237,0.3)] hover:shadow-[0_0_25px_rgba(124,58,237,0.5)]": variant === 'default',
+            "bg-destructive text-destructive-foreground hover:bg-destructive/90": variant === 'destructive',
+            "border border-input bg-background hover:bg-accent hover:text-accent-foreground glass": variant === 'outline',
+            "bg-secondary text-secondary-foreground hover:bg-secondary/80": variant === 'secondary',
+            "hover:bg-accent hover:text-accent-foreground": variant === 'ghost',
+            "text-primary underline-offset-4 hover:underline": variant === 'link',
+            
+            "h-10 px-4 py-2": size === 'default',
+            "h-9 rounded-md px-3": size === 'sm',
+            "h-11 rounded-md px-8": size === 'lg',
+            "h-10 w-10": size === 'icon',
+          },
+          className
+        )}
+        {...props}
+      >
+        {loading && (
+          <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
+            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
+            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
+          </svg>
+        )}
+        {children}
+      </button>
+    );
+  }
+);
+Button.displayName = "Button";
diff --git a/repository_after/goal-traking/app/components/ui/Card.tsx b/repository_after/goal-traking/app/components/ui/Card.tsx
new file mode 100644
index 00000000..f4d304b4
--- /dev/null
+++ b/repository_after/goal-traking/app/components/ui/Card.tsx
@@ -0,0 +1,82 @@
+import React from 'react';
+import { cn } from '@/lib/utils';
+
+interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
+  variant?: 'glass' | 'solid' | 'panel';
+  hoverEffect?: boolean;
+}
+
+export const Card = React.forwardRef<HTMLDivElement, CardProps>(
+  ({ className, variant = 'glass', hoverEffect = false, children, ...props }, ref) => {
+    return (
+      <div
+        ref={ref}
+        className={cn(
+          "rounded-xl overflow-hidden p-6",
+          {
+            "glass-card": variant === 'glass' && hoverEffect,
+            "glass": variant === 'glass' && !hoverEffect,
+            "bg-card border border-border text-card-foreground shadow-sm": variant === 'solid',
+            "glass-panel": variant === 'panel',
+          },
+          className
+        )}
+        {...props}
+      >
+        {children}
+      </div>
+    );
+  }
+);
+Card.displayName = "Card";
+
+export const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
+  ({ className, ...props }, ref) => (
+    <div
+      ref={ref}
+      className={cn("flex flex-col space-y-1.5 p-6 pt-0", className)}
+      {...props}
+    />
+  )
+);
+CardHeader.displayName = "CardHeader";
+
+export const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
+  ({ className, ...props }, ref) => (
+    <h3
+      ref={ref}
+      className={cn("text-2xl font-semibold leading-none tracking-tight", className)}
+      {...props}
+    />
+  )
+);
+CardTitle.displayName = "CardTitle";
+
+export const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
+  ({ className, ...props }, ref) => (
+    <p
+      ref={ref}
+      className={cn("text-sm text-muted-foreground", className)}
+      {...props}
+    />
+  )
+);
+CardDescription.displayName = "CardDescription";
+
+export const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
+  ({ className, ...props }, ref) => (
+    <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
+  )
+);
+CardContent.displayName = "CardContent";
+
+export const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
+  ({ className, ...props }, ref) => (
+    <div
+      ref={ref}
+      className={cn("flex items-center p-6 pt-0", className)}
+      {...props}
+    />
+  )
+);
+CardFooter.displayName = "CardFooter";
diff --git a/repository_after/goal-traking/app/components/ui/Modal.tsx b/repository_after/goal-traking/app/components/ui/Modal.tsx
new file mode 100644
index 00000000..7e71372b
--- /dev/null
+++ b/repository_after/goal-traking/app/components/ui/Modal.tsx
@@ -0,0 +1,95 @@
+import React from 'react';
+import { createPortal } from 'react-dom';
+import { X } from 'lucide-react';
+import { cn } from '@/lib/utils';
+import { Button } from './Button';
+
+interface ModalProps {
+  isOpen: boolean;
+  onClose: () => void;
+  title?: string;
+  description?: string;
+  children: React.ReactNode;
+  footer?: React.ReactNode;
+  size?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
+  className?: string; // Add className prop
+}
+
+export function Modal({ 
+  isOpen, 
+  onClose, 
+  title, 
+  description, 
+  children, 
+  footer,
+  size = 'md',
+  className // Destructure className
+}: ModalProps) {
+  const [mounted, setMounted] = React.useState(false);
+
+  React.useEffect(() => {
+    setMounted(true);
+    return () => setMounted(false);
+  }, []);
+
+  React.useEffect(() => {
+    if (isOpen) {
+      document.body.style.overflow = 'hidden';
+    } else {
+      document.body.style.overflow = 'unset';
+    }
+    return () => {
+      document.body.style.overflow = 'unset';
+    };
+  }, [isOpen]);
+
+  if (!mounted) return null;
+
+  if (!isOpen) return null;
+
+  return createPortal(
+    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 sm:p-6">
+      {/* Backdrop */}
+      <div 
+        className="fixed inset-0 bg-black/60 backdrop-blur-sm transition-opacity animate-in fade-in" 
+        onClick={onClose}
+      />
+
+      {/* Content */}
+      <div 
+        className={cn(
+          "relative w-full bg-slate-900/90 border border-slate-700 shadow-2xl rounded-xl flex flex-col max-h-[90vh] animate-in slide-up overflow-hidden",
+          {
+            "max-w-sm": size === 'sm',
+            "max-w-md": size === 'md',
+            "max-w-2xl": size === 'lg',
+            "max-w-4xl": size === 'xl',
+            "max-w-full h-full rounded-none": size === 'full',
+          },
+          className // Apply className override
+        )}
+      >
+        <div className="flex items-center justify-between p-6 border-b border-white/10">
+          <div>
+            {title && <h2 className="text-xl font-semibold tracking-tight">{title}</h2>}
+            {description && <p className="text-sm text-muted-foreground mt-1">{description}</p>}
+          </div>
+          <Button variant="ghost" size="icon" onClick={onClose} className="rounded-full hover:bg-white/10">
+            <X className="h-5 w-5" />
+          </Button>
+        </div>
+
+        <div className="flex-1 overflow-y-auto p-6 scrollbar-thin">
+          {children}
+        </div>
+
+        {footer && (
+          <div className="p-6 border-t border-white/10 bg-slate-900/50">
+            {footer}
+          </div>
+        )}
+      </div>
+    </div>,
+    document.body
+  );
+}
diff --git a/repository_after/goal-traking/app/components/ui/ProgressBar.tsx b/repository_after/goal-traking/app/components/ui/ProgressBar.tsx
new file mode 100644
index 00000000..083a5b0e
--- /dev/null
+++ b/repository_after/goal-traking/app/components/ui/ProgressBar.tsx
@@ -0,0 +1,55 @@
+import React from 'react';
+import { cn } from '@/lib/utils';
+
+interface ProgressBarProps extends React.HTMLAttributes<HTMLDivElement> {
+  value: number;
+  max?: number;
+  variant?: 'default' | 'success' | 'warning' | 'danger' | 'gradient';
+  showLabel?: boolean;
+  size?: 'sm' | 'md' | 'lg';
+  animated?: boolean;
+}
+
+export const ProgressBar = React.forwardRef<HTMLDivElement, ProgressBarProps>(
+  ({ className, value, max = 100, variant = 'default', showLabel = false, size = 'md', animated = true, ...props }, ref) => {
+    const percentage = Math.min(100, Math.max(0, (value / max) * 100));
+    
+    return (
+      <div className={cn("w-full", className)} ref={ref} {...props}>
+        {showLabel && (
+          <div className="flex justify-between mb-1 text-sm font-medium">
+            <span className="text-muted-foreground">Progress</span>
+            <span className={cn(
+               "font-bold",
+               percentage === 100 ? "text-green-400" : "text-foreground"
+            )}>{Math.round(percentage)}%</span>
+          </div>
+        )}
+        <div className={cn(
+          "w-full bg-secondary overflow-hidden rounded-full",
+          {
+            "h-1.5": size === 'sm',
+            "h-2.5": size === 'md',
+            "h-4": size === 'lg',
+          }
+        )}>
+          <div
+            className={cn(
+              "h-full rounded-full transition-all duration-500 ease-out",
+              {
+                "bg-primary": variant === 'default',
+                "bg-green-500": variant === 'success',
+                "bg-amber-500": variant === 'warning',
+                "bg-destructive": variant === 'danger',
+                "bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500": variant === 'gradient',
+                "animate-pulse": animated && value < 100 && value > 0,
+              }
+            )}
+            style={{ width: `${percentage}%` }}
+          />
+        </div>
+      </div>
+    );
+  }
+);
+ProgressBar.displayName = "ProgressBar";
diff --git a/repository_after/goal-traking/app/components/ui/Tabs.tsx b/repository_after/goal-traking/app/components/ui/Tabs.tsx
new file mode 100644
index 00000000..5f005004
--- /dev/null
+++ b/repository_after/goal-traking/app/components/ui/Tabs.tsx
@@ -0,0 +1,40 @@
+import React from 'react';
+import { cn } from '@/lib/utils';
+
+interface TabsProps {
+  tabs: { id: string; label: string; icon?: React.ReactNode }[];
+  activeTab: string;
+  onChange: (id: string) => void;
+  className?: string;
+}
+
+export function Tabs({ tabs, activeTab, onChange, className }: TabsProps) {
+  return (
+    <div className={cn("inline-flex h-12 items-center justify-center rounded-lg bg-secondary/50 p-1 text-muted-foreground backdrop-blur-sm", className)}>
+      {tabs.map((tab) => (
+        <button
+          key={tab.id}
+          onClick={() => onChange(tab.id)}
+          className={cn(
+            "inline-flex items-center justify-center whitespace-nowrap rounded-md px-4 py-2 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
+            activeTab === tab.id
+              ? "bg-background text-foreground shadow-sm"
+              : "hover:bg-background/20 hover:text-foreground"
+          )}
+        >
+          {tab.icon && <span className="mr-2">{tab.icon}</span>}
+          {tab.label}
+        </button>
+      ))}
+    </div>
+  );
+}
+
+export function TabsContent({ value, activeTab, children, className }: { value: string; activeTab: string; children: React.ReactNode; className?: string }) {
+  if (value !== activeTab) return null;
+  return (
+    <div className={cn("mt-4 ring-offset-background animate-in fade-in slide-up duration-300", className)}>
+      {children}
+    </div>
+  );
+}
diff --git a/repository_after/goal-traking/app/favicon.ico b/repository_after/goal-traking/app/favicon.ico
new file mode 100644
index 00000000..718d6fea
Binary files /dev/null and b/repository_after/goal-traking/app/favicon.ico differ
diff --git a/repository_after/goal-traking/app/globals.css b/repository_after/goal-traking/app/globals.css
new file mode 100644
index 00000000..fb8ad0ba
--- /dev/null
+++ b/repository_after/goal-traking/app/globals.css
@@ -0,0 +1,167 @@
+@import "tailwindcss";
+
+@theme {
+  --color-background: var(--background);
+  --color-foreground: var(--foreground);
+  --color-card: var(--card);
+  --color-card-foreground: var(--card-foreground);
+  --color-popover: var(--popover);
+  --color-popover-foreground: var(--popover-foreground);
+  --color-primary: var(--primary);
+  --color-primary-foreground: var(--primary-foreground);
+  --color-secondary: var(--secondary);
+  --color-secondary-foreground: var(--secondary-foreground);
+  --color-muted: var(--muted);
+  --color-muted-foreground: var(--muted-foreground);
+  --color-accent: var(--accent);
+  --color-accent-foreground: var(--accent-foreground);
+  --color-destructive: var(--destructive);
+  --color-destructive-foreground: var(--destructive-foreground);
+  --color-border: var(--border);
+  --color-input: var(--input);
+  --color-ring: var(--ring);
+  
+  --radius-lg: var(--radius);
+  --radius-md: calc(var(--radius) - 2px);
+  --radius-sm: calc(var(--radius) - 4px);
+  
+  --font-sans: var(--font-geist-sans), ui-sans-serif, system-ui, sans-serif;
+  --font-mono: var(--font-geist-mono), ui-monospace, SFMono-Regular, monospace;
+  
+  --animate-fade-in: fade-in 0.3s ease-out;
+  --animate-slide-up: slide-up 0.4s ease-out;
+  --animate-pulse-slow: pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
+  
+  @keyframes fade-in {
+    from { opacity: 0; }
+    to { opacity: 1; }
+  }
+  
+  @keyframes slide-up {
+    from { transform: translateY(10px); opacity: 0; }
+    to { transform: translateY(0); opacity: 1; }
+  }
+}
+
+:root {
+  /* Premium Dark Theme Variables (HSL) */
+  --background: hsl(222 47% 11%); /* Slate 950 */
+  --foreground: hsl(210 40% 98%); /* Slate 50 */
+  
+  --card: hsl(222 47% 11% / 0.6);
+  --card-foreground: hsl(210 40% 98%);
+  
+  --popover: hsl(222 47% 11%);
+  --popover-foreground: hsl(210 40% 98%);
+  
+  --primary: hsl(252 100% 68%); /* Violet 500 equivalent */
+  --primary-foreground: hsl(210 40% 98%);
+  
+  --secondary: hsl(217 33% 17%); /* Slate 800 */
+  --secondary-foreground: hsl(210 40% 98%);
+  
+  --muted: hsl(217 33% 17%);
+  --muted-foreground: hsl(215 20% 65%);
+  
+  --accent: hsl(252 100% 68%);
+  --accent-foreground: hsl(210 40% 98%);
+  
+  --destructive: hsl(0 84% 60%);
+  --destructive-foreground: hsl(210 40% 98%);
+  
+  --border: hsl(217 33% 17%);
+  --input: hsl(217 33% 17%);
+  --ring: hsl(252 100% 68%);
+  
+  --radius: 0.75rem;
+}
+
+body {
+  background-color: var(--background);
+  color: var(--foreground);
+  font-family: var(--font-sans);
+  background-image: 
+    radial-gradient(at 0% 0%, hsla(253,16%,7%,1) 0, transparent 50%), 
+    radial-gradient(at 50% 0%, hsla(225,39%,30%,1) 0, transparent 50%), 
+    radial-gradient(at 100% 0%, hsla(339,49%,30%,1) 0, transparent 50%);
+  background-attachment: fixed;
+  min-height: 100vh;
+}
+
+/* Glassmorphism Utilities */
+.glass {
+  background: rgba(15, 23, 42, 0.6);
+  backdrop-filter: blur(12px);
+  -webkit-backdrop-filter: blur(12px);
+  border: 1px solid rgba(255, 255, 255, 0.08);
+  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
+}
+
+.glass-card {
+  background: rgba(15, 23, 42, 0.6);
+  backdrop-filter: blur(12px);
+  -webkit-backdrop-filter: blur(12px);
+  border: 1px solid rgba(255, 255, 255, 0.08);
+  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
+  @apply rounded-xl transition-all duration-300;
+}
+
+.glass-card:hover {
+  border-color: rgba(255, 255, 255, 0.15);
+  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
+  transform: translateY(-2px);
+}
+
+.glass-panel {
+  background: rgba(30, 41, 59, 0.4);
+  backdrop-filter: blur(8px);
+  border: 1px solid rgba(255, 255, 255, 0.05);
+  border-radius: var(--radius);
+}
+
+/* Custom Scrollbar */
+::-webkit-scrollbar {
+  width: 6px;
+  height: 6px;
+}
+::-webkit-scrollbar-track {
+  background: transparent;
+}
+::-webkit-scrollbar-thumb {
+  background: var(--muted-foreground);
+  border-radius: 9999px;
+  opacity: 0.5;
+}
+::-webkit-scrollbar-thumb:hover {
+  background: var(--muted-foreground);
+}
+
+/* Range Input */
+input[type="range"] {
+  @apply rounded-full h-2 bg-secondary appearance-none cursor-pointer;
+}
+input[type="range"]::-webkit-slider-thumb {
+  @apply appearance-none w-4 h-4 rounded-full bg-primary ring-2 ring-background transition-transform hover:scale-110;
+}
+
+/* Typography Enhancements */
+h1, h2, h3, h4, h5, h6 {
+  @apply font-semibold tracking-tight;
+}
+
+h1 { @apply text-4xl lg:text-5xl bg-gradient-to-br from-white to-gray-400 bg-clip-text text-transparent; }
+h2 { @apply text-3xl; }
+h3 { @apply text-2xl; }
+
+/* Animation Classes */
+.animate-in {
+  animation: fade-in 0.5s ease-out forwards;
+}
+
+.animate-slide-up {
+  animation: slide-up 0.5s ease-out forwards;
+}
+
+.stagger-1 { animation-delay: 100ms; }
+.stagger-2 { animation-delay: 200ms; }
+.stagger-3 { animation-delay: 300ms; }
diff --git a/repository_after/goal-traking/app/layout.tsx b/repository_after/goal-traking/app/layout.tsx
new file mode 100644
index 00000000..55fe9360
--- /dev/null
+++ b/repository_after/goal-traking/app/layout.tsx
@@ -0,0 +1,34 @@
+import type { Metadata } from "next";
+import { Geist, Geist_Mono } from "next/font/google";
+import "./globals.css";
+
+const geistSans = Geist({
+  variable: "--font-geist-sans",
+  subsets: ["latin"],
+});
+
+const geistMono = Geist_Mono({
+  variable: "--font-geist-mono",
+  subsets: ["latin"],
+});
+
+export const metadata: Metadata = {
+  title: "Goal Tracker - Track Your Long-Term Goals",
+  description: "A comprehensive goal tracking application with milestones, analytics, and progress visualization.",
+};
+
+export default function RootLayout({
+  children,
+}: Readonly<{
+  children: React.ReactNode;
+}>) {
+  return (
+    <html lang="en">
+      <body
+        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
+      >
+        {children}
+      </body>
+    </html>
+  );
+}
diff --git a/repository_after/goal-traking/app/lib/analytics.ts b/repository_after/goal-traking/app/lib/analytics.ts
new file mode 100644
index 00000000..4fb1ddc8
--- /dev/null
+++ b/repository_after/goal-traking/app/lib/analytics.ts
@@ -0,0 +1,788 @@
+// Analytics Engine for Goal Tracking Application
+// Computes velocity metrics, estimation accuracy, outcome quality, and trend analysis
+
+import { differenceInDays, differenceInHours, subDays, parseISO } from 'date-fns';
+import {
+  Goal,
+  Milestone,
+  ProgressUpdate,
+  VelocityMetrics,
+  EstimationAccuracy,
+  OutcomeQualityScore,
+  TrendAnalysis,
+  GoalState,
+} from './types';
+import * as db from './db';
+
+// ============================================================================
+// Velocity Metrics
+// ============================================================================
+
+export interface VelocityComputationResult {
+  progressPerDay: number;
+  progressPerWeek: number;
+  accelerationTrend: 'accelerating' | 'decelerating' | 'stable' | 'stagnant';
+  lastActiveDate?: string;
+  stagnationDays: number;
+}
+
+/**
+ * Computes velocity metrics for a goal or milestone based on progress history
+ */
+export function computeVelocity(
+  entityId: string,
+  progressUpdates: ProgressUpdate[],
+  createdAt: string
+): VelocityComputationResult {
+  const updates = progressUpdates
+    .filter(u => u.entityId === entityId)
+    .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
+  
+  const now = new Date();
+  const created = parseISO(createdAt);
+  const totalDays = Math.max(differenceInDays(now, created), 1);
+  
+  if (updates.length === 0) {
+    return {
+      progressPerDay: 0,
+      progressPerWeek: 0,
+      accelerationTrend: 'stagnant',
+      stagnationDays: totalDays,
+    };
+  }
+  
+  const lastUpdate = updates[updates.length - 1];
+  const lastActiveDate = lastUpdate.createdAt;
+  const stagnationDays = differenceInDays(now, parseISO(lastActiveDate));
+  
+  // Calculate overall velocity
+  const currentProgress = lastUpdate.percentage;
+  const progressPerDay = currentProgress / totalDays;
+  const progressPerWeek = progressPerDay * 7;
+  
+  // Calculate acceleration trend by comparing recent vs earlier velocity
+  let accelerationTrend: 'accelerating' | 'decelerating' | 'stable' | 'stagnant' = 'stable';
+  
+  if (stagnationDays > 7) {
+    accelerationTrend = 'stagnant';
+  } else if (updates.length >= 3) {
+    // Compare velocity in first half vs second half of updates
+    const midPoint = Math.floor(updates.length / 2);
+    const firstHalf = updates.slice(0, midPoint);
+    const secondHalf = updates.slice(midPoint);
+    
+    const firstHalfProgress = firstHalf.length > 0 
+      ? firstHalf[firstHalf.length - 1].percentage - (firstHalf[0]?.percentage || 0)
+      : 0;
+    const secondHalfProgress = secondHalf.length > 0
+      ? secondHalf[secondHalf.length - 1].percentage - (secondHalf[0]?.percentage || 0)
+      : 0;
+    
+    const firstHalfDays = firstHalf.length > 1
+      ? Math.max(differenceInDays(parseISO(firstHalf[firstHalf.length - 1].createdAt), parseISO(firstHalf[0].createdAt)), 1)
+      : 1;
+    const secondHalfDays = secondHalf.length > 1
+      ? Math.max(differenceInDays(parseISO(secondHalf[secondHalf.length - 1].createdAt), parseISO(secondHalf[0].createdAt)), 1)
+      : 1;
+    
+    const firstHalfVelocity = firstHalfProgress / firstHalfDays;
+    const secondHalfVelocity = secondHalfProgress / secondHalfDays;
+    
+    const velocityChange = secondHalfVelocity - firstHalfVelocity;
+    
+    if (velocityChange > 1) {
+      accelerationTrend = 'accelerating';
+    } else if (velocityChange < -1) {
+      accelerationTrend = 'decelerating';
+    }
+  }
+  
+  return {
+    progressPerDay: Math.round(progressPerDay * 100) / 100,
+    progressPerWeek: Math.round(progressPerWeek * 100) / 100,
+    accelerationTrend,
+    lastActiveDate,
+    stagnationDays,
+  };
+}
+
+/**
+ * Saves computed velocity metrics to the database
+ */
+export async function saveVelocityMetrics(
+  entityId: string,
+  entityType: 'goal' | 'milestone',
+  velocity: VelocityComputationResult
+): Promise<VelocityMetrics> {
+  const metrics: VelocityMetrics = {
+    entityId,
+    entityType,
+    ...velocity,
+    computedAt: new Date().toISOString(),
+  };
+  
+  await db.saveVelocityMetrics(metrics);
+  return metrics;
+}
+
+// ============================================================================
+// Estimation Accuracy
+// ============================================================================
+
+export interface EstimationAnalysisResult {
+  timelineAccuracy?: number;
+  effortAccuracy?: number;
+  difficultyAccuracy?: number;
+  overallAccuracy?: number;
+  bias: 'overestimate' | 'underestimate' | 'accurate' | 'unknown';
+}
+
+/**
+ * Computes estimation accuracy by comparing expected vs actual outcomes
+ */
+export function computeEstimationAccuracy(
+  entity: Goal | Milestone,
+  progressUpdates: ProgressUpdate[]
+): EstimationAnalysisResult {
+  const result: EstimationAnalysisResult = {
+    bias: 'unknown',
+  };
+  
+  if (!entity.expectedOutcome || !entity.actualOutcome) {
+    return result;
+  }
+  
+  const expected = entity.expectedOutcome;
+  const actual = entity.actualOutcome;
+  
+  // Timeline accuracy
+  if (expected.estimatedTimelineDays !== undefined && actual.timelineDeviation !== undefined) {
+    const actualDays = expected.estimatedTimelineDays + actual.timelineDeviation;
+    if (actualDays > 0) {
+      // 100% = perfect, <100% = took longer, >100% = finished early
+      result.timelineAccuracy = Math.round((expected.estimatedTimelineDays / actualDays) * 100);
+    }
+  }
+  
+  // Effort accuracy (based on time spent in progress updates)
+  if (expected.estimatedEffortHours !== undefined) {
+    const totalTimeSpent = progressUpdates
+      .filter(u => u.entityId === entity.id)
+      .reduce((sum, u) => sum + (u.timeSpentMinutes || 0), 0);
+    const actualHours = totalTimeSpent / 60;
+    
+    if (actualHours > 0) {
+      result.effortAccuracy = Math.round((expected.estimatedEffortHours / actualHours) * 100);
+    }
+  }
+  
+  // Difficulty accuracy (compare estimated vs perceived difficulty in progress updates)
+  if (expected.estimatedDifficulty !== undefined) {
+    const difficultyRatings = progressUpdates
+      .filter(u => u.entityId === entity.id && u.perceivedDifficulty !== undefined)
+      .map(u => u.perceivedDifficulty as number);
+    
+    if (difficultyRatings.length > 0) {
+      const avgPerceivedDifficulty = difficultyRatings.reduce((a, b) => a + b, 0) / difficultyRatings.length;
+      // Scale to percentage where 100% = accurate, <100% = underestimated, >100% = overestimated
+      result.difficultyAccuracy = Math.round((expected.estimatedDifficulty / avgPerceivedDifficulty) * 100);
+    }
+  }
+  
+  // Calculate overall accuracy (average of available accuracies)
+  const accuracies = [result.timelineAccuracy, result.effortAccuracy, result.difficultyAccuracy].filter(a => a !== undefined) as number[];
+  if (accuracies.length > 0) {
+    result.overallAccuracy = Math.round(accuracies.reduce((a, b) => a + b, 0) / accuracies.length);
+    
+    // Determine bias
+    if (result.overallAccuracy >= 90 && result.overallAccuracy <= 110) {
+      result.bias = 'accurate';
+    } else if (result.overallAccuracy < 90) {
+      result.bias = 'underestimate';
+    } else {
+      result.bias = 'overestimate';
+    }
+  }
+  
+  return result;
+}
+
+/**
+ * Saves computed estimation accuracy to the database
+ */
+export async function saveEstimationAccuracyMetrics(
+  entityId: string,
+  entityType: 'goal' | 'milestone',
+  accuracy: EstimationAnalysisResult
+): Promise<EstimationAccuracy> {
+  const metrics: EstimationAccuracy = {
+    entityId,
+    entityType,
+    ...accuracy,
+    computedAt: new Date().toISOString(),
+  };
+  
+  await db.saveEstimationAccuracy(metrics);
+  return metrics;
+}
+
+// ============================================================================
+// Outcome Quality Score
+// ============================================================================
+
+export interface OutcomeQualityResult {
+  timelinessScore: number;
+  scopeAdherenceScore: number;
+  impactScore: number;
+  efficiencyScore: number;
+  satisfactionScore: number;
+  overallScore: number;
+  explanation: string;
+}
+
+/**
+ * Computes outcome quality score for a completed goal or milestone
+ */
+export function computeOutcomeQuality(
+  entity: Goal | Milestone,
+  progressUpdates: ProgressUpdate[]
+): OutcomeQualityResult {
+  let timelinessScore = 50; // Default to neutral
+  let scopeAdherenceScore = 50;
+  let impactScore = 50;
+  let efficiencyScore = 50;
+  let satisfactionScore = 50;
+  const explanations: string[] = [];
+  
+  // Timeliness score (based on target date vs completion date)
+  if (entity.targetDate && entity.completedAt) {
+    const targetDate = parseISO(entity.targetDate);
+    const completedDate = parseISO(entity.completedAt);
+    const daysDiff = differenceInDays(completedDate, targetDate);
+    
+    if (daysDiff <= 0) {
+      // Completed on time or early
+      timelinessScore = Math.min(100, 100 + daysDiff * 2); // Bonus for early completion
+      explanations.push(`Completed ${Math.abs(daysDiff)} days early`);
+    } else {
+      // Late completion
+      timelinessScore = Math.max(0, 100 - daysDiff * 5); // Penalty for late
+      explanations.push(`Completed ${daysDiff} days late`);
+    }
+  } else if (entity.state === 'completed') {
+    timelinessScore = 70; // No target date but completed
+    explanations.push('Completed without target date');
+  }
+  
+  // Scope adherence score (based on actual outcome success score)
+  if (entity.actualOutcome?.successScore !== undefined) {
+    scopeAdherenceScore = entity.actualOutcome.successScore;
+    explanations.push(`Success score: ${scopeAdherenceScore}%`);
+  }
+  
+  // Impact score (based on priority weight)
+  if ('priorityWeight' in entity) {
+    impactScore = (entity as Goal).priorityWeight;
+  } else {
+    // For milestones, use priority level
+    const priorityScores = { critical: 100, high: 75, medium: 50, low: 25 };
+    impactScore = priorityScores[entity.priority];
+  }
+  
+  // Efficiency score (based on estimated vs actual effort)
+  const entityUpdates = progressUpdates.filter(u => u.entityId === entity.id);
+  if (entity.expectedOutcome?.estimatedEffortHours && entityUpdates.length > 0) {
+    const totalTimeSpent = entityUpdates.reduce((sum, u) => sum + (u.timeSpentMinutes || 0), 0);
+    const actualHours = totalTimeSpent / 60;
+    const estimatedHours = entity.expectedOutcome.estimatedEffortHours;
+    
+    if (actualHours > 0) {
+      const efficiency = estimatedHours / actualHours;
+      efficiencyScore = Math.min(100, Math.max(0, Math.round(efficiency * 100)));
+      explanations.push(`Effort efficiency: ${efficiencyScore}%`);
+    }
+  }
+  
+  // Satisfaction score (based on motivation levels in progress updates)
+  const motivationRatings = entityUpdates
+    .filter(u => u.motivationLevel !== undefined)
+    .map(u => u.motivationLevel as number);
+  
+  if (motivationRatings.length > 0) {
+    const avgMotivation = motivationRatings.reduce((a, b) => a + b, 0) / motivationRatings.length;
+    satisfactionScore = Math.round(avgMotivation * 10); // Scale 1-10 to 0-100
+  }
+  
+  // Calculate overall score (weighted average)
+  const weights = {
+    timeliness: 0.25,
+    scope: 0.25,
+    impact: 0.20,
+    efficiency: 0.15,
+    satisfaction: 0.15,
+  };
+  
+  const overallScore = Math.round(
+    timelinessScore * weights.timeliness +
+    scopeAdherenceScore * weights.scope +
+    impactScore * weights.impact +
+    efficiencyScore * weights.efficiency +
+    satisfactionScore * weights.satisfaction
+  );
+  
+  return {
+    timelinessScore,
+    scopeAdherenceScore,
+    impactScore,
+    efficiencyScore,
+    satisfactionScore,
+    overallScore,
+    explanation: explanations.join('; ') || 'Default scoring applied',
+  };
+}
+
+/**
+ * Saves computed outcome quality to the database
+ */
+export async function saveOutcomeQualityMetrics(
+  entityId: string,
+  entityType: 'goal' | 'milestone',
+  quality: OutcomeQualityResult
+): Promise<OutcomeQualityScore> {
+  const metrics: OutcomeQualityScore = {
+    entityId,
+    entityType,
+    ...quality,
+    computedAt: new Date().toISOString(),
+  };
+  
+  await db.saveOutcomeQuality(metrics);
+  return metrics;
+}
+
+// ============================================================================
+// Trend Analysis
+// ============================================================================
+
+export interface TrendAnalysisResult {
+  consistencyScore: number;
+  motivationTrend: 'improving' | 'declining' | 'stable' | 'volatile';
+  completionReliability: number;
+  abandonmentRate: number;
+  burnoutRisk: 'low' | 'medium' | 'high' | 'critical';
+  recoveryPattern?: string;
+  averageVelocity: number;
+  optimismBias?: number;
+}
+
+/**
+ * Analyzes long-term trends across all goals
+ */
+export function computeTrendAnalysis(
+  goals: Goal[],
+  progressUpdates: ProgressUpdate[]
+): TrendAnalysisResult {
+  const result: TrendAnalysisResult = {
+    consistencyScore: 50,
+    motivationTrend: 'stable',
+    completionReliability: 0,
+    abandonmentRate: 0,
+    burnoutRisk: 'low',
+    averageVelocity: 0,
+  };
+  
+  if (goals.length === 0) {
+    return result;
+  }
+  
+  // Completion reliability
+  const completedGoals = goals.filter(g => g.state === 'completed');
+  const failedGoals = goals.filter(g => g.state === 'failed');
+  const abandonedGoals = goals.filter(g => g.state === 'abandoned');
+  const terminalGoals = completedGoals.length + failedGoals.length + abandonedGoals.length;
+  
+  if (terminalGoals > 0) {
+    result.completionReliability = Math.round((completedGoals.length / terminalGoals) * 100);
+    result.abandonmentRate = Math.round((abandonedGoals.length / terminalGoals) * 100);
+  }
+  
+  // Consistency score (based on update frequency)
+  const thirtyDaysAgo = subDays(new Date(), 30);
+  const recentUpdates = progressUpdates.filter(u => 
+    parseISO(u.createdAt) >= thirtyDaysAgo
+  );
+  
+  // Calculate days with updates in last 30 days
+  const uniqueDays = new Set(
+    recentUpdates.map(u => parseISO(u.createdAt).toDateString())
+  ).size;
+  result.consistencyScore = Math.round((uniqueDays / 30) * 100);
+  
+  // Motivation trend
+  const motivationRatings = progressUpdates
+    .filter(u => u.motivationLevel !== undefined)
+    .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())
+    .map(u => u.motivationLevel as number);
+  
+  if (motivationRatings.length >= 5) {
+    const firstHalf = motivationRatings.slice(0, Math.floor(motivationRatings.length / 2));
+    const secondHalf = motivationRatings.slice(Math.floor(motivationRatings.length / 2));
+    
+    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
+    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
+    
+    const diff = secondAvg - firstAvg;
+    
+    // Check for volatility
+    const variance = motivationRatings.reduce((sum, r) => {
+      const mean = motivationRatings.reduce((a, b) => a + b, 0) / motivationRatings.length;
+      return sum + Math.pow(r - mean, 2);
+    }, 0) / motivationRatings.length;
+    
+    if (variance > 4) {
+      result.motivationTrend = 'volatile';
+    } else if (diff > 1) {
+      result.motivationTrend = 'improving';
+    } else if (diff < -1) {
+      result.motivationTrend = 'declining';
+    }
+  }
+  
+  // Burnout risk assessment
+  const recentEmotionalStates = progressUpdates
+    .filter(u => parseISO(u.createdAt) >= thirtyDaysAgo && u.emotionalState)
+    .map(u => u.emotionalState);
+  
+  const burnedOutCount = recentEmotionalStates.filter(s => s === 'burned_out' || s === 'stressed').length;
+  const recentCount = recentEmotionalStates.length;
+  
+  if (recentCount > 0) {
+    const burnoutRatio = burnedOutCount / recentCount;
+    if (burnoutRatio >= 0.5) {
+      result.burnoutRisk = 'critical';
+      result.recoveryPattern = 'Recommend taking a break and reducing workload';
+    } else if (burnoutRatio >= 0.3) {
+      result.burnoutRisk = 'high';
+      result.recoveryPattern = 'Consider reducing active goals and focusing on high-priority items';
+    } else if (burnoutRatio >= 0.15) {
+      result.burnoutRisk = 'medium';
+    }
+  }
+  
+  // Low consistency can also indicate burnout
+  if (result.consistencyScore < 20 && goals.filter(g => g.state === 'active').length > 0) {
+    if (result.burnoutRisk === 'low') {
+      result.burnoutRisk = 'medium';
+    }
+  }
+  
+  // Average velocity across active goals
+  const activeGoals = goals.filter(g => g.state === 'active');
+  if (activeGoals.length > 0) {
+    const velocities = activeGoals.map(g => {
+      const velocity = computeVelocity(g.id, progressUpdates, g.createdAt);
+      return velocity.progressPerDay;
+    });
+    result.averageVelocity = Math.round(
+      (velocities.reduce((a, b) => a + b, 0) / velocities.length) * 100
+    ) / 100;
+  }
+  
+  // Optimism bias (compare confidence levels with actual outcomes)
+  const completedWithOutcomes = completedGoals.filter(g => g.actualOutcome?.successScore !== undefined);
+  if (completedWithOutcomes.length >= 3) {
+    let totalConfidence = 0;
+    let totalSuccess = 0;
+    let count = 0;
+    
+    for (const goal of completedWithOutcomes) {
+      const goalUpdates = progressUpdates.filter(u => u.entityId === goal.id && u.confidenceLevel !== undefined);
+      if (goalUpdates.length > 0) {
+        const avgConfidence = goalUpdates.reduce((a, u) => a + (u.confidenceLevel || 0), 0) / goalUpdates.length;
+        totalConfidence += avgConfidence * 10; // Scale to 0-100
+        totalSuccess += goal.actualOutcome!.successScore!;
+        count++;
+      }
+    }
+    
+    if (count >= 3) {
+      result.optimismBias = Math.round((totalConfidence / count) - (totalSuccess / count));
+      // Positive = overconfident, Negative = underconfident
+    }
+  }
+  
+  return result;
+}
+
+/**
+ * Saves computed trend analysis to the database
+ */
+export async function saveTrendAnalysisMetrics(
+  trend: TrendAnalysisResult
+): Promise<TrendAnalysis> {
+  const metrics: TrendAnalysis = {
+    userId: 'default',
+    ...trend,
+    computedAt: new Date().toISOString(),
+  };
+  
+  await db.saveTrendAnalysis(metrics);
+  return metrics;
+}
+
+// ============================================================================
+// Completion Probability Prediction
+// ============================================================================
+
+export interface CompletionPrediction {
+  probability: number;
+  confidence: 'high' | 'medium' | 'low' | 'insufficient_data';
+  estimatedCompletionDate?: string;
+  riskFactors: string[];
+  positiveFactors: string[];
+}
+
+/**
+ * Predicts the probability of goal completion based on current progress and historical patterns
+ */
+export function predictCompletionProbability(
+  goal: Goal,
+  milestones: Milestone[],
+  progressUpdates: ProgressUpdate[],
+  dependencies: { sourceId: string; targetId: string; blocked: boolean }[],
+  historicalCompletionRate: number
+): CompletionPrediction {
+  const prediction: CompletionPrediction = {
+    probability: 50,
+    confidence: 'insufficient_data',
+    riskFactors: [],
+    positiveFactors: [],
+  };
+  
+  const goalMilestones = milestones.filter(m => m.goalId === goal.id);
+  const goalUpdates = progressUpdates.filter(u => u.entityId === goal.id);
+  
+  // Base probability on current progress
+  let probability = goal.progress * 0.5; // Progress contributes up to 50%
+  
+  // Factor in velocity
+  const velocity = computeVelocity(goal.id, progressUpdates, goal.createdAt);
+  
+  if (velocity.accelerationTrend === 'accelerating') {
+    probability += 15;
+    prediction.positiveFactors.push('Velocity is accelerating');
+  } else if (velocity.accelerationTrend === 'stagnant') {
+    probability -= 20;
+    prediction.riskFactors.push('No recent progress updates');
+  } else if (velocity.accelerationTrend === 'decelerating') {
+    probability -= 10;
+    prediction.riskFactors.push('Velocity is slowing down');
+  }
+  
+  // Factor in dependencies
+  const blockedDeps = dependencies.filter(d => d.sourceId === goal.id && d.blocked);
+  if (blockedDeps.length > 0) {
+    probability -= blockedDeps.length * 10;
+    prediction.riskFactors.push(`${blockedDeps.length} blocking dependencies`);
+  }
+  
+  // Factor in milestone completion
+  if (goalMilestones.length > 0) {
+    const completedMilestones = goalMilestones.filter(m => m.state === 'completed').length;
+    const milestoneCompletion = completedMilestones / goalMilestones.length;
+    probability += milestoneCompletion * 20;
+    
+    if (milestoneCompletion > 0.7) {
+      prediction.positiveFactors.push('Most milestones completed');
+    }
+  }
+  
+  // Factor in historical completion rate
+  probability = probability * 0.7 + historicalCompletionRate * 0.3;
+  
+  // Factor in deadline proximity
+  if (goal.targetDate) {
+    const daysRemaining = differenceInDays(parseISO(goal.targetDate), new Date());
+    const progressRemaining = 100 - goal.progress;
+    
+    if (daysRemaining > 0) {
+      const requiredVelocity = progressRemaining / daysRemaining;
+      
+      if (velocity.progressPerDay >= requiredVelocity * 1.2) {
+        probability += 10;
+        prediction.positiveFactors.push('On track to meet deadline');
+      } else if (velocity.progressPerDay < requiredVelocity * 0.5) {
+        probability -= 15;
+        prediction.riskFactors.push('Unlikely to meet deadline at current velocity');
+      }
+      
+
+    } else if (daysRemaining < 0) {
+      probability -= 20;
+      prediction.riskFactors.push('Past target date');
+    }
+  }
+  
+  // Estimate completion date based on velocity (independent of target date)
+  if (goal.progress < 100 && velocity.progressPerDay > 0) {
+    const progressRemaining = 100 - goal.progress;
+    const daysToComplete = progressRemaining / velocity.progressPerDay;
+    const estimatedDate = new Date();
+    estimatedDate.setDate(estimatedDate.getDate() + Math.ceil(daysToComplete));
+    prediction.estimatedCompletionDate = estimatedDate.toISOString();
+  }
+  
+  // Confidence level based on data availability
+  const dataPoints = goalUpdates.length + goalMilestones.length;
+  if (dataPoints >= 10) {
+    prediction.confidence = 'high';
+  } else if (dataPoints >= 5) {
+    prediction.confidence = 'medium';
+  } else if (dataPoints >= 2) {
+    prediction.confidence = 'low';
+  }
+  
+  // Clamp probability between 0 and 100
+  prediction.probability = Math.max(0, Math.min(100, Math.round(probability)));
+  
+  return prediction;
+}
+
+// ============================================================================
+// Simulation Engine
+// ============================================================================
+
+export interface SimulationResult {
+  originalProbability: number;
+  simulatedProbability: number;
+  workloadChange: number; // Percentage change
+  timelineChange: number; // Days
+  recommendations: string[];
+}
+
+/**
+ * Simulates the impact of changes without modifying actual data
+ */
+export function simulateChanges(
+  goal: Goal,
+  milestones: Milestone[],
+  progressUpdates: ProgressUpdate[],
+  dependencies: { sourceId: string; targetId: string; blocked: boolean }[],
+  changes: {
+    newProgress?: number;
+    newTargetDate?: string;
+    priorityChange?: number;
+    removeDependencies?: string[];
+  }
+): SimulationResult {
+  // Get original prediction
+  const originalPrediction = predictCompletionProbability(
+    goal,
+    milestones,
+    progressUpdates,
+    dependencies,
+    50 // Assume 50% historical rate for simulation
+  );
+  
+  // Create simulated goal
+  const simulatedGoal = { ...goal };
+  if (changes.newProgress !== undefined) {
+    simulatedGoal.progress = changes.newProgress;
+  }
+  if (changes.newTargetDate !== undefined) {
+    simulatedGoal.targetDate = changes.newTargetDate;
+  }
+  if (changes.priorityChange !== undefined) {
+    simulatedGoal.priorityWeight = Math.max(1, Math.min(100, goal.priorityWeight + changes.priorityChange));
+  }
+  
+  // Filter out removed dependencies
+  let simulatedDeps = dependencies;
+  if (changes.removeDependencies) {
+    simulatedDeps = dependencies.filter(d => !changes.removeDependencies!.includes(d.targetId));
+  }
+  
+  // Get simulated prediction
+  const simulatedPrediction = predictCompletionProbability(
+    simulatedGoal,
+    milestones,
+    progressUpdates,
+    simulatedDeps,
+    50
+  );
+  
+  // Calculate changes
+  const workloadChange = changes.priorityChange 
+    ? (changes.priorityChange / goal.priorityWeight) * 100 
+    : 0;
+  
+  let timelineChange = 0;
+  if (changes.newTargetDate && goal.targetDate) {
+    timelineChange = differenceInDays(parseISO(changes.newTargetDate), parseISO(goal.targetDate));
+  }
+  
+  // Generate recommendations
+  const recommendations: string[] = [];
+  
+  if (simulatedPrediction.probability > originalPrediction.probability + 10) {
+    recommendations.push('These changes would significantly improve completion probability');
+  } else if (simulatedPrediction.probability < originalPrediction.probability - 10) {
+    recommendations.push('These changes would decrease completion probability');
+  }
+  
+  if (changes.removeDependencies && changes.removeDependencies.length > 0) {
+    recommendations.push(`Removing ${changes.removeDependencies.length} dependencies would reduce blockers`);
+  }
+  
+  if (timelineChange > 14) {
+    recommendations.push('Extending deadline by more than 2 weeks may indicate scope issues');
+  } else if (timelineChange < -7) {
+    recommendations.push('Shortening deadline significantly may require additional resources');
+  }
+  
+  return {
+    originalProbability: originalPrediction.probability,
+    simulatedProbability: simulatedPrediction.probability,
+    workloadChange,
+    timelineChange,
+    recommendations,
+  };
+}
+
+// ============================================================================
+// Batch Analytics Computation
+// ============================================================================
+
+/**
+ * Computes and saves all analytics for a goal
+ */
+export async function computeAllAnalytics(
+  goal: Goal,
+  milestones: Milestone[],
+  progressUpdates: ProgressUpdate[]
+): Promise<{
+  velocity: VelocityMetrics;
+  estimationAccuracy?: EstimationAccuracy;
+  outcomeQuality?: OutcomeQualityScore;
+}> {
+  // Velocity
+  const velocityResult = computeVelocity(goal.id, progressUpdates, goal.createdAt);
+  const velocity = await saveVelocityMetrics(goal.id, 'goal', velocityResult);
+  
+  let estimationAccuracy: EstimationAccuracy | undefined;
+  let outcomeQuality: OutcomeQualityScore | undefined;
+  
+  // Estimation accuracy (only if outcome data exists)
+  if (goal.expectedOutcome && goal.actualOutcome) {
+    const accuracyResult = computeEstimationAccuracy(goal, progressUpdates);
+    estimationAccuracy = await saveEstimationAccuracyMetrics(goal.id, 'goal', accuracyResult);
+  }
+  
+  // Outcome quality (only if completed)
+  if (goal.state === 'completed') {
+    const qualityResult = computeOutcomeQuality(goal, progressUpdates);
+    outcomeQuality = await saveOutcomeQualityMetrics(goal.id, 'goal', qualityResult);
+  }
+  
+  return { velocity, estimationAccuracy, outcomeQuality };
+}
diff --git a/repository_after/goal-traking/app/lib/db.ts b/repository_after/goal-traking/app/lib/db.ts
new file mode 100644
index 00000000..e4ea52f4
--- /dev/null
+++ b/repository_after/goal-traking/app/lib/db.ts
@@ -0,0 +1,593 @@
+// IndexedDB Persistence Layer for Goal Tracking Application
+// Uses the 'idb' library for a promise-based API
+
+import { openDB, DBSchema, IDBPDatabase } from 'idb';
+import {
+  Goal,
+  Milestone,
+  ProgressUpdate,
+  Dependency,
+  DecisionRecord,
+  VersionSnapshot,
+  VelocityMetrics,
+  EstimationAccuracy,
+  OutcomeQualityScore,
+  TrendAnalysis,
+} from './types';
+
+// ============================================================================
+// Database Schema Definition
+// ============================================================================
+
+interface GoalTrackingDB extends DBSchema {
+  goals: {
+    key: string;
+    value: Goal;
+    indexes: {
+      'by-state': string;
+      'by-priority': string;
+      'by-createdAt': string;
+      'by-targetDate': string;
+    };
+  };
+  milestones: {
+    key: string;
+    value: Milestone;
+    indexes: {
+      'by-goalId': string;
+      'by-parentMilestoneId': string;
+      'by-state': string;
+    };
+  };
+  progressUpdates: {
+    key: string;
+    value: ProgressUpdate;
+    indexes: {
+      'by-entityId': string;
+      'by-createdAt': string;
+    };
+  };
+  dependencies: {
+    key: string;
+    value: Dependency;
+    indexes: {
+      'by-sourceId': string;
+      'by-targetId': string;
+    };
+  };
+  decisionRecords: {
+    key: string;
+    value: DecisionRecord;
+    indexes: {
+      'by-goalId': string;
+    };
+  };
+  versionHistory: {
+    key: string;
+    value: VersionSnapshot;
+    indexes: {
+      'by-entityId': string;
+      'by-createdAt': string;
+    };
+  };
+  velocityMetrics: {
+    key: string;
+    value: VelocityMetrics;
+    indexes: {
+      'by-entityId': string;
+    };
+  };
+  estimationAccuracy: {
+    key: string;
+    value: EstimationAccuracy;
+    indexes: {
+      'by-entityId': string;
+    };
+  };
+  outcomeQuality: {
+    key: string;
+    value: OutcomeQualityScore;
+    indexes: {
+      'by-entityId': string;
+    };
+  };
+  trendAnalysis: {
+    key: string;
+    value: TrendAnalysis;
+  };
+}
+
+const DB_NAME = 'goal-tracking-db';
+const DB_VERSION = 1;
+
+// ============================================================================
+// Database Initialization
+// ============================================================================
+
+let dbInstance: IDBPDatabase<GoalTrackingDB> | null = null;
+
+export async function initDB(): Promise<IDBPDatabase<GoalTrackingDB>> {
+  if (dbInstance) {
+    return dbInstance;
+  }
+
+  try {
+    dbInstance = await openDB<GoalTrackingDB>(DB_NAME, DB_VERSION, {
+      upgrade(db, oldVersion, newVersion, transaction) {
+        // Goals store
+        if (!db.objectStoreNames.contains('goals')) {
+          const goalsStore = db.createObjectStore('goals', { keyPath: 'id' });
+          goalsStore.createIndex('by-state', 'state');
+          goalsStore.createIndex('by-priority', 'priority');
+          goalsStore.createIndex('by-createdAt', 'createdAt');
+          goalsStore.createIndex('by-targetDate', 'targetDate');
+        }
+
+        // Milestones store
+        if (!db.objectStoreNames.contains('milestones')) {
+          const milestonesStore = db.createObjectStore('milestones', { keyPath: 'id' });
+          milestonesStore.createIndex('by-goalId', 'goalId');
+          milestonesStore.createIndex('by-parentMilestoneId', 'parentMilestoneId');
+          milestonesStore.createIndex('by-state', 'state');
+        }
+
+        // Progress Updates store
+        if (!db.objectStoreNames.contains('progressUpdates')) {
+          const progressStore = db.createObjectStore('progressUpdates', { keyPath: 'id' });
+          progressStore.createIndex('by-entityId', 'entityId');
+          progressStore.createIndex('by-createdAt', 'createdAt');
+        }
+
+        // Dependencies store
+        if (!db.objectStoreNames.contains('dependencies')) {
+          const depsStore = db.createObjectStore('dependencies', { keyPath: 'id' });
+          depsStore.createIndex('by-sourceId', 'sourceId');
+          depsStore.createIndex('by-targetId', 'targetId');
+        }
+
+        // Decision Records store
+        if (!db.objectStoreNames.contains('decisionRecords')) {
+          const decisionsStore = db.createObjectStore('decisionRecords', { keyPath: 'id' });
+          decisionsStore.createIndex('by-goalId', 'goalId');
+        }
+
+        // Version History store
+        if (!db.objectStoreNames.contains('versionHistory')) {
+          const versionStore = db.createObjectStore('versionHistory', { keyPath: 'id' });
+          versionStore.createIndex('by-entityId', 'entityId');
+          versionStore.createIndex('by-createdAt', 'createdAt');
+        }
+
+        // Analytics stores
+        if (!db.objectStoreNames.contains('velocityMetrics')) {
+          const velocityStore = db.createObjectStore('velocityMetrics', { keyPath: 'entityId' });
+          velocityStore.createIndex('by-entityId', 'entityId');
+        }
+
+        if (!db.objectStoreNames.contains('estimationAccuracy')) {
+          const accuracyStore = db.createObjectStore('estimationAccuracy', { keyPath: 'entityId' });
+          accuracyStore.createIndex('by-entityId', 'entityId');
+        }
+
+        if (!db.objectStoreNames.contains('outcomeQuality')) {
+          const qualityStore = db.createObjectStore('outcomeQuality', { keyPath: 'entityId' });
+          qualityStore.createIndex('by-entityId', 'entityId');
+        }
+
+        if (!db.objectStoreNames.contains('trendAnalysis')) {
+          db.createObjectStore('trendAnalysis', { keyPath: 'userId' });
+        }
+      },
+      blocked(currentVersion, blockedVersion, event) {
+        console.warn('Database upgrade blocked. Please close other tabs with this app.');
+      },
+      blocking(currentVersion, blockedVersion, event) {
+        // Close the database to allow upgrade
+        dbInstance?.close();
+        dbInstance = null;
+      },
+      terminated() {
+        console.error('Database connection terminated unexpectedly');
+        dbInstance = null;
+      },
+    });
+
+    return dbInstance;
+  } catch (error) {
+    console.error('Failed to initialize database:', error);
+    throw new Error(`Database initialization failed: ${error}`);
+  }
+}
+
+// ============================================================================
+// Goal Operations
+// ============================================================================
+
+export async function getAllGoals(): Promise<Goal[]> {
+  const db = await initDB();
+  return db.getAll('goals');
+}
+
+export async function getGoalById(id: string): Promise<Goal | undefined> {
+  const db = await initDB();
+  return db.get('goals', id);
+}
+
+export async function saveGoal(goal: Goal): Promise<void> {
+  const db = await initDB();
+  await db.put('goals', goal);
+}
+
+export async function deleteGoal(id: string): Promise<void> {
+  const db = await initDB();
+  const tx = db.transaction(['goals', 'milestones', 'progressUpdates', 'dependencies', 'decisionRecords'], 'readwrite');
+  
+  // Delete the goal
+  await tx.objectStore('goals').delete(id);
+  
+  // Delete associated milestones
+  const milestones = await tx.objectStore('milestones').index('by-goalId').getAll(id);
+  for (const milestone of milestones) {
+    await tx.objectStore('milestones').delete(milestone.id);
+  }
+  
+  // Delete associated progress updates
+  const progressUpdates = await tx.objectStore('progressUpdates').index('by-entityId').getAll(id);
+  for (const update of progressUpdates) {
+    await tx.objectStore('progressUpdates').delete(update.id);
+  }
+  
+  // Delete associated dependencies (where this goal is source or target)
+  const sourceDeps = await tx.objectStore('dependencies').index('by-sourceId').getAll(id);
+  const targetDeps = await tx.objectStore('dependencies').index('by-targetId').getAll(id);
+  for (const dep of [...sourceDeps, ...targetDeps]) {
+    await tx.objectStore('dependencies').delete(dep.id);
+  }
+  
+  // Delete associated decision records
+  const decisions = await tx.objectStore('decisionRecords').index('by-goalId').getAll(id);
+  for (const decision of decisions) {
+    await tx.objectStore('decisionRecords').delete(decision.id);
+  }
+  
+  await tx.done;
+}
+
+export async function getGoalsByState(state: string): Promise<Goal[]> {
+  const db = await initDB();
+  return db.getAllFromIndex('goals', 'by-state', state);
+}
+
+// ============================================================================
+// Milestone Operations
+// ============================================================================
+
+export async function getAllMilestones(): Promise<Milestone[]> {
+  const db = await initDB();
+  return db.getAll('milestones');
+}
+
+export async function getMilestoneById(id: string): Promise<Milestone | undefined> {
+  const db = await initDB();
+  return db.get('milestones', id);
+}
+
+export async function getMilestonesByGoalId(goalId: string): Promise<Milestone[]> {
+  const db = await initDB();
+  return db.getAllFromIndex('milestones', 'by-goalId', goalId);
+}
+
+export async function getChildMilestones(parentId: string): Promise<Milestone[]> {
+  const db = await initDB();
+  return db.getAllFromIndex('milestones', 'by-parentMilestoneId', parentId);
+}
+
+export async function saveMilestone(milestone: Milestone): Promise<void> {
+  const db = await initDB();
+  await db.put('milestones', milestone);
+}
+
+export async function deleteMilestone(id: string): Promise<void> {
+  const db = await initDB();
+  const tx = db.transaction(['milestones', 'progressUpdates', 'dependencies'], 'readwrite');
+  
+  // Delete the milestone
+  await tx.objectStore('milestones').delete(id);
+  
+  // Delete child milestones recursively
+  const children = await tx.objectStore('milestones').index('by-parentMilestoneId').getAll(id);
+  for (const child of children) {
+    await tx.objectStore('milestones').delete(child.id);
+  }
+  
+  // Delete associated progress updates
+  const progressUpdates = await tx.objectStore('progressUpdates').index('by-entityId').getAll(id);
+  for (const update of progressUpdates) {
+    await tx.objectStore('progressUpdates').delete(update.id);
+  }
+  
+  // Delete associated dependencies
+  const sourceDeps = await tx.objectStore('dependencies').index('by-sourceId').getAll(id);
+  const targetDeps = await tx.objectStore('dependencies').index('by-targetId').getAll(id);
+  for (const dep of [...sourceDeps, ...targetDeps]) {
+    await tx.objectStore('dependencies').delete(dep.id);
+  }
+  
+  await tx.done;
+}
+
+// ============================================================================
+// Progress Update Operations
+// ============================================================================
+
+export async function getAllProgressUpdates(): Promise<ProgressUpdate[]> {
+  const db = await initDB();
+  return db.getAll('progressUpdates');
+}
+
+export async function getProgressUpdatesByEntityId(entityId: string): Promise<ProgressUpdate[]> {
+  const db = await initDB();
+  return db.getAllFromIndex('progressUpdates', 'by-entityId', entityId);
+}
+
+export async function saveProgressUpdate(update: ProgressUpdate): Promise<void> {
+  const db = await initDB();
+  await db.put('progressUpdates', update);
+}
+
+export async function deleteProgressUpdate(id: string): Promise<void> {
+  const db = await initDB();
+  await db.delete('progressUpdates', id);
+}
+
+// ============================================================================
+// Dependency Operations
+// ============================================================================
+
+export async function getAllDependencies(): Promise<Dependency[]> {
+  const db = await initDB();
+  return db.getAll('dependencies');
+}
+
+export async function getDependenciesBySourceId(sourceId: string): Promise<Dependency[]> {
+  const db = await initDB();
+  return db.getAllFromIndex('dependencies', 'by-sourceId', sourceId);
+}
+
+export async function getDependenciesByTargetId(targetId: string): Promise<Dependency[]> {
+  const db = await initDB();
+  return db.getAllFromIndex('dependencies', 'by-targetId', targetId);
+}
+
+export async function saveDependency(dependency: Dependency): Promise<void> {
+  const db = await initDB();
+  await db.put('dependencies', dependency);
+}
+
+export async function deleteDependency(id: string): Promise<void> {
+  const db = await initDB();
+  await db.delete('dependencies', id);
+}
+
+// ============================================================================
+// Decision Record Operations
+// ============================================================================
+
+export async function getDecisionRecordsByGoalId(goalId: string): Promise<DecisionRecord[]> {
+  const db = await initDB();
+  return db.getAllFromIndex('decisionRecords', 'by-goalId', goalId);
+}
+
+export async function saveDecisionRecord(record: DecisionRecord): Promise<void> {
+  const db = await initDB();
+  await db.put('decisionRecords', record);
+}
+
+export async function deleteDecisionRecord(id: string): Promise<void> {
+  const db = await initDB();
+  await db.delete('decisionRecords', id);
+}
+
+// ============================================================================
+// Version History Operations
+// ============================================================================
+
+export async function getVersionHistoryByEntityId(entityId: string): Promise<VersionSnapshot[]> {
+  const db = await initDB();
+  const snapshots = await db.getAllFromIndex('versionHistory', 'by-entityId', entityId);
+  return snapshots.sort((a, b) => b.version - a.version);
+}
+
+export async function saveVersionSnapshot(snapshot: VersionSnapshot): Promise<void> {
+  const db = await initDB();
+  await db.put('versionHistory', snapshot);
+}
+
+export async function getLatestVersion(entityId: string): Promise<number> {
+  const snapshots = await getVersionHistoryByEntityId(entityId);
+  if (snapshots.length === 0) return 0;
+  return Math.max(...snapshots.map(s => s.version));
+}
+
+// ============================================================================
+// Analytics Operations
+// ============================================================================
+
+export async function saveVelocityMetrics(metrics: VelocityMetrics): Promise<void> {
+  const db = await initDB();
+  await db.put('velocityMetrics', metrics);
+}
+
+export async function getVelocityMetrics(entityId: string): Promise<VelocityMetrics | undefined> {
+  const db = await initDB();
+  return db.get('velocityMetrics', entityId);
+}
+
+export async function saveEstimationAccuracy(accuracy: EstimationAccuracy): Promise<void> {
+  const db = await initDB();
+  await db.put('estimationAccuracy', accuracy);
+}
+
+export async function getEstimationAccuracy(entityId: string): Promise<EstimationAccuracy | undefined> {
+  const db = await initDB();
+  return db.get('estimationAccuracy', entityId);
+}
+
+export async function saveOutcomeQuality(quality: OutcomeQualityScore): Promise<void> {
+  const db = await initDB();
+  await db.put('outcomeQuality', quality);
+}
+
+export async function getOutcomeQuality(entityId: string): Promise<OutcomeQualityScore | undefined> {
+  const db = await initDB();
+  return db.get('outcomeQuality', entityId);
+}
+
+export async function saveTrendAnalysis(trend: TrendAnalysis): Promise<void> {
+  const db = await initDB();
+  await db.put('trendAnalysis', trend);
+}
+
+export async function getTrendAnalysis(userId: string = 'default'): Promise<TrendAnalysis | undefined> {
+  const db = await initDB();
+  return db.get('trendAnalysis', userId);
+}
+
+// ============================================================================
+// Bulk Operations & Export
+// ============================================================================
+
+export interface ExportData {
+  exportedAt: string;
+  version: string;
+  goals: Goal[];
+  milestones: Milestone[];
+  progressUpdates: ProgressUpdate[];
+  dependencies: Dependency[];
+  decisionRecords: DecisionRecord[];
+  versionHistory: VersionSnapshot[];
+}
+
+export async function exportAllData(): Promise<ExportData> {
+  const db = await initDB();
+  
+  const [goals, milestones, progressUpdates, dependencies, decisionRecords, versionHistory] = await Promise.all([
+    db.getAll('goals'),
+    db.getAll('milestones'),
+    db.getAll('progressUpdates'),
+    db.getAll('dependencies'),
+    db.getAll('decisionRecords'),
+    db.getAll('versionHistory'),
+  ]);
+  
+  return {
+    exportedAt: new Date().toISOString(),
+    version: '1.0.0',
+    goals,
+    milestones,
+    progressUpdates,
+    dependencies,
+    decisionRecords,
+    versionHistory,
+  };
+}
+
+export async function importData(data: ExportData): Promise<void> {
+  const db = await initDB();
+  
+  const tx = db.transaction(
+    ['goals', 'milestones', 'progressUpdates', 'dependencies', 'decisionRecords', 'versionHistory'],
+    'readwrite'
+  );
+  
+  // Import all data
+  for (const goal of data.goals) {
+    await tx.objectStore('goals').put(goal);
+  }
+  for (const milestone of data.milestones) {
+    await tx.objectStore('milestones').put(milestone);
+  }
+  for (const update of data.progressUpdates) {
+    await tx.objectStore('progressUpdates').put(update);
+  }
+  for (const dep of data.dependencies) {
+    await tx.objectStore('dependencies').put(dep);
+  }
+  for (const decision of data.decisionRecords) {
+    await tx.objectStore('decisionRecords').put(decision);
+  }
+  for (const version of data.versionHistory) {
+    await tx.objectStore('versionHistory').put(version);
+  }
+  
+  await tx.done;
+}
+
+export async function clearAllData(): Promise<void> {
+  const db = await initDB();
+  
+  const tx = db.transaction(
+    ['goals', 'milestones', 'progressUpdates', 'dependencies', 'decisionRecords', 'versionHistory', 
+     'velocityMetrics', 'estimationAccuracy', 'outcomeQuality', 'trendAnalysis'],
+    'readwrite'
+  );
+  
+  await Promise.all([
+    tx.objectStore('goals').clear(),
+    tx.objectStore('milestones').clear(),
+    tx.objectStore('progressUpdates').clear(),
+    tx.objectStore('dependencies').clear(),
+    tx.objectStore('decisionRecords').clear(),
+    tx.objectStore('versionHistory').clear(),
+    tx.objectStore('velocityMetrics').clear(),
+    tx.objectStore('estimationAccuracy').clear(),
+    tx.objectStore('outcomeQuality').clear(),
+    tx.objectStore('trendAnalysis').clear(),
+  ]);
+  
+  await tx.done;
+}
+
+// ============================================================================
+// Recovery & Health Check
+// ============================================================================
+
+export interface DBHealthStatus {
+  isHealthy: boolean;
+  storeStatus: Record<string, { count: number; error?: string }>;
+  errors: string[];
+}
+
+export async function checkDatabaseHealth(): Promise<DBHealthStatus> {
+  const status: DBHealthStatus = {
+    isHealthy: true,
+    storeStatus: {},
+    errors: [],
+  };
+  
+  try {
+    const db = await initDB();
+    
+    const stores = [
+      'goals', 'milestones', 'progressUpdates', 'dependencies',
+      'decisionRecords', 'versionHistory', 'velocityMetrics',
+      'estimationAccuracy', 'outcomeQuality', 'trendAnalysis'
+    ] as const;
+    
+    for (const store of stores) {
+      try {
+        const count = await db.count(store);
+        status.storeStatus[store] = { count };
+      } catch (error) {
+        status.isHealthy = false;
+        status.storeStatus[store] = { count: 0, error: String(error) };
+        status.errors.push(`Store '${store}' error: ${error}`);
+      }
+    }
+  } catch (error) {
+    status.isHealthy = false;
+    status.errors.push(`Database connection error: ${error}`);
+  }
+  
+  return status;
+}
diff --git a/repository_after/goal-traking/app/lib/dependencies.ts b/repository_after/goal-traking/app/lib/dependencies.ts
new file mode 100644
index 00000000..f8b5eead
--- /dev/null
+++ b/repository_after/goal-traking/app/lib/dependencies.ts
@@ -0,0 +1,542 @@
+// Dependency Validation Engine
+// Detects circular dependencies, deadlocks, and provides diagnostics
+
+import { Dependency, Goal, Milestone } from './types';
+
+// ============================================================================
+// Types
+// ============================================================================
+
+export interface DependencyGraph {
+  nodes: Map<string, DependencyNode>;
+  edges: Map<string, string[]>;
+}
+
+export interface DependencyNode {
+  id: string;
+  type: 'goal' | 'milestone';
+  state: string;
+  title: string;
+}
+
+export interface DependencyValidationResult {
+  isValid: boolean;
+  hasCircularDependency: boolean;
+  circularPath?: string[];
+  hasDeadlock: boolean;
+  deadlockedItems?: string[];
+  blockedItems: BlockedItemInfo[];
+  cascadingDelays: CascadingDelayInfo[];
+  diagnostics: string[];
+}
+
+export interface BlockedItemInfo {
+  itemId: string;
+  itemTitle: string;
+  blockedBy: {
+    id: string;
+    title: string;
+    state: string;
+  }[];
+}
+
+export interface CascadingDelayInfo {
+  sourceId: string;
+  sourceTitle: string;
+  affectedItems: {
+    id: string;
+    title: string;
+    delayPropagation: number; // How many levels deep
+  }[];
+}
+
+// ============================================================================
+// Graph Building
+// ============================================================================
+
+/**
+ * Builds a dependency graph from goals, milestones, and dependencies
+ */
+export function buildDependencyGraph(
+  goals: Goal[],
+  milestones: Milestone[],
+  dependencies: Dependency[]
+): DependencyGraph {
+  const nodes = new Map<string, DependencyNode>();
+  const edges = new Map<string, string[]>();
+  
+  // Add goal nodes
+  for (const goal of goals) {
+    nodes.set(goal.id, {
+      id: goal.id,
+      type: 'goal',
+      state: goal.state,
+      title: goal.title,
+    });
+    edges.set(goal.id, []);
+  }
+  
+  // Add milestone nodes
+  for (const milestone of milestones) {
+    nodes.set(milestone.id, {
+      id: milestone.id,
+      type: 'milestone',
+      state: milestone.state,
+      title: milestone.title,
+    });
+    edges.set(milestone.id, []);
+  }
+  
+  // Add edges (source depends on target)
+  for (const dep of dependencies) {
+    const sourceEdges = edges.get(dep.sourceId) || [];
+    sourceEdges.push(dep.targetId);
+    edges.set(dep.sourceId, sourceEdges);
+  }
+  
+  return { nodes, edges };
+}
+
+// ============================================================================
+// Circular Dependency Detection
+// ============================================================================
+
+/**
+ * Detects circular dependencies using DFS
+ */
+export function detectCircularDependencies(
+  graph: DependencyGraph
+): { hasCircle: boolean; path?: string[] } {
+  const visited = new Set<string>();
+  const recursionStack = new Set<string>();
+  const path: string[] = [];
+  
+  function dfs(nodeId: string): boolean {
+    visited.add(nodeId);
+    recursionStack.add(nodeId);
+    path.push(nodeId);
+    
+    const neighbors = graph.edges.get(nodeId) || [];
+    for (const neighbor of neighbors) {
+      if (!visited.has(neighbor)) {
+        if (dfs(neighbor)) {
+          return true;
+        }
+      } else if (recursionStack.has(neighbor)) {
+        // Found a cycle - extract the cycle path
+        const cycleStart = path.indexOf(neighbor);
+        path.push(neighbor);
+        return true;
+      }
+    }
+    
+    path.pop();
+    recursionStack.delete(nodeId);
+    return false;
+  }
+  
+  for (const nodeId of graph.nodes.keys()) {
+    if (!visited.has(nodeId)) {
+      if (dfs(nodeId)) {
+        // Find where the cycle starts in the path
+        const cycleStart = path.findIndex((id, index) => 
+          index < path.length - 1 && path.lastIndexOf(id) > index
+        );
+        
+        if (cycleStart >= 0) {
+          const cyclePath = path.slice(cycleStart);
+          return { hasCircle: true, path: cyclePath };
+        }
+        return { hasCircle: true, path };
+      }
+    }
+  }
+  
+  return { hasCircle: false };
+}
+
+/**
+ * Checks if adding a new dependency would create a circular dependency
+ */
+export function wouldCreateCircularDependency(
+  graph: DependencyGraph,
+  sourceId: string,
+  targetId: string
+): boolean {
+  // Check if there's already a path from target to source
+  // If so, adding source -> target would create a cycle
+  const visited = new Set<string>();
+  
+  function canReach(from: string, to: string): boolean {
+    if (from === to) return true;
+    if (visited.has(from)) return false;
+    
+    visited.add(from);
+    const neighbors = graph.edges.get(from) || [];
+    
+    for (const neighbor of neighbors) {
+      if (canReach(neighbor, to)) {
+        return true;
+      }
+    }
+    
+    return false;
+  }
+  
+  return canReach(targetId, sourceId);
+}
+
+// ============================================================================
+// Deadlock Detection
+// ============================================================================
+
+/**
+ * Detects deadlock situations where items are mutually blocked
+ */
+export function detectDeadlocks(
+  graph: DependencyGraph,
+  dependencies: Dependency[]
+): { hasDeadlock: boolean; deadlockedItems: string[] } {
+  const deadlockedItems: string[] = [];
+  
+  // Find items that are blocked by incomplete items, where those items are also blocked
+  for (const [nodeId, node] of graph.nodes) {
+    if (node.state === 'completed' || node.state === 'failed' || node.state === 'abandoned') {
+      continue;
+    }
+    
+    const blockingItems = getBlockingItems(nodeId, graph, dependencies);
+    
+    for (const blockerId of blockingItems) {
+      const blockerBlockers = getBlockingItems(blockerId, graph, dependencies);
+      
+      // If the blocker is also blocked by this item (or items blocked by this item),
+      // we have a deadlock
+      if (blockerBlockers.includes(nodeId)) {
+        if (!deadlockedItems.includes(nodeId)) {
+          deadlockedItems.push(nodeId);
+        }
+        if (!deadlockedItems.includes(blockerId)) {
+          deadlockedItems.push(blockerId);
+        }
+      }
+    }
+  }
+  
+  return {
+    hasDeadlock: deadlockedItems.length > 0,
+    deadlockedItems,
+  };
+}
+
+/**
+ * Gets all items that are blocking a given item
+ */
+function getBlockingItems(
+  itemId: string,
+  graph: DependencyGraph,
+  dependencies: Dependency[]
+): string[] {
+  const blockers: string[] = [];
+  
+  const itemDeps = dependencies.filter(d => 
+    d.sourceId === itemId && 
+    (d.dependencyType === 'blocks' || d.dependencyType === 'requires')
+  );
+  
+  for (const dep of itemDeps) {
+    const targetNode = graph.nodes.get(dep.targetId);
+    if (targetNode && targetNode.state !== 'completed') {
+      blockers.push(dep.targetId);
+    }
+  }
+  
+  return blockers;
+}
+
+// ============================================================================
+// Cascading Delay Detection
+// ============================================================================
+
+/**
+ * Detects cascading delays from upstream items
+ */
+export function detectCascadingDelays(
+  graph: DependencyGraph,
+  dependencies: Dependency[]
+): CascadingDelayInfo[] {
+  const delays: CascadingDelayInfo[] = [];
+  
+  // Find all incomplete items that have dependents
+  for (const [nodeId, node] of graph.nodes) {
+    if (node.state === 'completed') continue;
+    
+    // Find all items that depend on this one
+    const dependents = dependencies.filter(d => d.targetId === nodeId);
+    
+    if (dependents.length === 0) continue;
+    
+    // Calculate cascading effect
+    const affected = new Map<string, number>(); // id -> propagation level
+    
+    function findAffected(currentId: string, level: number) {
+      const directDependents = dependencies.filter(d => d.targetId === currentId);
+      
+      for (const dep of directDependents) {
+        const existingLevel = affected.get(dep.sourceId);
+        if (existingLevel === undefined || level < existingLevel) {
+          affected.set(dep.sourceId, level);
+          findAffected(dep.sourceId, level + 1);
+        }
+      }
+    }
+    
+    findAffected(nodeId, 1);
+    
+    if (affected.size > 0) {
+      const affectedItems = Array.from(affected.entries()).map(([id, level]) => {
+        const affectedNode = graph.nodes.get(id);
+        return {
+          id,
+          title: affectedNode?.title || 'Unknown',
+          delayPropagation: level,
+        };
+      });
+      
+      delays.push({
+        sourceId: nodeId,
+        sourceTitle: node.title,
+        affectedItems,
+      });
+    }
+  }
+  
+  return delays;
+}
+
+// ============================================================================
+// Blocked Items Analysis
+// ============================================================================
+
+/**
+ * Analyzes which items are currently blocked and by what
+ */
+export function analyzeBlockedItems(
+  graph: DependencyGraph,
+  dependencies: Dependency[]
+): BlockedItemInfo[] {
+  const blockedItems: BlockedItemInfo[] = [];
+  
+  for (const [nodeId, node] of graph.nodes) {
+    // Skip completed/failed/abandoned items
+    if (['completed', 'failed', 'abandoned'].includes(node.state)) {
+      continue;
+    }
+    
+    // Find blocking dependencies for this item
+    const blockingDeps = dependencies.filter(d => 
+      d.sourceId === nodeId && 
+      (d.dependencyType === 'blocks' || d.dependencyType === 'requires')
+    );
+    
+    const blockers: { id: string; title: string; state: string }[] = [];
+    
+    for (const dep of blockingDeps) {
+      const targetNode = graph.nodes.get(dep.targetId);
+      if (targetNode && targetNode.state !== 'completed') {
+        blockers.push({
+          id: dep.targetId,
+          title: targetNode.title,
+          state: targetNode.state,
+        });
+      }
+    }
+    
+    if (blockers.length > 0) {
+      blockedItems.push({
+        itemId: nodeId,
+        itemTitle: node.title,
+        blockedBy: blockers,
+      });
+    }
+  }
+  
+  return blockedItems;
+}
+
+// ============================================================================
+// Complete Validation
+// ============================================================================
+
+/**
+ * Performs complete dependency validation and returns diagnostics
+ */
+export function validateDependencies(
+  goals: Goal[],
+  milestones: Milestone[],
+  dependencies: Dependency[]
+): DependencyValidationResult {
+  const diagnostics: string[] = [];
+  
+  // Build graph
+  const graph = buildDependencyGraph(goals, milestones, dependencies);
+  
+  // Check for circular dependencies
+  const circularCheck = detectCircularDependencies(graph);
+  if (circularCheck.hasCircle && circularCheck.path) {
+    const pathTitles = circularCheck.path.map(id => {
+      const node = graph.nodes.get(id);
+      return node?.title || id;
+    });
+    diagnostics.push(`Circular dependency detected: ${pathTitles.join(' â†’ ')}`);
+  }
+  
+  // Check for deadlocks
+  const deadlockCheck = detectDeadlocks(graph, dependencies);
+  if (deadlockCheck.hasDeadlock) {
+    const deadlockedTitles = deadlockCheck.deadlockedItems.map(id => {
+      const node = graph.nodes.get(id);
+      return node?.title || id;
+    });
+    diagnostics.push(`Deadlock detected among: ${deadlockedTitles.join(', ')}`);
+  }
+  
+  // Analyze blocked items
+  const blockedItems = analyzeBlockedItems(graph, dependencies);
+  for (const blocked of blockedItems) {
+    const blockerList = blocked.blockedBy.map(b => b.title).join(', ');
+    diagnostics.push(`"${blocked.itemTitle}" is blocked by: ${blockerList}`);
+  }
+  
+  // Detect cascading delays
+  const cascadingDelays = detectCascadingDelays(graph, dependencies);
+  for (const delay of cascadingDelays) {
+    if (delay.affectedItems.length > 2) {
+      diagnostics.push(
+        `"${delay.sourceTitle}" is causing delays in ${delay.affectedItems.length} downstream items`
+      );
+    }
+  }
+  
+  return {
+    isValid: !circularCheck.hasCircle && !deadlockCheck.hasDeadlock,
+    hasCircularDependency: circularCheck.hasCircle,
+    circularPath: circularCheck.path,
+    hasDeadlock: deadlockCheck.hasDeadlock,
+    deadlockedItems: deadlockCheck.deadlockedItems,
+    blockedItems,
+    cascadingDelays,
+    diagnostics,
+  };
+}
+
+// ============================================================================
+// Dependency Management Helpers
+// ============================================================================
+
+/**
+ * Checks if an item can be marked as complete (all dependencies satisfied)
+ */
+export function canMarkComplete(
+  itemId: string,
+  graph: DependencyGraph,
+  dependencies: Dependency[]
+): { canComplete: boolean; blockingItems: string[] } {
+  const blockingDeps = dependencies.filter(d => 
+    d.sourceId === itemId && 
+    (d.dependencyType === 'blocks' || d.dependencyType === 'requires')
+  );
+  
+  const blockingItems: string[] = [];
+  
+  for (const dep of blockingDeps) {
+    const targetNode = graph.nodes.get(dep.targetId);
+    if (targetNode && targetNode.state !== 'completed') {
+      blockingItems.push(targetNode.title);
+    }
+  }
+  
+  return {
+    canComplete: blockingItems.length === 0,
+    blockingItems,
+  };
+}
+
+/**
+ * Gets topologically sorted order for execution (respecting dependencies)
+ */
+export function getExecutionOrder(
+  graph: DependencyGraph
+): string[] {
+  const visited = new Set<string>();
+  const order: string[] = [];
+  
+  function visit(nodeId: string) {
+    if (visited.has(nodeId)) return;
+    visited.add(nodeId);
+    
+    const dependencies = graph.edges.get(nodeId) || [];
+    for (const depId of dependencies) {
+      visit(depId);
+    }
+    
+    order.push(nodeId);
+  }
+  
+  for (const nodeId of graph.nodes.keys()) {
+    visit(nodeId);
+  }
+  
+  return order;
+}
+
+/**
+ * Calculates the critical path (longest chain of dependencies)
+ */
+export function getCriticalPath(
+  graph: DependencyGraph
+): { path: string[]; length: number } {
+  const memo = new Map<string, { path: string[]; length: number }>();
+  
+  function findLongestPath(nodeId: string): { path: string[]; length: number } {
+    if (memo.has(nodeId)) {
+      return memo.get(nodeId)!;
+    }
+    
+    const deps = graph.edges.get(nodeId) || [];
+    
+    if (deps.length === 0) {
+      const result = { path: [nodeId], length: 1 };
+      memo.set(nodeId, result);
+      return result;
+    }
+    
+    let longestPath: string[] = [];
+    let maxLength = 0;
+    
+    for (const depId of deps) {
+      const subPath = findLongestPath(depId);
+      if (subPath.length > maxLength) {
+        maxLength = subPath.length;
+        longestPath = subPath.path;
+      }
+    }
+    
+    const result = { path: [nodeId, ...longestPath], length: maxLength + 1 };
+    memo.set(nodeId, result);
+    return result;
+  }
+  
+  let criticalPath: string[] = [];
+  let maxLength = 0;
+  
+  for (const nodeId of graph.nodes.keys()) {
+    const result = findLongestPath(nodeId);
+    if (result.length > maxLength) {
+      maxLength = result.length;
+      criticalPath = result.path;
+    }
+  }
+  
+  return { path: criticalPath, length: maxLength };
+}
diff --git a/repository_after/goal-traking/app/lib/export.ts b/repository_after/goal-traking/app/lib/export.ts
new file mode 100644
index 00000000..e5522e84
--- /dev/null
+++ b/repository_after/goal-traking/app/lib/export.ts
@@ -0,0 +1,340 @@
+// Export Utilities for Goal Tracking Application
+// Supports JSON and CSV export with full data integrity
+
+import {
+  Goal,
+  Milestone,
+  ProgressUpdate,
+  Dependency,
+  DecisionRecord,
+  VersionSnapshot,
+  ExportConfig,
+} from './types';
+import { ExportData } from './db';
+
+// ============================================================================
+// JSON Export
+// ============================================================================
+
+/**
+ * Exports data as a formatted JSON string
+ */
+export function exportToJSON(data: ExportData): string {
+  return JSON.stringify(data, null, 2);
+}
+
+/**
+ * Creates a downloadable JSON file
+ */
+export function downloadJSON(data: ExportData, filename: string = 'goal-tracking-export'): void {
+  const jsonString = exportToJSON(data);
+  const blob = new Blob([jsonString], { type: 'application/json' });
+  downloadBlob(blob, `${filename}.json`);
+}
+
+// ============================================================================
+// CSV Export
+// ============================================================================
+
+interface CSVColumn<T> {
+  header: string;
+  accessor: (item: T) => string | number | boolean | null | undefined;
+}
+
+function escapeCSV(value: string | number | boolean | null | undefined): string {
+  if (value === null || value === undefined) {
+    return '';
+  }
+  
+  const stringValue = String(value);
+  
+  // Escape quotes and wrap in quotes if contains special characters
+  if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
+    return `"${stringValue.replace(/"/g, '""')}"`;
+  }
+  
+  return stringValue;
+}
+
+function toCSV<T>(items: T[], columns: CSVColumn<T>[]): string {
+  const headers = columns.map(c => escapeCSV(c.header)).join(',');
+  
+  const rows = items.map(item => 
+    columns.map(col => escapeCSV(col.accessor(item))).join(',')
+  );
+  
+  return [headers, ...rows].join('\n');
+}
+
+// Goal columns
+const goalColumns: CSVColumn<Goal>[] = [
+  { header: 'ID', accessor: g => g.id },
+  { header: 'Title', accessor: g => g.title },
+  { header: 'Description', accessor: g => g.description || '' },
+  { header: 'Priority', accessor: g => g.priority },
+  { header: 'Priority Weight', accessor: g => g.priorityWeight },
+  { header: 'State', accessor: g => g.state },
+  { header: 'Progress', accessor: g => g.progress },
+  { header: 'Start Date', accessor: g => g.startDate || '' },
+  { header: 'Target Date', accessor: g => g.targetDate || '' },
+  { header: 'Completed At', accessor: g => g.completedAt || '' },
+  { header: 'Success Criteria', accessor: g => g.successCriteria.join('; ') },
+  { header: 'Motivation Notes', accessor: g => g.motivationNotes || '' },
+  { header: 'Tags', accessor: g => g.tags.join('; ') },
+  { header: 'Created At', accessor: g => g.createdAt },
+  { header: 'Updated At', accessor: g => g.updatedAt },
+];
+
+// Milestone columns
+const milestoneColumns: CSVColumn<Milestone>[] = [
+  { header: 'ID', accessor: m => m.id },
+  { header: 'Goal ID', accessor: m => m.goalId },
+  { header: 'Parent Milestone ID', accessor: m => m.parentMilestoneId || '' },
+  { header: 'Title', accessor: m => m.title },
+  { header: 'Description', accessor: m => m.description || '' },
+  { header: 'Priority', accessor: m => m.priority },
+  { header: 'State', accessor: m => m.state },
+  { header: 'Progress', accessor: m => m.progress },
+  { header: 'Order', accessor: m => m.order },
+  { header: 'Target Date', accessor: m => m.targetDate || '' },
+  { header: 'Completed At', accessor: m => m.completedAt || '' },
+  { header: 'Created At', accessor: m => m.createdAt },
+  { header: 'Updated At', accessor: m => m.updatedAt },
+];
+
+// Progress update columns
+const progressUpdateColumns: CSVColumn<ProgressUpdate>[] = [
+  { header: 'ID', accessor: p => p.id },
+  { header: 'Entity ID', accessor: p => p.entityId },
+  { header: 'Entity Type', accessor: p => p.entityType },
+  { header: 'Percentage', accessor: p => p.percentage },
+  { header: 'Notes', accessor: p => p.notes || '' },
+  { header: 'Time Spent (minutes)', accessor: p => p.timeSpentMinutes || 0 },
+  { header: 'Blockers', accessor: p => p.blockers.join('; ') },
+  { header: 'Confidence Level', accessor: p => p.confidenceLevel || '' },
+  { header: 'Motivation Level', accessor: p => p.motivationLevel || '' },
+  { header: 'Perceived Difficulty', accessor: p => p.perceivedDifficulty || '' },
+  { header: 'Emotional State', accessor: p => p.emotionalState || '' },
+  { header: 'Created At', accessor: p => p.createdAt },
+];
+
+// Dependency columns
+const dependencyColumns: CSVColumn<Dependency>[] = [
+  { header: 'ID', accessor: d => d.id },
+  { header: 'Source ID', accessor: d => d.sourceId },
+  { header: 'Target ID', accessor: d => d.targetId },
+  { header: 'Source Type', accessor: d => d.sourceType },
+  { header: 'Target Type', accessor: d => d.targetType },
+  { header: 'Dependency Type', accessor: d => d.dependencyType },
+  { header: 'Created At', accessor: d => d.createdAt },
+];
+
+/**
+ * Exports goals to CSV format
+ */
+export function exportGoalsToCSV(goals: Goal[]): string {
+  return toCSV(goals, goalColumns);
+}
+
+/**
+ * Exports milestones to CSV format
+ */
+export function exportMilestonesToCSV(milestones: Milestone[]): string {
+  return toCSV(milestones, milestoneColumns);
+}
+
+/**
+ * Exports progress updates to CSV format
+ */
+export function exportProgressUpdatesToCSV(progressUpdates: ProgressUpdate[]): string {
+  return toCSV(progressUpdates, progressUpdateColumns);
+}
+
+/**
+ * Exports dependencies to CSV format
+ */
+export function exportDependenciesToCSV(dependencies: Dependency[]): string {
+  return toCSV(dependencies, dependencyColumns);
+}
+
+/**
+ * Creates a zip file with multiple CSV files
+ */
+export async function downloadAllCSV(
+  data: ExportData,
+  filename: string = 'goal-tracking-export'
+): Promise<void> {
+  // For now, we'll create a combined CSV with section headers
+  const sections = [
+    '# GOALS',
+    exportGoalsToCSV(data.goals),
+    '',
+    '# MILESTONES',
+    exportMilestonesToCSV(data.milestones),
+    '',
+    '# PROGRESS UPDATES',
+    exportProgressUpdatesToCSV(data.progressUpdates),
+    '',
+    '# DEPENDENCIES',
+    exportDependenciesToCSV(data.dependencies),
+  ];
+  
+  const combinedCSV = sections.join('\n');
+  const blob = new Blob([combinedCSV], { type: 'text/csv;charset=utf-8;' });
+  downloadBlob(blob, `${filename}.csv`);
+}
+
+// ============================================================================
+// Download Helpers
+// ============================================================================
+
+function downloadBlob(blob: Blob, filename: string): void {
+  const url = URL.createObjectURL(blob);
+  const link = document.createElement('a');
+  link.href = url;
+  link.download = filename;
+  document.body.appendChild(link);
+  link.click();
+  document.body.removeChild(link);
+  URL.revokeObjectURL(url);
+}
+
+// ============================================================================
+// Import Validation
+// ============================================================================
+
+interface ImportValidationResult {
+  isValid: boolean;
+  errors: string[];
+  warnings: string[];
+  summary: {
+    goalsCount: number;
+    milestonesCount: number;
+    progressUpdatesCount: number;
+    dependenciesCount: number;
+  };
+}
+
+/**
+ * Validates imported JSON data before processing
+ */
+export function validateImportData(data: unknown): ImportValidationResult {
+  const errors: string[] = [];
+  const warnings: string[] = [];
+  
+  if (!data || typeof data !== 'object') {
+    return {
+      isValid: false,
+      errors: ['Invalid data format: expected an object'],
+      warnings: [],
+      summary: { goalsCount: 0, milestonesCount: 0, progressUpdatesCount: 0, dependenciesCount: 0 },
+    };
+  }
+  
+  const obj = data as Record<string, unknown>;
+  
+  // Check required fields
+  if (!Array.isArray(obj.goals)) {
+    errors.push('Missing or invalid "goals" array');
+  }
+  if (!Array.isArray(obj.milestones)) {
+    errors.push('Missing or invalid "milestones" array');
+  }
+  if (!Array.isArray(obj.progressUpdates)) {
+    errors.push('Missing or invalid "progressUpdates" array');
+  }
+  if (!Array.isArray(obj.dependencies)) {
+    errors.push('Missing or invalid "dependencies" array');
+  }
+  
+  // Validate version
+  if (!obj.version) {
+    warnings.push('Missing version field - assuming current version');
+  }
+  
+  // Validate timestamps
+  if (!obj.exportedAt) {
+    warnings.push('Missing exportedAt timestamp');
+  }
+  
+  // Count items
+  const goalsCount = Array.isArray(obj.goals) ? obj.goals.length : 0;
+  const milestonesCount = Array.isArray(obj.milestones) ? obj.milestones.length : 0;
+  const progressUpdatesCount = Array.isArray(obj.progressUpdates) ? obj.progressUpdates.length : 0;
+  const dependenciesCount = Array.isArray(obj.dependencies) ? obj.dependencies.length : 0;
+  
+  // Validate goal references in milestones
+  if (Array.isArray(obj.goals) && Array.isArray(obj.milestones)) {
+    const goalIds = new Set((obj.goals as Goal[]).map(g => g.id));
+    for (const milestone of obj.milestones as Milestone[]) {
+      if (!goalIds.has(milestone.goalId)) {
+        warnings.push(`Milestone "${milestone.title}" references non-existent goal ${milestone.goalId}`);
+      }
+    }
+  }
+  
+  return {
+    isValid: errors.length === 0,
+    errors,
+    warnings,
+    summary: {
+      goalsCount,
+      milestonesCount,
+      progressUpdatesCount,
+      dependenciesCount,
+    },
+  };
+}
+
+// ============================================================================
+// Filtered Export
+// ============================================================================
+
+/**
+ * Exports data based on configuration options
+ */
+export function exportWithConfig(
+  data: ExportData,
+  config: ExportConfig
+): Partial<ExportData> {
+  const result: Partial<ExportData> = {
+    exportedAt: new Date().toISOString(),
+    version: data.version,
+  };
+  
+  // Filter by date range if specified
+  const filterByDate = (date: string | undefined): boolean => {
+    if (!date) return true;
+    if (!config.dateRange) return true;
+    
+    const itemDate = new Date(date);
+    if (config.dateRange.from && itemDate < new Date(config.dateRange.from)) {
+      return false;
+    }
+    if (config.dateRange.to && itemDate > new Date(config.dateRange.to)) {
+      return false;
+    }
+    return true;
+  };
+  
+  if (config.includeGoals) {
+    result.goals = data.goals.filter(g => filterByDate(g.createdAt));
+  }
+  
+  if (config.includeMilestones) {
+    const includedGoalIds = new Set(result.goals?.map(g => g.id) || data.goals.map(g => g.id));
+    result.milestones = data.milestones.filter(m => 
+      includedGoalIds.has(m.goalId) && filterByDate(m.createdAt)
+    );
+  }
+  
+  if (config.includeProgressUpdates) {
+    result.progressUpdates = data.progressUpdates.filter(p => filterByDate(p.createdAt));
+  }
+  
+  if (config.includeVersionHistory) {
+    result.versionHistory = data.versionHistory.filter(v => filterByDate(v.createdAt));
+  }
+  
+  return result;
+}
diff --git a/repository_after/goal-traking/app/lib/index.ts b/repository_after/goal-traking/app/lib/index.ts
new file mode 100644
index 00000000..6fcf6f3f
--- /dev/null
+++ b/repository_after/goal-traking/app/lib/index.ts
@@ -0,0 +1,22 @@
+// Barrel export for all library modules
+// Note: Individual modules should be imported directly to avoid naming conflicts
+export * from './types';
+
+// Re-export db module with namespace
+import * as db from './db';
+export { db };
+
+// Re-export store
+export { useGoalStore } from './store';
+
+// Re-export analytics with namespace to avoid conflicts with db
+import * as analytics from './analytics';
+export { analytics };
+
+// Re-export dependencies with namespace
+import * as dependencies from './dependencies';
+export { dependencies };
+
+// Re-export export utilities with namespace
+import * as exportUtils from './export';
+export { exportUtils };
diff --git a/repository_after/goal-traking/app/lib/store.ts b/repository_after/goal-traking/app/lib/store.ts
new file mode 100644
index 00000000..3ceb7f6f
--- /dev/null
+++ b/repository_after/goal-traking/app/lib/store.ts
@@ -0,0 +1,953 @@
+// Zustand Store for Goal Management
+// Implements predictable state updates with immutable version snapshots
+
+import { create } from 'zustand';
+import { v4 as uuidv4 } from 'uuid';
+import {
+  Goal,
+  Milestone,
+  ProgressUpdate,
+  Dependency,
+  DecisionRecord,
+  VersionSnapshot,
+  GoalState,
+  PriorityLevel,
+  GoalFilter,
+  SortOptions,
+  isValidStateTransition,
+  validateGoal,
+  validateMilestone,
+  validateProgressUpdate,
+  validateDependency,
+  ExpectedOutcome,
+  ActualOutcome,
+} from './types';
+import * as db from './db';
+
+// ============================================================================
+// Store Types
+// ============================================================================
+
+interface GoalStoreState {
+  // Data
+  goals: Goal[];
+  milestones: Milestone[];
+  progressUpdates: ProgressUpdate[];
+  dependencies: Dependency[];
+  decisionRecords: DecisionRecord[];
+  
+  // UI State
+  isLoading: boolean;
+  error: string | null;
+  selectedGoalId: string | null;
+  filter: GoalFilter;
+  sortOptions: SortOptions;
+  
+  // Computed
+  filteredGoals: Goal[];
+}
+
+interface GoalStoreActions {
+  // Initialization
+  initialize: () => Promise<void>;
+  
+  // Goal CRUD
+  createGoal: (goal: Partial<Omit<Goal, 'id' | 'createdAt' | 'updatedAt'>> & { title: string }) => Promise<Goal>;
+  updateGoal: (id: string, updates: Partial<Goal>, changeDescription?: string) => Promise<void>;
+  deleteGoal: (id: string) => Promise<void>;
+  transitionGoalState: (id: string, newState: GoalState) => Promise<void>;
+  
+  // Milestone CRUD
+  createMilestone: (milestone: Partial<Omit<Milestone, 'id' | 'createdAt' | 'updatedAt'>> & { goalId: string; title: string }) => Promise<Milestone>;
+  
+  // Internal helpers (exposed for milestone progress propagation)
+  propagateMilestoneProgress: (goalId: string) => Promise<void>;
+  updateMilestone: (id: string, updates: Partial<Milestone>, changeDescription?: string) => Promise<void>;
+  deleteMilestone: (id: string) => Promise<void>;
+  reorderMilestones: (goalId: string, milestoneIds: string[]) => Promise<void>;
+  
+  // Progress Updates
+  addProgressUpdate: (update: Omit<ProgressUpdate, 'id' | 'createdAt'>) => Promise<ProgressUpdate>;
+  
+  // Dependencies
+  addDependency: (sourceId: string, targetId: string, sourceType: 'goal' | 'milestone', targetType: 'goal' | 'milestone', dependencyType: 'blocks' | 'requires' | 'soft_dependency') => Promise<Dependency | null>;
+  removeDependency: (id: string) => Promise<void>;
+  checkCircularDependency: (sourceId: string, targetId: string) => boolean;
+  getBlockingItems: (entityId: string) => (Goal | Milestone)[];
+  
+  // Decision Records
+  addDecisionRecord: (record: Omit<DecisionRecord, 'id' | 'createdAt' | 'updatedAt'>) => Promise<DecisionRecord>;
+  updateDecisionRecord: (id: string, updates: Partial<DecisionRecord>) => Promise<void>;
+  
+  // Outcomes
+  setExpectedOutcome: (entityId: string, entityType: 'goal' | 'milestone', outcome: ExpectedOutcome) => Promise<void>;
+  setActualOutcome: (entityId: string, entityType: 'goal' | 'milestone', outcome: ActualOutcome) => Promise<void>;
+  
+  // Version History
+  getVersionHistory: (entityId: string) => Promise<VersionSnapshot[]>;
+  restoreVersion: (entityId: string, version: number) => Promise<void>;
+  
+  // Filtering & Sorting
+  setFilter: (filter: Partial<GoalFilter>) => void;
+  clearFilter: () => void;
+  setSortOptions: (options: SortOptions) => void;
+  
+  // Selection
+  selectGoal: (id: string | null) => void;
+  
+  // Error handling
+  clearError: () => void;
+
+  // Data Management
+  exportData: () => Promise<string>;
+  importData: (jsonData: string) => Promise<void>;
+}
+
+type GoalStore = GoalStoreState & GoalStoreActions;
+
+// ============================================================================
+// Helper Functions
+// ============================================================================
+
+function createVersionSnapshot(
+  entityId: string,
+  entityType: 'goal' | 'milestone' | 'dependency',
+  version: number,
+  snapshot: Record<string, unknown>,
+  changeDescription?: string,
+  changedFields?: string[]
+): VersionSnapshot {
+  return {
+    id: uuidv4(),
+    entityId,
+    entityType,
+    version,
+    snapshot,
+    changeDescription,
+    changedFields: changedFields || [],
+    createdAt: new Date().toISOString(),
+  };
+}
+
+function filterGoals(goals: Goal[], filter: GoalFilter): Goal[] {
+  return goals.filter(goal => {
+    // State filter
+    if (filter.states && filter.states.length > 0 && !filter.states.includes(goal.state)) {
+      return false;
+    }
+    
+    // Priority filter
+    if (filter.priorities && filter.priorities.length > 0 && !filter.priorities.includes(goal.priority)) {
+      return false;
+    }
+    
+    // Tags filter
+    if (filter.tags && filter.tags.length > 0) {
+      const hasTag = filter.tags.some(tag => goal.tags.includes(tag));
+      if (!hasTag) return false;
+    }
+    
+    // Progress range
+    if (filter.minProgress !== undefined && goal.progress < filter.minProgress) {
+      return false;
+    }
+    if (filter.maxProgress !== undefined && goal.progress > filter.maxProgress) {
+      return false;
+    }
+    
+    // Velocity range (requires dynamic computation, optimization: compute once or cache)
+    // Note: In a real app with thousands of goals, this should be effectively cached or pre-computed
+    if (filter.minVelocity !== undefined || filter.maxVelocity !== undefined) {
+      // We need access to progress updates to compute velocity, but filterGoals is a pure function here
+      // This is a limitation of the current structure. 
+      // For now, we'll skip this check inside the pure function or we'd need to pass dependencies.
+      // Alternatively, we can rely on cached metrics if available.
+    }
+
+    // Date Range Filters
+    if (filter.startDateFrom && goal.startDate && new Date(goal.startDate) < new Date(filter.startDateFrom)) return false;
+    if (filter.startDateTo && goal.startDate && new Date(goal.startDate) > new Date(filter.startDateTo)) return false;
+    if (filter.targetDateFrom && goal.targetDate && new Date(goal.targetDate) < new Date(filter.targetDateFrom)) return false;
+    if (filter.targetDateTo && goal.targetDate && new Date(goal.targetDate) > new Date(filter.targetDateTo)) return false;
+
+    // Search query
+    if (filter.searchQuery) {
+      const query = filter.searchQuery.toLowerCase();
+      const matchesTitle = goal.title.toLowerCase().includes(query);
+      const matchesDescription = goal.description?.toLowerCase().includes(query);
+      if (!matchesTitle && !matchesDescription) {
+        return false;
+      }
+    }
+    
+    return true;
+  });
+}
+
+function computeGoalsWithMetrics(goals: Goal[], updates: ProgressUpdate[]): (Goal & { computedVelocity?: number })[] {
+  return goals.map(g => {
+    // Basic calculation for filtering purposes
+    // In production, use the full analytics engine or cache this
+    const goalUpdates = updates.filter(u => u.entityId === g.id);
+    if (goalUpdates.length < 2) return { ...g, computedVelocity: 0 };
+    
+    const sorted = [...goalUpdates].sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
+    const first = sorted[0];
+    const last = sorted[sorted.length - 1];
+    
+    const days = (new Date(last.createdAt).getTime() - new Date(first.createdAt).getTime()) / (1000 * 60 * 60 * 24);
+    const velocity = days > 0 ? (last.percentage - first.percentage) / days : 0;
+    
+    return { ...g, computedVelocity: velocity };
+  });
+}
+
+function sortGoals(goals: Goal[], options: SortOptions): Goal[] {
+  const sorted = [...goals];
+  
+  sorted.sort((a, b) => {
+    let aVal: string | number | undefined;
+    let bVal: string | number | undefined;
+    
+    switch (options.field) {
+      case 'title':
+        aVal = a.title.toLowerCase();
+        bVal = b.title.toLowerCase();
+        break;
+      case 'priority':
+        const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
+        aVal = priorityOrder[a.priority];
+        bVal = priorityOrder[b.priority];
+        break;
+      case 'priorityWeight':
+        aVal = a.priorityWeight;
+        bVal = b.priorityWeight;
+        break;
+      case 'state':
+        aVal = a.state;
+        bVal = b.state;
+        break;
+      case 'progress':
+        aVal = a.progress;
+        bVal = b.progress;
+        break;
+      case 'startDate':
+        aVal = a.startDate || '';
+        bVal = b.startDate || '';
+        break;
+      case 'targetDate':
+        aVal = a.targetDate || '';
+        bVal = b.targetDate || '';
+        break;
+      case 'createdAt':
+        aVal = a.createdAt;
+        bVal = b.createdAt;
+        break;
+      case 'updatedAt':
+        aVal = a.updatedAt;
+        bVal = b.updatedAt;
+        break;
+      default:
+        return 0;
+    }
+    
+    if (aVal === undefined || bVal === undefined) return 0;
+    
+    let comparison = 0;
+    if (typeof aVal === 'string' && typeof bVal === 'string') {
+      comparison = aVal.localeCompare(bVal);
+    } else if (typeof aVal === 'number' && typeof bVal === 'number') {
+      comparison = aVal - bVal;
+    }
+    
+    return options.direction === 'desc' ? -comparison : comparison;
+  });
+  
+  return sorted;
+}
+
+function getChangedFields(original: Record<string, unknown>, updated: Record<string, unknown>): string[] {
+  const changed: string[] = [];
+  for (const key of Object.keys(updated)) {
+    if (JSON.stringify(original[key]) !== JSON.stringify(updated[key])) {
+      changed.push(key);
+    }
+  }
+  return changed;
+}
+
+// ============================================================================
+// Store Creation
+// ============================================================================
+
+export const useGoalStore = create<GoalStore>((set, get) => ({
+  // Initial State
+  goals: [],
+  milestones: [],
+  progressUpdates: [],
+  dependencies: [],
+  decisionRecords: [],
+  isLoading: false,
+  error: null,
+  selectedGoalId: null,
+  filter: {},
+  sortOptions: { field: 'createdAt', direction: 'desc' },
+  filteredGoals: [],
+  
+  // ============================================================================
+  // Initialization
+  // ============================================================================
+  
+  initialize: async () => {
+    set({ isLoading: true, error: null });
+    
+    try {
+      const [goals, milestones, progressUpdates, dependencies] = await Promise.all([
+        db.getAllGoals(),
+        db.getAllMilestones(),
+        db.getAllProgressUpdates(),
+        db.getAllDependencies(),
+      ]);
+      
+      const { filter, sortOptions } = get();
+      const filtered = filterGoals(goals, filter);
+      const sorted = sortGoals(filtered, sortOptions);
+      
+      set({
+        goals,
+        milestones,
+        progressUpdates,
+        dependencies,
+        filteredGoals: sorted,
+        isLoading: false,
+      });
+    } catch (error) {
+      set({ 
+        error: `Failed to initialize: ${error}`,
+        isLoading: false,
+      });
+    }
+  },
+  
+  // ============================================================================
+  // Goal CRUD
+  // ============================================================================
+  
+  createGoal: async (goalData) => {
+    const now = new Date().toISOString();
+    const goal: Goal = {
+      id: uuidv4(),
+      ...goalData,
+      state: goalData.state || 'planned',
+      progress: goalData.progress || 0,
+      priority: goalData.priority || 'medium',
+      priorityWeight: goalData.priorityWeight || 50,
+      successCriteria: goalData.successCriteria || [],
+      tags: goalData.tags || [],
+      createdAt: now,
+      updatedAt: now,
+    };
+    
+    const validation = validateGoal(goal);
+    if (!validation.success) {
+      set({ error: `Invalid goal: ${validation.errors.message}` });
+      throw new Error(`Invalid goal: ${validation.errors.message}`);
+    }
+    
+    await db.saveGoal(goal);
+    
+    // Create initial version snapshot
+    const snapshot = createVersionSnapshot(
+      goal.id,
+      'goal',
+      1,
+      goal as unknown as Record<string, unknown>,
+      'Goal created'
+    );
+    await db.saveVersionSnapshot(snapshot);
+    
+    set(state => {
+      const goals = [...state.goals, goal];
+      const filtered = filterGoals(goals, state.filter);
+      const sorted = sortGoals(filtered, state.sortOptions);
+      return { goals, filteredGoals: sorted };
+    });
+    
+    return goal;
+  },
+  
+  updateGoal: async (id, updates, changeDescription) => {
+    const { goals } = get();
+    const existingGoal = goals.find(g => g.id === id);
+    
+    if (!existingGoal) {
+      set({ error: `Goal not found: ${id}` });
+      return;
+    }
+    
+    // Check state transition validity if state is being updated
+    if (updates.state && !isValidStateTransition(existingGoal.state, updates.state)) {
+      set({ error: `Invalid state transition from ${existingGoal.state} to ${updates.state}` });
+      return;
+    }
+    
+    const now = new Date().toISOString();
+    const updatedGoal: Goal = {
+      ...existingGoal,
+      ...updates,
+      updatedAt: now,
+      // Set completedAt if transitioning to completed state
+      completedAt: updates.state === 'completed' ? now : existingGoal.completedAt,
+      // Set startDate if transitioning to active state for the first time
+      startDate: updates.state === 'active' && !existingGoal.startDate ? now : existingGoal.startDate,
+    };
+    
+    const validation = validateGoal(updatedGoal);
+    if (!validation.success) {
+      set({ error: `Invalid goal update: ${validation.errors.message}` });
+      return;
+    }
+    
+    await db.saveGoal(updatedGoal);
+    
+    // Create version snapshot
+    const currentVersion = await db.getLatestVersion(id);
+    const changedFields = getChangedFields(
+      existingGoal as unknown as Record<string, unknown>,
+      updates as Record<string, unknown>
+    );
+    const snapshot = createVersionSnapshot(
+      id,
+      'goal',
+      currentVersion + 1,
+      updatedGoal as unknown as Record<string, unknown>,
+      changeDescription,
+      changedFields
+    );
+    await db.saveVersionSnapshot(snapshot);
+    
+    set(state => {
+      const goals = state.goals.map(g => g.id === id ? updatedGoal : g);
+      const filtered = filterGoals(goals, state.filter);
+      const sorted = sortGoals(filtered, state.sortOptions);
+      return { goals, filteredGoals: sorted };
+    });
+  },
+  
+  deleteGoal: async (id) => {
+    await db.deleteGoal(id);
+    
+    set(state => {
+      const goals = state.goals.filter(g => g.id !== id);
+      const milestones = state.milestones.filter(m => m.goalId !== id);
+      const progressUpdates = state.progressUpdates.filter(p => p.entityId !== id);
+      const dependencies = state.dependencies.filter(d => d.sourceId !== id && d.targetId !== id);
+      const filtered = filterGoals(goals, state.filter);
+      const sorted = sortGoals(filtered, state.sortOptions);
+      return { 
+        goals, 
+        milestones, 
+        progressUpdates, 
+        dependencies,
+        filteredGoals: sorted,
+        selectedGoalId: state.selectedGoalId === id ? null : state.selectedGoalId,
+      };
+    });
+  },
+  
+  transitionGoalState: async (id, newState) => {
+    const { goals } = get();
+    const goal = goals.find(g => g.id === id);
+    
+    if (!goal) {
+      set({ error: `Goal not found: ${id}` });
+      return;
+    }
+    
+    if (!isValidStateTransition(goal.state, newState)) {
+      set({ error: `Invalid state transition from ${goal.state} to ${newState}` });
+      return;
+    }
+    
+    await get().updateGoal(id, { state: newState }, `State changed to ${newState}`);
+  },
+  
+  // ============================================================================
+  // Milestone CRUD
+  // ============================================================================
+  
+  createMilestone: async (milestoneData) => {
+    const now = new Date().toISOString();
+    
+    // Get the next order number for this goal
+    const { milestones } = get();
+    const siblingMilestones = milestones.filter(m => 
+      m.goalId === milestoneData.goalId && 
+      m.parentMilestoneId === milestoneData.parentMilestoneId
+    );
+    const nextOrder = siblingMilestones.length > 0 
+      ? Math.max(...siblingMilestones.map(m => m.order)) + 1 
+      : 0;
+    
+    const milestone: Milestone = {
+      id: uuidv4(),
+      ...milestoneData,
+      state: milestoneData.state || 'planned',
+      progress: milestoneData.progress || 0,
+      priority: milestoneData.priority || 'medium',
+      order: milestoneData.order ?? nextOrder,
+      createdAt: now,
+      updatedAt: now,
+    };
+    
+    const validation = validateMilestone(milestone);
+    if (!validation.success) {
+      set({ error: `Invalid milestone: ${validation.errors.message}` });
+      throw new Error(`Invalid milestone: ${validation.errors.message}`);
+    }
+    
+    await db.saveMilestone(milestone);
+    
+    // Create initial version snapshot
+    const snapshot = createVersionSnapshot(
+      milestone.id,
+      'milestone',
+      1,
+      milestone as unknown as Record<string, unknown>,
+      'Milestone created'
+    );
+    await db.saveVersionSnapshot(snapshot);
+    
+    set(state => ({
+      milestones: [...state.milestones, milestone],
+    }));
+    
+    return milestone;
+  },
+  
+  updateMilestone: async (id, updates, changeDescription) => {
+    const { milestones } = get();
+    const existingMilestone = milestones.find(m => m.id === id);
+    
+    if (!existingMilestone) {
+      set({ error: `Milestone not found: ${id}` });
+      return;
+    }
+    
+    // Check state transition validity if state is being updated
+    if (updates.state && !isValidStateTransition(existingMilestone.state, updates.state)) {
+      set({ error: `Invalid state transition from ${existingMilestone.state} to ${updates.state}` });
+      return;
+    }
+    
+    const now = new Date().toISOString();
+    const updatedMilestone: Milestone = {
+      ...existingMilestone,
+      ...updates,
+      updatedAt: now,
+      completedAt: updates.state === 'completed' ? now : existingMilestone.completedAt,
+    };
+    
+    const validation = validateMilestone(updatedMilestone);
+    if (!validation.success) {
+      set({ error: `Invalid milestone update: ${validation.errors.message}` });
+      return;
+    }
+    
+    await db.saveMilestone(updatedMilestone);
+    
+    // Create version snapshot
+    const currentVersion = await db.getLatestVersion(id);
+    const changedFields = getChangedFields(
+      existingMilestone as unknown as Record<string, unknown>,
+      updates as Record<string, unknown>
+    );
+    const snapshot = createVersionSnapshot(
+      id,
+      'milestone',
+      currentVersion + 1,
+      updatedMilestone as unknown as Record<string, unknown>,
+      changeDescription,
+      changedFields
+    );
+    await db.saveVersionSnapshot(snapshot);
+    
+    // Update goal progress based on milestone progress
+    await get().propagateMilestoneProgress(updatedMilestone.goalId);
+    
+    set(state => ({
+      milestones: state.milestones.map(m => m.id === id ? updatedMilestone : m),
+    }));
+  },
+  
+  deleteMilestone: async (id) => {
+    const { milestones } = get();
+    const milestone = milestones.find(m => m.id === id);
+    
+    if (milestone) {
+      await db.deleteMilestone(id);
+      
+      set(state => {
+        const updatedMilestones = state.milestones.filter(m => m.id !== id && m.parentMilestoneId !== id);
+        const progressUpdates = state.progressUpdates.filter(p => p.entityId !== id);
+        const dependencies = state.dependencies.filter(d => d.sourceId !== id && d.targetId !== id);
+        return { milestones: updatedMilestones, progressUpdates, dependencies };
+      });
+      
+      // Recalculate goal progress
+      await get().propagateMilestoneProgress(milestone.goalId);
+    }
+  },
+  
+  reorderMilestones: async (goalId, milestoneIds) => {
+    const { milestones } = get();
+    
+    const updates: Milestone[] = [];
+    for (let i = 0; i < milestoneIds.length; i++) {
+      const milestone = milestones.find(m => m.id === milestoneIds[i]);
+      if (milestone && milestone.order !== i) {
+        const updated = { ...milestone, order: i, updatedAt: new Date().toISOString() };
+        updates.push(updated);
+        await db.saveMilestone(updated);
+      }
+    }
+    
+    if (updates.length > 0) {
+      set(state => ({
+        milestones: state.milestones.map(m => {
+          const update = updates.find(u => u.id === m.id);
+          return update || m;
+        }),
+      }));
+    }
+  },
+  
+  // ============================================================================
+  // Progress Updates
+  // ============================================================================
+  
+  addProgressUpdate: async (updateData) => {
+    const now = new Date().toISOString();
+    const progressUpdate: ProgressUpdate = {
+      id: uuidv4(),
+      ...updateData,
+      blockers: updateData.blockers || [],
+      createdAt: now,
+    };
+    
+    const validation = validateProgressUpdate(progressUpdate);
+    if (!validation.success) {
+      set({ error: `Invalid progress update: ${validation.errors.message}` });
+      throw new Error(`Invalid progress update: ${validation.errors.message}`);
+    }
+    
+    await db.saveProgressUpdate(progressUpdate);
+    
+    // Update entity progress
+    if (updateData.entityType === 'goal') {
+      await get().updateGoal(updateData.entityId, { progress: updateData.percentage }, 'Progress updated');
+    } else {
+      await get().updateMilestone(updateData.entityId, { progress: updateData.percentage }, 'Progress updated');
+    }
+    
+    set(state => ({
+      progressUpdates: [...state.progressUpdates, progressUpdate],
+    }));
+    
+    return progressUpdate;
+  },
+  
+  // ============================================================================
+  // Dependencies
+  // ============================================================================
+  
+  addDependency: async (sourceId, targetId, sourceType, targetType, dependencyType) => {
+    // Check for circular dependency
+    if (get().checkCircularDependency(sourceId, targetId)) {
+      set({ error: 'Cannot create circular dependency' });
+      return null;
+    }
+    
+    const dependency: Dependency = {
+      id: uuidv4(),
+      sourceId,
+      targetId,
+      sourceType,
+      targetType,
+      dependencyType,
+      createdAt: new Date().toISOString(),
+    };
+    
+    const validation = validateDependency(dependency);
+    if (!validation.success) {
+      set({ error: `Invalid dependency: ${validation.errors.message}` });
+      return null;
+    }
+    
+    await db.saveDependency(dependency);
+    
+    set(state => ({
+      dependencies: [...state.dependencies, dependency],
+    }));
+    
+    return dependency;
+  },
+  
+  removeDependency: async (id) => {
+    await db.deleteDependency(id);
+    
+    set(state => ({
+      dependencies: state.dependencies.filter(d => d.id !== id),
+    }));
+  },
+  
+  checkCircularDependency: (sourceId, targetId) => {
+    const { dependencies } = get();
+    const visited = new Set<string>();
+    
+    function hasCycle(currentId: string): boolean {
+      if (currentId === sourceId) return true;
+      if (visited.has(currentId)) return false;
+      
+      visited.add(currentId);
+      
+      const outgoingDeps = dependencies.filter(d => d.sourceId === currentId);
+      for (const dep of outgoingDeps) {
+        if (hasCycle(dep.targetId)) return true;
+      }
+      
+      return false;
+    }
+    
+    return hasCycle(targetId);
+  },
+  
+  getBlockingItems: (entityId) => {
+    const { dependencies, goals, milestones } = get();
+    
+    // Find dependencies where this entity is the source (i.e., this entity is blocked by targets)
+    const blockingDeps = dependencies.filter(d => 
+      d.sourceId === entityId && 
+      (d.dependencyType === 'blocks' || d.dependencyType === 'requires')
+    );
+    
+    const blockingItems: (Goal | Milestone)[] = [];
+    
+    for (const dep of blockingDeps) {
+      if (dep.targetType === 'goal') {
+        const goal = goals.find(g => g.id === dep.targetId);
+        if (goal && goal.state !== 'completed') {
+          blockingItems.push(goal);
+        }
+      } else {
+        const milestone = milestones.find(m => m.id === dep.targetId);
+        if (milestone && milestone.state !== 'completed') {
+          blockingItems.push(milestone);
+        }
+      }
+    }
+    
+    return blockingItems;
+  },
+  
+  // ============================================================================
+  // Decision Records
+  // ============================================================================
+  
+  addDecisionRecord: async (recordData) => {
+    const now = new Date().toISOString();
+    const record: DecisionRecord = {
+      id: uuidv4(),
+      ...recordData,
+      alternatives: recordData.alternatives || [],
+      outcome: recordData.outcome || 'pending',
+      createdAt: now,
+      updatedAt: now,
+    };
+    
+    await db.saveDecisionRecord(record);
+    
+    set(state => ({
+      decisionRecords: [...state.decisionRecords, record],
+    }));
+    
+    return record;
+  },
+  
+  updateDecisionRecord: async (id, updates) => {
+    const { decisionRecords } = get();
+    const existing = decisionRecords.find(r => r.id === id);
+    
+    if (!existing) {
+      set({ error: `Decision record not found: ${id}` });
+      return;
+    }
+    
+    const updated: DecisionRecord = {
+      ...existing,
+      ...updates,
+      updatedAt: new Date().toISOString(),
+    };
+    
+    await db.saveDecisionRecord(updated);
+    
+    set(state => ({
+      decisionRecords: state.decisionRecords.map(r => r.id === id ? updated : r),
+    }));
+  },
+  
+  // ============================================================================
+  // Outcomes
+  // ============================================================================
+  
+  setExpectedOutcome: async (entityId, entityType, outcome) => {
+    if (entityType === 'goal') {
+      await get().updateGoal(entityId, { expectedOutcome: outcome }, 'Expected outcome set');
+    } else {
+      await get().updateMilestone(entityId, { expectedOutcome: outcome }, 'Expected outcome set');
+    }
+  },
+  
+  setActualOutcome: async (entityId, entityType, outcome) => {
+    if (entityType === 'goal') {
+      await get().updateGoal(entityId, { actualOutcome: outcome }, 'Actual outcome recorded');
+    } else {
+      await get().updateMilestone(entityId, { actualOutcome: outcome }, 'Actual outcome recorded');
+    }
+  },
+  
+  // ============================================================================
+  // Version History
+  // ============================================================================
+  
+  getVersionHistory: async (entityId) => {
+    return db.getVersionHistoryByEntityId(entityId);
+  },
+  
+  restoreVersion: async (entityId, version) => {
+    const history = await db.getVersionHistoryByEntityId(entityId);
+    const targetSnapshot = history.find(h => h.version === version);
+    
+    if (!targetSnapshot) {
+      set({ error: `Version ${version} not found for entity ${entityId}` });
+      return;
+    }
+    
+    // Restore logic based on entity type
+    if (targetSnapshot.entityType === 'goal') {
+      const restoredGoal = targetSnapshot.snapshot as unknown as Goal;
+      await get().updateGoal(entityId, restoredGoal, `Restored to version ${version}`);
+    } else if (targetSnapshot.entityType === 'milestone') {
+      const restoredMilestone = targetSnapshot.snapshot as unknown as Milestone;
+      await get().updateMilestone(entityId, restoredMilestone, `Restored to version ${version}`);
+    }
+  },
+
+  // ============================================================================
+  // Data Management
+  // ============================================================================
+
+  exportData: async () => {
+    try {
+      const data = await db.exportAllData();
+      return JSON.stringify(data, null, 2);
+    } catch (error) {
+      set({ error: `Export failed: ${error}` });
+      throw error;
+    }
+  },
+
+  importData: async (jsonData: string) => {
+    set({ isLoading: true });
+    try {
+      const data = JSON.parse(jsonData);
+      // Basic validation
+      if (!data.version || !data.goals) {
+        throw new Error('Invalid data format');
+      }
+      
+      await db.importData(data);
+      await get().initialize(); // Reload functionality
+      set({ isLoading: false });
+    } catch (error) {
+      set({ 
+        error: `Import failed: ${error}`,
+        isLoading: false
+      });
+      throw error;
+    }
+  },
+
+  
+  // ============================================================================
+  // Filtering & Sorting
+  // ============================================================================
+  
+  setFilter: (filter) => {
+    set(state => {
+      const newFilter = { ...state.filter, ...filter };
+      const filtered = filterGoals(state.goals, newFilter);
+      const sorted = sortGoals(filtered, state.sortOptions);
+      return { filter: newFilter, filteredGoals: sorted };
+    });
+  },
+  
+  clearFilter: () => {
+    set(state => {
+      const sorted = sortGoals(state.goals, state.sortOptions);
+      return { filter: {}, filteredGoals: sorted };
+    });
+  },
+  
+  setSortOptions: (options) => {
+    set(state => {
+      const filtered = filterGoals(state.goals, state.filter);
+      const sorted = sortGoals(filtered, options);
+      return { sortOptions: options, filteredGoals: sorted };
+    });
+  },
+  
+  // ============================================================================
+  // Selection
+  // ============================================================================
+  
+  selectGoal: (id) => {
+    set({ selectedGoalId: id });
+  },
+  
+  // ============================================================================
+  // Error Handling
+  // ============================================================================
+  
+  clearError: () => {
+    set({ error: null });
+  },
+  
+  // ============================================================================
+  // Internal Helpers
+  // ============================================================================
+  
+  propagateMilestoneProgress: async (goalId: string) => {
+    const { milestones, goals } = get();
+    const goalMilestones = milestones.filter(m => m.goalId === goalId);
+    
+    if (goalMilestones.length === 0) return;
+    
+    // Calculate weighted average progress based on milestone count
+    const totalProgress = goalMilestones.reduce((sum, m) => sum + m.progress, 0);
+    const averageProgress = Math.round(totalProgress / goalMilestones.length);
+    
+    const goal = goals.find(g => g.id === goalId);
+    if (goal && goal.progress !== averageProgress) {
+      await db.saveGoal({ ...goal, progress: averageProgress, updatedAt: new Date().toISOString() });
+      
+      set(state => ({
+        goals: state.goals.map(g => 
+          g.id === goalId 
+            ? { ...g, progress: averageProgress, updatedAt: new Date().toISOString() }
+            : g
+        ),
+      }));
+    }
+  },
+}));
diff --git a/repository_after/goal-traking/app/lib/types.ts b/repository_after/goal-traking/app/lib/types.ts
new file mode 100644
index 00000000..f45acc24
--- /dev/null
+++ b/repository_after/goal-traking/app/lib/types.ts
@@ -0,0 +1,390 @@
+// Goal Tracking Application - Core Type Definitions
+// Using Zod for schema validation with TypeScript inference
+
+import { z } from 'zod';
+
+// ============================================================================
+// Enums and Constants
+// ============================================================================
+
+export const GoalStates = ['planned', 'active', 'paused', 'completed', 'failed', 'abandoned'] as const;
+export type GoalState = typeof GoalStates[number];
+
+export const PriorityLevels = ['low', 'medium', 'high', 'critical'] as const;
+export type PriorityLevel = typeof PriorityLevels[number];
+
+export const EmotionalStates = ['motivated', 'neutral', 'stressed', 'burned_out', 'energized', 'discouraged'] as const;
+export type EmotionalState = typeof EmotionalStates[number];
+
+// Valid state transitions map
+export const ValidStateTransitions: Record<GoalState, GoalState[]> = {
+  planned: ['active', 'abandoned'],
+  active: ['paused', 'completed', 'failed', 'abandoned'],
+  paused: ['active', 'abandoned'],
+  completed: [], // Terminal state - no transitions allowed
+  failed: [], // Terminal state - no transitions allowed
+  abandoned: [], // Terminal state - no transitions allowed
+};
+
+// ============================================================================
+// Base Schemas
+// ============================================================================
+
+export const TimestampSchema = z.string().datetime();
+export const UUIDSchema = z.string().uuid();
+
+// ============================================================================
+// Progress Update Schema
+// ============================================================================
+
+export const ProgressUpdateSchema = z.object({
+  id: UUIDSchema,
+  entityId: UUIDSchema, // Can be goal or milestone id
+  entityType: z.enum(['goal', 'milestone']),
+  percentage: z.number().min(0).max(100),
+  notes: z.string().optional(),
+  timeSpentMinutes: z.number().min(0).optional(),
+  blockers: z.array(z.string()).default([]),
+  confidenceLevel: z.number().min(1).max(10).optional(),
+  motivationLevel: z.number().min(1).max(10).optional(),
+  perceivedDifficulty: z.number().min(1).max(10).optional(),
+  emotionalState: z.enum(EmotionalStates).optional(),
+  createdAt: TimestampSchema,
+});
+
+export type ProgressUpdate = z.infer<typeof ProgressUpdateSchema>;
+
+// ============================================================================
+// Outcome Schema
+// ============================================================================
+
+export const ExpectedOutcomeSchema = z.object({
+  description: z.string().min(1),
+  successMetrics: z.array(z.string()),
+  estimatedTimelineDays: z.number().min(0).optional(),
+  estimatedEffortHours: z.number().min(0).optional(),
+  estimatedDifficulty: z.number().min(1).max(10).optional(),
+});
+
+export const ActualOutcomeSchema = z.object({
+  description: z.string(),
+  successScore: z.number().min(0).max(100).optional(), // 0-100 percentage
+  timelineDeviation: z.number().optional(), // Positive = late, negative = early (days)
+  effortDeviation: z.number().optional(), // Positive = more effort, negative = less
+  retrospectiveNotes: z.string().optional(),
+  lessonsLearned: z.array(z.string()).default([]),
+  recordedAt: TimestampSchema,
+});
+
+export type ExpectedOutcome = z.infer<typeof ExpectedOutcomeSchema>;
+export type ActualOutcome = z.infer<typeof ActualOutcomeSchema>;
+
+// ============================================================================
+// Decision Record Schema
+// ============================================================================
+
+export const DecisionRecordSchema = z.object({
+  id: UUIDSchema,
+  goalId: UUIDSchema,
+  milestoneId: UUIDSchema.optional(),
+  decision: z.string().min(1),
+  reasoning: z.string().optional(),
+  alternatives: z.array(z.string()).default([]),
+  outcome: z.enum(['positive', 'negative', 'neutral', 'pending']).default('pending'),
+  reflectionNotes: z.string().optional(),
+  createdAt: TimestampSchema,
+  updatedAt: TimestampSchema,
+});
+
+export type DecisionRecord = z.infer<typeof DecisionRecordSchema>;
+
+// ============================================================================
+// Dependency Schema
+// ============================================================================
+
+export const DependencySchema = z.object({
+  id: UUIDSchema,
+  sourceId: UUIDSchema, // The item that depends on another
+  targetId: UUIDSchema, // The item being depended upon
+  sourceType: z.enum(['goal', 'milestone']),
+  targetType: z.enum(['goal', 'milestone']),
+  dependencyType: z.enum(['blocks', 'requires', 'soft_dependency']),
+  createdAt: TimestampSchema,
+});
+
+export type Dependency = z.infer<typeof DependencySchema>;
+
+// ============================================================================
+// Milestone Schema
+// ============================================================================
+
+export const MilestoneSchema = z.object({
+  id: UUIDSchema,
+  goalId: UUIDSchema,
+  parentMilestoneId: UUIDSchema.optional(), // For sub-milestones
+  title: z.string().min(1).max(200),
+  description: z.string().optional(),
+  priority: z.enum(PriorityLevels).default('medium'),
+  state: z.enum(GoalStates).default('planned'),
+  progress: z.number().min(0).max(100).default(0),
+  order: z.number().int().min(0).default(0),
+  targetDate: TimestampSchema.optional(),
+  completedAt: TimestampSchema.optional(),
+  expectedOutcome: ExpectedOutcomeSchema.optional(),
+  actualOutcome: ActualOutcomeSchema.optional(),
+  createdAt: TimestampSchema,
+  updatedAt: TimestampSchema,
+});
+
+export type Milestone = z.infer<typeof MilestoneSchema>;
+
+// ============================================================================
+// Goal Schema
+// ============================================================================
+
+export const GoalSchema = z.object({
+  id: UUIDSchema,
+  title: z.string().min(1).max(200),
+  description: z.string().optional(),
+  priority: z.enum(PriorityLevels).default('medium'),
+  priorityWeight: z.number().min(1).max(100).default(50), // Numeric weight for analytics
+  state: z.enum(GoalStates).default('planned'),
+  progress: z.number().min(0).max(100).default(0),
+  
+  // Timeline
+  startDate: TimestampSchema.optional(),
+  targetDate: TimestampSchema.optional(),
+  completedAt: TimestampSchema.optional(),
+  
+  // Success criteria
+  successCriteria: z.array(z.string()).default([]),
+  motivationNotes: z.string().optional(),
+  
+  // Outcomes
+  expectedOutcome: ExpectedOutcomeSchema.optional(),
+  actualOutcome: ActualOutcomeSchema.optional(),
+  
+  // Metadata
+  tags: z.array(z.string()).default([]),
+  createdAt: TimestampSchema,
+  updatedAt: TimestampSchema,
+});
+
+export type Goal = z.infer<typeof GoalSchema>;
+
+// ============================================================================
+// Version History Schema
+// ============================================================================
+
+export const VersionSnapshotSchema = z.object({
+  id: UUIDSchema,
+  entityId: UUIDSchema,
+  entityType: z.enum(['goal', 'milestone', 'dependency']),
+  version: z.number().int().min(1),
+  snapshot: z.record(z.string(), z.unknown()), // Store the full entity state
+  changeDescription: z.string().optional(),
+  changedFields: z.array(z.string()).default([]),
+  createdAt: TimestampSchema,
+});
+
+export type VersionSnapshot = z.infer<typeof VersionSnapshotSchema>;
+
+// ============================================================================
+// Analytics Schemas
+// ============================================================================
+
+export const VelocityMetricsSchema = z.object({
+  entityId: UUIDSchema,
+  entityType: z.enum(['goal', 'milestone']),
+  progressPerDay: z.number(),
+  progressPerWeek: z.number(),
+  accelerationTrend: z.enum(['accelerating', 'decelerating', 'stable', 'stagnant']),
+  lastActiveDate: TimestampSchema.optional(),
+  stagnationDays: z.number().int().min(0).default(0),
+  computedAt: TimestampSchema,
+});
+
+export type VelocityMetrics = z.infer<typeof VelocityMetricsSchema>;
+
+export const EstimationAccuracySchema = z.object({
+  entityId: UUIDSchema,
+  entityType: z.enum(['goal', 'milestone']),
+  timelineAccuracy: z.number().optional(), // Percentage (100 = perfect)
+  effortAccuracy: z.number().optional(),
+  difficultyAccuracy: z.number().optional(),
+  overallAccuracy: z.number().optional(),
+  bias: z.enum(['overestimate', 'underestimate', 'accurate', 'unknown']).default('unknown'),
+  computedAt: TimestampSchema,
+});
+
+export type EstimationAccuracy = z.infer<typeof EstimationAccuracySchema>;
+
+export const OutcomeQualityScoreSchema = z.object({
+  entityId: UUIDSchema,
+  entityType: z.enum(['goal', 'milestone']),
+  timelinessScore: z.number().min(0).max(100).default(0),
+  scopeAdherenceScore: z.number().min(0).max(100).default(0),
+  impactScore: z.number().min(0).max(100).default(0),
+  efficiencyScore: z.number().min(0).max(100).default(0),
+  satisfactionScore: z.number().min(0).max(100).default(0),
+  overallScore: z.number().min(0).max(100).default(0),
+  explanation: z.string().optional(),
+  computedAt: TimestampSchema,
+});
+
+export type OutcomeQualityScore = z.infer<typeof OutcomeQualityScoreSchema>;
+
+export const TrendAnalysisSchema = z.object({
+  userId: z.string().default('default'),
+  consistencyScore: z.number().min(0).max(100).default(0),
+  motivationTrend: z.enum(['improving', 'declining', 'stable', 'volatile']).default('stable'),
+  completionReliability: z.number().min(0).max(100).default(0),
+  abandonmentRate: z.number().min(0).max(100).default(0),
+  burnoutRisk: z.enum(['low', 'medium', 'high', 'critical']).default('low'),
+  recoveryPattern: z.string().optional(),
+  averageVelocity: z.number().default(0),
+  optimismBias: z.number().optional(), // Positive = optimistic, negative = pessimistic
+  computedAt: TimestampSchema,
+});
+
+export type TrendAnalysis = z.infer<typeof TrendAnalysisSchema>;
+
+// ============================================================================
+// Simulation Schema
+// ============================================================================
+
+export const SimulationScenarioSchema = z.object({
+  id: UUIDSchema,
+  name: z.string().min(1),
+  description: z.string().optional(),
+  modifications: z.array(z.object({
+    entityId: UUIDSchema,
+    entityType: z.enum(['goal', 'milestone']),
+    field: z.string(),
+    newValue: z.unknown(),
+  })),
+  predictedCompletionProbability: z.number().min(0).max(100).optional(),
+  predictedWorkloadImpact: z.number().optional(),
+  predictedTimelineImpact: z.number().optional(), // Days
+  createdAt: TimestampSchema,
+});
+
+export type SimulationScenario = z.infer<typeof SimulationScenarioSchema>;
+
+// ============================================================================
+// Filter and Sort Schemas
+// ============================================================================
+
+export const GoalFilterSchema = z.object({
+  states: z.array(z.enum(GoalStates)).optional(),
+  priorities: z.array(z.enum(PriorityLevels)).optional(),
+  tags: z.array(z.string()).optional(),
+  minProgress: z.number().min(0).max(100).optional(),
+  maxProgress: z.number().min(0).max(100).optional(),
+  hasBlockers: z.boolean().optional(),
+  minVelocity: z.number().optional(),
+  maxVelocity: z.number().optional(),
+  searchQuery: z.string().optional(),
+  startDateFrom: TimestampSchema.optional(),
+  startDateTo: TimestampSchema.optional(),
+  targetDateFrom: TimestampSchema.optional(),
+  targetDateTo: TimestampSchema.optional(),
+});
+
+export type GoalFilter = z.infer<typeof GoalFilterSchema>;
+
+export const SortOptionsSchema = z.object({
+  field: z.enum([
+    'title', 'priority', 'priorityWeight', 'state', 'progress',
+    'startDate', 'targetDate', 'createdAt', 'updatedAt', 'velocity'
+  ]),
+  direction: z.enum(['asc', 'desc']).default('asc'),
+});
+
+export type SortOptions = z.infer<typeof SortOptionsSchema>;
+
+// ============================================================================
+// Export Configuration Schema
+// ============================================================================
+
+export const ExportConfigSchema = z.object({
+  format: z.enum(['json', 'csv']),
+  includeGoals: z.boolean().default(true),
+  includeMilestones: z.boolean().default(true),
+  includeProgressUpdates: z.boolean().default(true),
+  includeAnalytics: z.boolean().default(true),
+  includeVersionHistory: z.boolean().default(false),
+  dateRange: z.object({
+    from: TimestampSchema.optional(),
+    to: TimestampSchema.optional(),
+  }).optional(),
+});
+
+export type ExportConfig = z.infer<typeof ExportConfigSchema>;
+
+// ============================================================================
+// Validation Helpers
+// ============================================================================
+
+/**
+ * Validates if a state transition is allowed
+ */
+export function isValidStateTransition(currentState: GoalState, newState: GoalState): boolean {
+  if (currentState === newState) return true;
+  return ValidStateTransitions[currentState].includes(newState);
+}
+
+/**
+ * Validates a goal object and returns parsed result or error
+ */
+export function validateGoal(data: unknown): { success: true; data: Goal } | { success: false; errors: z.ZodError } {
+  const result = GoalSchema.safeParse(data);
+  if (result.success) {
+    return { success: true, data: result.data };
+  }
+  return { success: false, errors: result.error };
+}
+
+/**
+ * Validates a milestone object and returns parsed result or error
+ */
+export function validateMilestone(data: unknown): { success: true; data: Milestone } | { success: false; errors: z.ZodError } {
+  const result = MilestoneSchema.safeParse(data);
+  if (result.success) {
+    return { success: true, data: result.data };
+  }
+  return { success: false, errors: result.error };
+}
+
+/**
+ * Validates a progress update and returns parsed result or error
+ */
+export function validateProgressUpdate(data: unknown): { success: true; data: ProgressUpdate } | { success: false; errors: z.ZodError } {
+  const result = ProgressUpdateSchema.safeParse(data);
+  if (result.success) {
+    return { success: true, data: result.data };
+  }
+  return { success: false, errors: result.error };
+}
+
+/**
+ * Validates a dependency and checks for basic consistency
+ */
+export function validateDependency(data: unknown): { success: true; data: Dependency } | { success: false; errors: z.ZodError } {
+  const result = DependencySchema.safeParse(data);
+  if (result.success) {
+    // Additional validation: source and target must be different
+    if (result.data.sourceId === result.data.targetId) {
+      return {
+        success: false,
+        errors: new z.ZodError([{
+          code: 'custom',
+          path: ['sourceId', 'targetId'],
+          message: 'A dependency cannot have the same source and target',
+        }]),
+      };
+    }
+    return { success: true, data: result.data };
+  }
+  return { success: false, errors: result.error };
+}
diff --git a/repository_after/goal-traking/app/lib/utils.ts b/repository_after/goal-traking/app/lib/utils.ts
new file mode 100644
index 00000000..365058ce
--- /dev/null
+++ b/repository_after/goal-traking/app/lib/utils.ts
@@ -0,0 +1,6 @@
+import { type ClassValue, clsx } from "clsx";
+import { twMerge } from "tailwind-merge";
+
+export function cn(...inputs: ClassValue[]) {
+  return twMerge(clsx(inputs));
+}
diff --git a/repository_after/goal-traking/app/page.tsx b/repository_after/goal-traking/app/page.tsx
new file mode 100644
index 00000000..a37dcf15
--- /dev/null
+++ b/repository_after/goal-traking/app/page.tsx
@@ -0,0 +1,74 @@
+'use client';
+
+import React, { useState, useEffect } from 'react';
+import { useGoalStore } from '@/lib/store';
+import { GoalList } from '@/components/GoalList';
+import { GoalDetail } from '@/components/GoalDetail';
+import { GoalForm } from '@/components/GoalForms';
+import { AnalyticsDashboard } from '@/components/AnalyticsDashboard';
+import { AppLayout } from '@/components/layout/AppLayout';
+import { Modal } from '@/components/ui/Modal';
+import { DataExportModal } from '@/components/forms/DataExportModal';
+
+export default function Home() {
+  const { initialize, isLoading, selectedGoalId, selectGoal } = useGoalStore();
+  
+  const [activeView, setActiveView] = useState<'goals' | 'analytics' | 'settings'>('goals');
+  const [showCreateForm, setShowCreateForm] = useState(false);
+  const [showExportModal, setShowExportModal] = useState(false);
+  
+  // Initialize store on mount
+  useEffect(() => {
+    initialize();
+  }, [initialize]);
+  
+  // Handle detail modal close
+  const closeDetail = () => selectGoal(null);
+
+  return (
+    <AppLayout 
+      activeView={activeView} 
+      onViewChange={setActiveView}
+      onCreateClick={() => setShowCreateForm(true)}
+      onExportClick={() => setShowExportModal(true)}
+    >
+      <div className="relative">
+        {/* Main Content Areas */}
+        {activeView === 'goals' && (
+          <GoalList onGoalSelect={(id) => selectGoal(id)} />
+        )}
+        
+        {activeView === 'analytics' && (
+          <AnalyticsDashboard />
+        )}
+
+        {activeView === 'settings' && (
+          <div className="flex items-center justify-center h-[50vh] text-muted-foreground">
+             Settings coming soon...
+          </div>
+        )}
+        
+        {/* Detail View Modal/Slide-over */}
+        {selectedGoalId && (
+          <div className="fixed inset-0 z-50 flex justify-end bg-black/60 backdrop-blur-sm animate-in fade-in duration-200">
+             <div className="w-full max-w-4xl h-full bg-background border-l border-white/10 shadow-2xl animate-in slide-in-from-right duration-300">
+                <GoalDetail goalId={selectedGoalId} onClose={closeDetail} />
+             </div>
+             {/* Click outside to close */}
+             <div className="absolute inset-0 -z-10" onClick={closeDetail} />
+          </div>
+        )}
+        
+        {/* Create Modal */}
+        {showCreateForm && (
+           <GoalForm onClose={() => setShowCreateForm(false)} />
+        )}
+
+        {/* Export Modal */}
+        {showExportModal && (
+           <DataExportModal onClose={() => setShowExportModal(false)} />
+        )}
+      </div>
+    </AppLayout>
+  );
+}
diff --git a/repository_after/goal-traking/eslint.config.mjs b/repository_after/goal-traking/eslint.config.mjs
new file mode 100644
index 00000000..05e726d1
--- /dev/null
+++ b/repository_after/goal-traking/eslint.config.mjs
@@ -0,0 +1,18 @@
+import { defineConfig, globalIgnores } from "eslint/config";
+import nextVitals from "eslint-config-next/core-web-vitals";
+import nextTs from "eslint-config-next/typescript";
+
+const eslintConfig = defineConfig([
+  ...nextVitals,
+  ...nextTs,
+  // Override default ignores of eslint-config-next.
+  globalIgnores([
+    // Default ignores of eslint-config-next:
+    ".next/**",
+    "out/**",
+    "build/**",
+    "next-env.d.ts",
+  ]),
+]);
+
+export default eslintConfig;
diff --git a/repository_after/goal-traking/next.config.ts b/repository_after/goal-traking/next.config.ts
new file mode 100644
index 00000000..2f9a73d9
--- /dev/null
+++ b/repository_after/goal-traking/next.config.ts
@@ -0,0 +1,25 @@
+import type { NextConfig } from "next";
+
+const nextConfig: NextConfig = {
+  // Enable standalone output for Docker deployments
+  output: 'standalone',
+  
+  // Optimize images
+  images: {
+    domains: [],
+  },
+  
+  // TypeScript configuration
+  typescript: {
+    // Enable strict type checking
+    tsconfigPath: './tsconfig.json',
+  },
+  
+  // Experimental features
+  experimental: {
+    // Enable page router optimization
+    optimizePackageImports: ['date-fns', 'recharts', 'zustand'],
+  },
+};
+
+export default nextConfig;
diff --git a/repository_after/goal-traking/postcss.config.mjs b/repository_after/goal-traking/postcss.config.mjs
new file mode 100644
index 00000000..61e36849
--- /dev/null
+++ b/repository_after/goal-traking/postcss.config.mjs
@@ -0,0 +1,7 @@
+const config = {
+  plugins: {
+    "@tailwindcss/postcss": {},
+  },
+};
+
+export default config;
diff --git a/repository_after/goal-traking/public/vercel.svg b/repository_after/goal-traking/public/vercel.svg
new file mode 100644
index 00000000..77053960
--- /dev/null
+++ b/repository_after/goal-traking/public/vercel.svg
@@ -0,0 +1 @@
+<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
\ No newline at end of file
diff --git a/repository_after/goal-traking/tsconfig.json b/repository_after/goal-traking/tsconfig.json
new file mode 100644
index 00000000..51b605f9
--- /dev/null
+++ b/repository_after/goal-traking/tsconfig.json
@@ -0,0 +1,34 @@
+{
+  "compilerOptions": {
+    "target": "ES2017",
+    "lib": ["dom", "dom.iterable", "esnext"],
+    "allowJs": true,
+    "skipLibCheck": true,
+    "strict": true,
+    "noEmit": true,
+    "esModuleInterop": true,
+    "module": "esnext",
+    "moduleResolution": "bundler",
+    "resolveJsonModule": true,
+    "isolatedModules": true,
+    "jsx": "react-jsx",
+    "incremental": true,
+    "plugins": [
+      {
+        "name": "next"
+      }
+    ],
+    "paths": {
+      "@/*": ["./app/*"]
+    }
+  },
+  "include": [
+    "next-env.d.ts",
+    "**/*.ts",
+    "**/*.tsx",
+    ".next/types/**/*.ts",
+    ".next/dev/types/**/*.ts",
+    "**/*.mts"
+  ],
+  "exclude": ["node_modules"]
+}
