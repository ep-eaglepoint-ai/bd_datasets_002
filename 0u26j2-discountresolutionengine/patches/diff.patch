diff --git a/0u26j2-discountresolutionengine/repository_after/discount_engine.go b/0u26j2-discountresolutionengine/repository_after/discount_engine.go
index ef5a47f..aed83ee 100644
--- a/0u26j2-discountresolutionengine/repository_after/discount_engine.go
+++ b/0u26j2-discountresolutionengine/repository_after/discount_engine.go
@@ -269,6 +269,43 @@ type CalculationManifest struct {
 	IsSimulation     bool
 }
 
+// Equal checks if two manifests are equal (for testing determinism)
+func (m *CalculationManifest) Equal(other *CalculationManifest) bool {
+	if m.CartID != other.CartID ||
+		!m.EntryPrice.Equal(other.EntryPrice) ||
+		!m.FinalPrice.Equal(other.FinalPrice) ||
+		!m.TotalDiscount.Equal(other.TotalDiscount) ||
+		len(m.RulesApplied) != len(other.RulesApplied) ||
+		len(m.RulesSkipped) != len(other.RulesSkipped) {
+		return false
+	}
+
+	for i := range m.RulesApplied {
+		if m.RulesApplied[i].RuleID != other.RulesApplied[i].RuleID ||
+			!m.RulesApplied[i].EntryPrice.Equal(other.RulesApplied[i].EntryPrice) ||
+			!m.RulesApplied[i].Delta.Equal(other.RulesApplied[i].Delta) ||
+			!m.RulesApplied[i].ExitPrice.Equal(other.RulesApplied[i].ExitPrice) {
+			return false
+		}
+	}
+
+	for i := range m.RulesSkipped {
+		if m.RulesSkipped[i] != other.RulesSkipped[i] {
+			return false
+		}
+	}
+
+	return true
+}
+
+// ZeroTimestamps zeros all timestamps for deterministic comparison
+func (m *CalculationManifest) ZeroTimestamps() {
+	m.EvaluationTime = 0
+	for i := range m.RulesApplied {
+		m.RulesApplied[i].AppliedAt = time.Time{}
+	}
+}
+
 // ============================================================================
 // DAG - Directed Acyclic Graph for Rule Dependencies
 // ============================================================================
@@ -310,6 +347,21 @@ func (d *DAG) AddRule(rule *Rule) error {
 	return nil
 }
 
+// ValidateDependencies checks that all dependencies exist
+func (d *DAG) ValidateDependencies() error {
+	d.mu.RLock()
+	defer d.mu.RUnlock()
+
+	for id, rule := range d.rules {
+		for _, depID := range rule.Dependencies {
+			if _, exists := d.rules[depID]; !exists {
+				return fmt.Errorf("rule %s has missing dependency: %s", id, depID)
+			}
+		}
+	}
+	return nil
+}
+
 // DetectCycle detects circular dependencies using DFS
 func (d *DAG) DetectCycle() error {
 	d.mu.RLock()
@@ -377,9 +429,12 @@ func (d *DAG) TopologicalSort() ([]*Rule, error) {
 
 	var sorted []*Rule
 	for len(queue) > 0 {
-		// Sort by priority within same tier
+		// Sort by priority within same tier, tie-break by Rule.ID for determinism
 		sort.Slice(queue, func(i, j int) bool {
-			return d.rules[queue[i]].Priority > d.rules[queue[j]].Priority
+			if d.rules[queue[i]].Priority != d.rules[queue[j]].Priority {
+				return d.rules[queue[i]].Priority > d.rules[queue[j]].Priority
+			}
+			return queue[i] < queue[j] // Tie-break by ID (lexicographic)
 		})
 
 		nodeID := queue[0]
@@ -452,8 +507,11 @@ func (e *Engine) AddRule(rule *Rule) error {
 	return e.dag.AddRule(rule)
 }
 
-// Validate validates the rule graph (detects cycles)
+// Validate validates the rule graph (detects cycles and missing dependencies)
 func (e *Engine) Validate() error {
+	if err := e.dag.ValidateDependencies(); err != nil {
+		return err
+	}
 	return e.dag.DetectCycle()
 }
 
@@ -510,10 +568,13 @@ func (e *Engine) EvaluateAt(cart *Cart, snapshotDate time.Time, isSimulation boo
 		}
 	}
 
-	// Sort by priority within each group
+	// Sort by priority within each group, tie-break by Rule.ID for determinism
 	sortByPriority := func(rules []*Rule) {
 		sort.Slice(rules, func(i, j int) bool {
-			return rules[i].Priority > rules[j].Priority
+			if rules[i].Priority != rules[j].Priority {
+				return rules[i].Priority > rules[j].Priority
+			}
+			return rules[i].ID < rules[j].ID
 		})
 	}
 	sortByPriority(additiveRules)
diff --git a/0u26j2-discountresolutionengine/tests/discount_engine_test.go b/0u26j2-discountresolutionengine/tests/discount_engine_test.go
index 239a5c7..ebe5fd5 100644
--- a/0u26j2-discountresolutionengine/tests/discount_engine_test.go
+++ b/0u26j2-discountresolutionengine/tests/discount_engine_test.go
@@ -2,6 +2,8 @@ package discountengine_test
 
 import (
 	de "discountengine"
+	"fmt"
+	"sort"
 	"sync"
 	"testing"
 	"time"
@@ -630,3 +632,404 @@ func TestDecimal_Comparisons(t *testing.T) {
 		t.Error("10.5 should equal 10.5")
 	}
 }
+
+// ============================================================================
+// Additional Tests (Boss Feedback)
+// ============================================================================
+
+// Test 1: Deterministic manifest equality (parallel runs compare full CalculationManifest)
+func TestEngine_DeterministicManifestEquality_Parallel(t *testing.T) {
+	engine := de.NewEngine()
+
+	engine.AddRule(&de.Rule{
+		ID:         "rule1",
+		Name:       "10% Off",
+		Type:       de.RuleTypePercentage,
+		Mode:       de.RuleModeStackable,
+		StackOrder: de.StackOrderMultiplicative,
+		Priority:   10,
+		Value:      de.NewDecimal(10),
+	})
+
+	engine.AddRule(&de.Rule{
+		ID:         "rule2",
+		Name:       "$5 Off",
+		Type:       de.RuleTypeFixed,
+		Mode:       de.RuleModeStackable,
+		StackOrder: de.StackOrderAdditive,
+		Priority:   20,
+		Value:      de.NewDecimal(5),
+	})
+
+	cart := &de.Cart{
+		ID: "determinism-cart",
+		Items: []*de.CartItem{
+			{ID: "item1", Name: "Product A", Quantity: 2, UnitPrice: de.NewDecimal(50)},
+			{ID: "item2", Name: "Product B", Quantity: 1, UnitPrice: de.NewDecimal(30)},
+		},
+	}
+
+	const numParallel = 100
+	results := make([]*de.CalculationManifest, numParallel)
+	var wg sync.WaitGroup
+
+	for i := 0; i < numParallel; i++ {
+		wg.Add(1)
+		go func(idx int) {
+			defer wg.Done()
+			manifest, err := engine.Evaluate(cart)
+			if err != nil {
+				t.Errorf("Parallel evaluation %d failed: %v", idx, err)
+				return
+			}
+			manifest.ZeroTimestamps()
+			results[idx] = manifest
+		}(i)
+	}
+	wg.Wait()
+
+	reference := results[0]
+	for i := 1; i < numParallel; i++ {
+		if !results[i].Equal(reference) {
+			t.Errorf("Manifest %d differs from reference manifest", i)
+			t.Errorf("Reference: FinalPrice=%s, RulesApplied=%d", reference.FinalPrice.String(), len(reference.RulesApplied))
+			t.Errorf("Result %d: FinalPrice=%s, RulesApplied=%d", i, results[i].FinalPrice.String(), len(results[i].RulesApplied))
+		}
+	}
+}
+
+// Test 2: Timestamp determinism (ensure AppliedAt and EvaluationTime are zeroed for comparison)
+func TestEngine_TimestampDeterminism(t *testing.T) {
+	engine := de.NewEngine()
+
+	engine.AddRule(&de.Rule{
+		ID:         "rule1",
+		Name:       "15% Off",
+		Type:       de.RuleTypePercentage,
+		Mode:       de.RuleModeStackable,
+		StackOrder: de.StackOrderMultiplicative,
+		Priority:   10,
+		Value:      de.NewDecimal(15),
+	})
+
+	cart := &de.Cart{
+		ID:    "timestamp-cart",
+		Items: []*de.CartItem{{ID: "item1", Name: "Product", Quantity: 1, UnitPrice: de.NewDecimal(100)}},
+	}
+
+	manifest1, _ := engine.Evaluate(cart)
+	time.Sleep(10 * time.Millisecond) // Ensure different timestamps
+	manifest2, _ := engine.Evaluate(cart)
+
+	// Before zeroing, EvaluationTime might differ
+	if manifest1.EvaluationTime == manifest2.EvaluationTime {
+		t.Log("EvaluationTime happened to be equal (rare)")
+	}
+
+	// Zero timestamps for deterministic comparison
+	manifest1.ZeroTimestamps()
+	manifest2.ZeroTimestamps()
+
+	if !manifest1.Equal(manifest2) {
+		t.Error("Manifests should be equal after zeroing timestamps")
+	}
+
+	// Verify timestamps are actually zeroed
+	if manifest1.EvaluationTime != 0 {
+		t.Error("EvaluationTime should be zeroed")
+	}
+	for _, ra := range manifest1.RulesApplied {
+		if !ra.AppliedAt.IsZero() {
+			t.Error("AppliedAt should be zeroed")
+		}
+	}
+}
+
+// Test 3: Full-manifest order and delta test
+func TestEngine_FullManifest_OrderAndDelta(t *testing.T) {
+	engine := de.NewEngine()
+
+	engine.AddRule(&de.Rule{
+		ID:         "fixed5",
+		Name:       "$5 Off",
+		Type:       de.RuleTypeFixed,
+		Mode:       de.RuleModeStackable,
+		StackOrder: de.StackOrderAdditive,
+		Priority:   20,
+		Value:      de.NewDecimal(5),
+	})
+
+	engine.AddRule(&de.Rule{
+		ID:         "percent10",
+		Name:       "10% Off",
+		Type:       de.RuleTypePercentage,
+		Mode:       de.RuleModeStackable,
+		StackOrder: de.StackOrderMultiplicative,
+		Priority:   10,
+		Value:      de.NewDecimal(10),
+	})
+
+	cart := &de.Cart{
+		ID:    "manifest-order-cart",
+		Items: []*de.CartItem{{ID: "item1", Name: "Product", Quantity: 1, UnitPrice: de.NewDecimal(100)}},
+	}
+
+	manifest, err := engine.Evaluate(cart)
+	if err != nil {
+		t.Fatalf("Evaluation failed: %v", err)
+	}
+
+	// Verify order: additive ($5 off) before multiplicative (10% off)
+	if len(manifest.RulesApplied) < 2 {
+		t.Fatalf("Expected at least 2 rules applied, got %d", len(manifest.RulesApplied))
+	}
+
+	if manifest.RulesApplied[0].RuleID != "fixed5" {
+		t.Errorf("First rule should be fixed5, got %s", manifest.RulesApplied[0].RuleID)
+	}
+	if manifest.RulesApplied[1].RuleID != "percent10" {
+		t.Errorf("Second rule should be percent10, got %s", manifest.RulesApplied[1].RuleID)
+	}
+
+	// Verify deltas
+	// Entry: 100, after $5 off: 95, delta = 5
+	if !manifest.RulesApplied[0].Delta.Equal(de.NewDecimal(5)) {
+		t.Errorf("First delta should be 5, got %s", manifest.RulesApplied[0].Delta.String())
+	}
+
+	// Entry: 95, after 10% off: 85.5, delta = 9.5
+	expectedDelta2 := de.NewDecimal(9.5)
+	if !manifest.RulesApplied[1].Delta.Equal(expectedDelta2) {
+		t.Errorf("Second delta should be %s, got %s", expectedDelta2.String(), manifest.RulesApplied[1].Delta.String())
+	}
+
+	// Verify entry/exit prices chain
+	if !manifest.RulesApplied[0].EntryPrice.Equal(de.NewDecimal(100)) {
+		t.Errorf("First entry price should be 100")
+	}
+	if !manifest.RulesApplied[0].ExitPrice.Equal(de.NewDecimal(95)) {
+		t.Errorf("First exit price should be 95")
+	}
+	if !manifest.RulesApplied[1].EntryPrice.Equal(de.NewDecimal(95)) {
+		t.Errorf("Second entry price should be 95")
+	}
+}
+
+// Test 4: Topological sort tie-breaker (equal Priority resolved by Rule.ID)
+func TestDAG_TopologicalSort_TieBreaker(t *testing.T) {
+	dag := de.NewDAG()
+
+	// Add rules with same priority but different IDs
+	dag.AddRule(&de.Rule{ID: "C", Name: "Rule C", Priority: 10})
+	dag.AddRule(&de.Rule{ID: "A", Name: "Rule A", Priority: 10})
+	dag.AddRule(&de.Rule{ID: "B", Name: "Rule B", Priority: 10})
+
+	sorted, err := dag.TopologicalSort()
+	if err != nil {
+		t.Fatalf("TopologicalSort failed: %v", err)
+	}
+
+	// With same priority, should be sorted by ID lexicographically: A, B, C
+	expectedOrder := []string{"A", "B", "C"}
+	for i, rule := range sorted {
+		if rule.ID != expectedOrder[i] {
+			t.Errorf("Position %d: expected %s, got %s", i, expectedOrder[i], rule.ID)
+		}
+	}
+}
+
+// Test 5: Missing-dependency validation test
+func TestEngine_Validate_MissingDependency(t *testing.T) {
+	engine := de.NewEngine()
+
+	engine.AddRule(&de.Rule{ID: "A", Name: "Rule A"})
+	engine.AddRule(&de.Rule{ID: "B", Name: "Rule B", Dependencies: []string{"NonExistent"}})
+
+	err := engine.Validate()
+	if err == nil {
+		t.Error("Validation should fail for missing dependency")
+	}
+}
+
+// Test 6: BuyXGetY per-SKU scoping test
+func TestEngine_BuyXGetY_PerSKU_Scoping(t *testing.T) {
+	engine := de.NewEngine()
+
+	engine.AddRule(&de.Rule{
+		ID:          "b2g1",
+		Name:        "Buy 2 Get 1 Free",
+		Type:        de.RuleTypeBuyXGetY,
+		Mode:        de.RuleModeStackable,
+		StackOrder:  de.StackOrderAdditive,
+		Priority:    10,
+		BuyQuantity: 2,
+		GetQuantity: 1,
+	})
+
+	// Test with multiple SKUs
+	cart := &de.Cart{
+		ID: "sku-scoping-cart",
+		Items: []*de.CartItem{
+			{ID: "item1", ProductID: "SKU-A", Name: "Product A", Quantity: 2, UnitPrice: de.NewDecimal(30)},
+			{ID: "item2", ProductID: "SKU-B", Name: "Product B", Quantity: 1, UnitPrice: de.NewDecimal(20)},
+		},
+	}
+
+	manifest, err := engine.Evaluate(cart)
+	if err != nil {
+		t.Fatalf("Evaluation failed: %v", err)
+	}
+
+	// Total items = 3, Buy 2 Get 1 applies: cheapest item ($20) is free
+	// Original: 2*30 + 1*20 = 80
+	// After B2G1: 80 - 20 = 60
+	expectedFinal := de.NewDecimal(60)
+	if !manifest.FinalPrice.Equal(expectedFinal) {
+		t.Errorf("Final price = %s, expected %s", manifest.FinalPrice.String(), expectedFinal.String())
+	}
+}
+
+// Test 7: Purity/idempotence test for Evaluate
+func TestEngine_Evaluate_Idempotence(t *testing.T) {
+	engine := de.NewEngine()
+
+	engine.AddRule(&de.Rule{
+		ID:         "rule1",
+		Name:       "10% Off",
+		Type:       de.RuleTypePercentage,
+		Mode:       de.RuleModeStackable,
+		StackOrder: de.StackOrderMultiplicative,
+		Priority:   10,
+		Value:      de.NewDecimal(10),
+	})
+
+	cart := &de.Cart{
+		ID:    "idempotence-cart",
+		Items: []*de.CartItem{{ID: "item1", Name: "Product", Quantity: 1, UnitPrice: de.NewDecimal(100)}},
+	}
+
+	// Run multiple times and compare manifests
+	var manifests []*de.CalculationManifest
+	for i := 0; i < 10; i++ {
+		manifest, err := engine.Evaluate(cart)
+		if err != nil {
+			t.Fatalf("Evaluation %d failed: %v", i, err)
+		}
+		manifest.ZeroTimestamps()
+		manifests = append(manifests, manifest)
+	}
+
+	reference := manifests[0]
+	for i := 1; i < len(manifests); i++ {
+		if !manifests[i].Equal(reference) {
+			t.Errorf("Evaluation %d produced different manifest than reference", i)
+		}
+	}
+}
+
+// Test 8: Deep-nesting stack-safety test (1k+ chain)
+func TestEngine_DeepNesting_StackSafety_1000Chain(t *testing.T) {
+	engine := de.NewEngine()
+
+	const chainLength = 1000
+
+	// Create a chain of 1000 rules with dependencies
+	for i := 0; i < chainLength; i++ {
+		rule := &de.Rule{
+			ID:         fmt.Sprintf("rule%04d", i),
+			Name:       fmt.Sprintf("Rule %d", i),
+			Type:       de.RuleTypePercentage,
+			Mode:       de.RuleModeStackable,
+			StackOrder: de.StackOrderMultiplicative,
+			Priority:   chainLength - i,
+			Value:      de.NewDecimal(0.001), // Tiny discount to avoid going negative
+		}
+		if i > 0 {
+			rule.Dependencies = []string{fmt.Sprintf("rule%04d", i-1)}
+		}
+		engine.AddRule(rule)
+	}
+
+	cart := &de.Cart{
+		ID:    "deep-nesting-cart",
+		Items: []*de.CartItem{{ID: "item1", Name: "Product", Quantity: 1, UnitPrice: de.NewDecimal(1000000)}},
+	}
+
+	manifest, err := engine.Evaluate(cart)
+	if err != nil {
+		t.Fatalf("Deep nesting evaluation failed (possible stack overflow): %v", err)
+	}
+
+	if manifest.FinalPrice.IsNegative() {
+		t.Error("Final price should not be negative")
+	}
+
+	if len(manifest.RulesApplied) != chainLength {
+		t.Errorf("Expected %d rules applied, got %d", chainLength, len(manifest.RulesApplied))
+	}
+}
+
+// Test 9: Performance - Benchmark format for manual P99 verification
+func TestEngine_Performance_SLA_100Items_200Rules(t *testing.T) {
+	engine := de.NewEngine()
+
+	// Add 200 rules
+	for i := 0; i < 200; i++ {
+		stackOrder := de.StackOrderAdditive
+		if i%2 == 0 {
+			stackOrder = de.StackOrderMultiplicative
+		}
+		engine.AddRule(&de.Rule{
+			ID:         fmt.Sprintf("rule%03d", i),
+			Name:       fmt.Sprintf("Rule %d", i),
+			Type:       de.RuleTypePercentage,
+			Mode:       de.RuleModeStackable,
+			StackOrder: stackOrder,
+			Priority:   i % 50,
+			Value:      de.NewDecimal(0.05), // Small discount
+		})
+	}
+
+	// Create cart with 100 items
+	items := make([]*de.CartItem, 100)
+	for i := 0; i < 100; i++ {
+		items[i] = &de.CartItem{
+			ID:        fmt.Sprintf("item%03d", i),
+			ProductID: fmt.Sprintf("SKU-%03d", i),
+			Name:      fmt.Sprintf("Product %d", i),
+			Quantity:  1,
+			UnitPrice: de.NewDecimal(10.0 + float64(i)),
+		}
+	}
+	cart := &de.Cart{ID: "perf-cart", Items: items}
+
+	// Warm up
+	engine.Evaluate(cart)
+
+	// Run 100 evaluations and check timing
+	const numRuns = 100
+	durations := make([]time.Duration, numRuns)
+
+	for i := 0; i < numRuns; i++ {
+		start := time.Now()
+		_, err := engine.Evaluate(cart)
+		durations[i] = time.Since(start)
+		if err != nil {
+			t.Fatalf("Evaluation %d failed: %v", i, err)
+		}
+	}
+
+	// Sort to find P99
+	sort.Slice(durations, func(i, j int) bool {
+		return durations[i] < durations[j]
+	})
+
+	p99Index := int(float64(numRuns) * 0.99)
+	p99 := durations[p99Index]
+
+	t.Logf("P99 latency: %v (SLA: < 5ms)", p99)
+
+	if p99 > 5*time.Millisecond {
+		t.Errorf("P99 latency %v exceeds SLA of 5ms", p99)
+	}
+}
