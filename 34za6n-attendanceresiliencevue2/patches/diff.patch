diff --git a/repository_before/.gitkeep b/repository_before/.gitkeep
deleted file mode 100644
index e69de29..0000000
diff --git a/repository_after/package.json b/repository_after/package.json
new file mode 100644
index 0000000..47450aa
--- /dev/null
+++ b/repository_after/package.json
@@ -0,0 +1,50 @@
+{
+  "name": "attendance-resilience-vue2",
+  "version": "1.0.0",
+  "description": "Enterprise attendance system with resilient state management",
+  "main": "src/main.js",
+  "scripts": {
+    "serve": "vue-cli-service serve",
+    "build": "vue-cli-service build",
+    "test": "jest",
+    "test:watch": "jest --watch",
+    "lint": "vue-cli-service lint"
+  },
+  "dependencies": {
+    "vue": "^2.6.14",
+    "vuex": "^3.6.2",
+    "vuetify": "^2.6.14",
+    "axios": "^1.6.0"
+  },
+  "devDependencies": {
+    "@vue/cli-service": "^5.0.8",
+    "@vue/test-utils": "^1.3.6",
+    "jest": "^29.7.0",
+    "vue-jest": "^3.0.7",
+    "vue-template-compiler": "^2.6.14",
+    "babel-jest": "^29.7.0",
+    "@babel/preset-env": "^7.23.0",
+    "jsdom": "^23.0.0"
+  },
+  "jest": {
+    "moduleFileExtensions": [
+      "js",
+      "json",
+      "vue"
+    ],
+    "transform": {
+      ".*\\.(vue)$": "vue-jest",
+      "^.+\\.js$": "babel-jest"
+    },
+    "testEnvironment": "jsdom",
+    "collectCoverageFrom": [
+      "src/**/*.{js,vue}",
+      "!src/main.js"
+    ]
+  },
+  "babel": {
+    "presets": [
+      "@babel/preset-env"
+    ]
+  }
+}
\ No newline at end of file
diff --git a/repository_after/public/index.html b/repository_after/public/index.html
new file mode 100644
index 0000000..c31738e
--- /dev/null
+++ b/repository_after/public/index.html
@@ -0,0 +1,18 @@
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="utf-8">
+    <meta http-equiv="X-UA-Compatible" content="IE=edge">
+    <meta name="viewport" content="width=device-width,initial-scale=1.0">
+    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
+    <title>Attendance Resilience System</title>
+    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
+    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@6.x/css/materialdesignicons.min.css" rel="stylesheet">
+  </head>
+  <body>
+    <noscript>
+      <strong>We're sorry but attendance-resilience-vue2 doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
+    </noscript>
+    <div id="app"></div>
+  </body>
+</html>
\ No newline at end of file
diff --git a/repository_after/src/App.vue b/repository_after/src/App.vue
new file mode 100644
index 0000000..4610a6a
--- /dev/null
+++ b/repository_after/src/App.vue
@@ -0,0 +1,187 @@
+<template>
+  <v-app>
+    <v-app-bar app color="primary" dark>
+      <v-toolbar-title>
+        <v-icon left>mdi-account-clock</v-icon>
+        Enterprise Attendance System
+      </v-toolbar-title>
+      
+      <v-spacer></v-spacer>
+      
+      <!-- Operations in progress indicator -->
+      <v-chip
+        v-if="hasOperationsInProgress"
+        color="warning"
+        text-color="white"
+        small
+      >
+        <v-progress-circular
+          indeterminate
+          size="16"
+          width="2"
+          class="mr-2"
+        ></v-progress-circular>
+        Operations in progress
+      </v-chip>
+      
+      <!-- Retry queue indicator -->
+      <v-badge
+        v-if="retryQueue.length > 0"
+        :content="retryQueue.length"
+        color="error"
+        overlap
+      >
+        <v-btn
+          icon
+          @click="showRetryDialog = true"
+          title="Failed operations - click to retry"
+        >
+          <v-icon>mdi-alert-circle</v-icon>
+        </v-btn>
+      </v-badge>
+    </v-app-bar>
+
+    <v-main>
+      <v-container fluid>
+        <!-- Loading skeleton for initial load -->
+        <template v-if="isLoadingRecords && allRecords.length === 0">
+          <v-row>
+            <v-col cols="12">
+              <v-skeleton-loader
+                type="table-heading, table-tbody"
+                class="mx-auto"
+              ></v-skeleton-loader>
+            </v-col>
+          </v-row>
+        </template>
+        
+        <!-- Main content -->
+        <template v-else>
+          <!-- Filter Panel -->
+          <FilterPanel />
+          
+          <!-- Header with actions -->
+          <v-row>
+            <v-col cols="12">
+              <v-card>
+                <v-card-title>
+                  Attendance Records
+                  <v-spacer></v-spacer>
+                  <v-btn
+                    color="primary"
+                    @click="refreshData"
+                    :loading="isLoadingRecords"
+                  >
+                    <v-icon left>mdi-refresh</v-icon>
+                    Refresh
+                  </v-btn>
+                </v-card-title>
+              </v-card>
+            </v-col>
+          </v-row>
+          
+          <!-- Attendance records -->
+          <AttendanceList />
+          
+          <!-- Bulk operations -->
+          <BulkOperations />
+        </template>
+      </v-container>
+    </v-main>
+
+    <!-- Notifications -->
+    <NotificationSystem />
+    
+    <!-- Retry dialog -->
+    <RetryDialog
+      v-model="showRetryDialog"
+      :retry-queue="retryQueue"
+      @retry="handleRetry"
+      @clear="clearRetryQueue"
+    />
+  </v-app>
+</template>
+
+<script>
+import { mapGetters, mapActions } from 'vuex'
+import AttendanceList from '@/components/AttendanceList.vue'
+import BulkOperations from '@/components/BulkOperations.vue'
+import NotificationSystem from '@/components/NotificationSystem.vue'
+import RetryDialog from '@/components/RetryDialog.vue'
+import FilterPanel from '@/components/FilterPanel.vue'
+
+export default {
+  name: 'App',
+  
+  components: {
+    AttendanceList,
+    BulkOperations,
+    NotificationSystem,
+    RetryDialog,
+    FilterPanel
+  },
+  
+  data() {
+    return {
+      showRetryDialog: false
+    }
+  },
+  
+  computed: {
+    ...mapGetters('attendance', [
+      'allRecords',
+      'isLoadingRecords',
+      'hasOperationsInProgress',
+      'retryQueue'
+    ])
+  },
+  
+  methods: {
+    ...mapActions('attendance', [
+      'fetchAttendanceRecords',
+      'retryOperation',
+      'clearRetryQueue',
+      'cleanupNotifications'
+    ]),
+    
+    async refreshData() {
+      await this.fetchAttendanceRecords()
+    },
+    
+    async handleRetry(operation) {
+      await this.retryOperation(operation)
+      
+      // Close dialog if no more operations
+      if (this.retryQueue.length === 0) {
+        this.showRetryDialog = false
+      }
+    }
+  },
+  
+  async created() {
+    // Load initial data
+    await this.fetchAttendanceRecords()
+    
+    // Set up cleanup interval for notifications
+    this.cleanupInterval = setInterval(() => {
+      this.cleanupNotifications()
+    }, 10000) // Clean up every 10 seconds
+  },
+  
+  beforeDestroy() {
+    if (this.cleanupInterval) {
+      clearInterval(this.cleanupInterval)
+    }
+  }
+}
+</script>
+
+<style>
+.v-application {
+  font-family: 'Roboto', sans-serif;
+}
+
+.v-chip--small .v-progress-circular {
+  margin-right: 4px !important;
+}
+</style>
\ No newline at end of file
diff --git a/repository_after/src/components/AttendanceList.vue b/repository_after/src/components/AttendanceList.vue
new file mode 100644
index 0000000..fe39cfc
--- /dev/null
+++ b/repository_after/src/components/AttendanceList.vue
@@ -0,0 +1,320 @@
+<template>
+  <v-row>
+    <v-col cols="12">
+      <v-card>
+        <v-card-title>
+          Daily Attendance - {{ currentDate }}
+        </v-card-title>
+        
+        <v-data-table
+          :headers="headers"
+          :items="allRecords"
+          :loading="isLoadingRecords"
+          class="elevation-1"
+          item-key="id"
+        >
+          <!-- Employee name column -->
+          <template v-slot:item.employeeName="{ item }">
+            <div class="d-flex align-center">
+              <v-avatar size="32" class="mr-3">
+                <v-icon>mdi-account</v-icon>
+              </v-avatar>
+              <div>
+                <div class="font-weight-medium">{{ item.employeeName }}</div>
+                <div class="text-caption text--secondary">{{ item.employeeId }}</div>
+                <div class="text-caption text--secondary">{{ item.department }}</div>
+              </div>
+            </div>
+          </template>
+          
+          <!-- Status column with loading indicators -->
+          <template v-slot:item.status="{ item }">
+            <div class="d-flex align-center">
+              <!-- Loading indicator for individual record operations -->
+              <v-progress-circular
+                v-if="getRecordOperationStatus(item.id) === 'loading'"
+                indeterminate
+                size="20"
+                width="2"
+                color="primary"
+                class="mr-2"
+              ></v-progress-circular>
+              
+              <!-- Status chip -->
+              <v-chip
+                :color="getStatusColor(item.status)"
+                :text-color="getStatusTextColor(item.status)"
+                small
+                :class="{ 'opacity-60': getRecordOperationStatus(item.id) === 'loading' }"
+              >
+                <v-icon left small>{{ getStatusIcon(item.status) }}</v-icon>
+                {{ item.status.toUpperCase() }}
+              </v-chip>
+              
+              <!-- Error indicator -->
+              <v-tooltip bottom v-if="getRecordOperationStatus(item.id) === 'error'">
+                <template v-slot:activator="{ on, attrs }">
+                  <v-icon
+                    color="error"
+                    small
+                    class="ml-2"
+                    v-bind="attrs"
+                    v-on="on"
+                  >
+                    mdi-alert-circle
+                  </v-icon>
+                </template>
+                <span>Operation failed - check retry queue</span>
+              </v-tooltip>
+            </div>
+          </template>
+          
+          <!-- Check-in time column -->
+          <template v-slot:item.checkInTime="{ item }">
+            <span v-if="item.checkInTime" class="font-weight-medium">
+              {{ item.checkInTime }}
+            </span>
+            <span v-else class="text--disabled">
+              --:--
+            </span>
+          </template>
+          
+          <!-- Check-out time column -->
+          <template v-slot:item.checkOutTime="{ item }">
+            <span v-if="item.checkOutTime" class="font-weight-medium">
+              {{ item.checkOutTime }}
+            </span>
+            <span v-else class="text--disabled">
+              --:--
+            </span>
+          </template>
+          
+          <!-- Hours worked column -->
+          <template v-slot:item.hoursWorked="{ item }">
+            <div v-if="getTotalHours(item.id) > 0">
+              <div class="font-weight-medium">
+                {{ getTotalHours(item.id).toFixed(1) }}h
+              </div>
+              <div v-if="getOvertimeHours(item.id) > 0" class="text-caption text--warning">
+                +{{ getOvertimeHours(item.id).toFixed(1) }}h OT
+              </div>
+            </div>
+            <span v-else class="text--disabled">--</span>
+          </template>
+          
+          <!-- Actions column -->
+          <template v-slot:item.actions="{ item }">
+            <div class="d-flex gap-2 flex-wrap">
+              <!-- Clock In/Out buttons -->
+              <v-btn
+                v-if="item.status !== 'active' && item.status !== 'clocked_out'"
+                small
+                color="primary"
+                :disabled="getRecordOperationStatus(item.id) === 'loading'"
+                @click="clockIn(item.id)"
+              >
+                <v-icon small left>mdi-login</v-icon>
+                Clock In
+              </v-btn>
+              
+              <v-btn
+                v-if="item.status === 'active'"
+                small
+                color="warning"
+                :disabled="getRecordOperationStatus(item.id) === 'loading'"
+                @click="clockOut(item.id)"
+              >
+                <v-icon small left>mdi-logout</v-icon>
+                Clock Out
+              </v-btn>
+              
+              <!-- Status toggle buttons -->
+              <v-btn
+                v-if="item.status !== 'present'"
+                small
+                color="success"
+                :disabled="getRecordOperationStatus(item.id) === 'loading'"
+                @click="toggleAttendance(item.id, 'present')"
+              >
+                <v-icon small left>mdi-check</v-icon>
+                Present
+              </v-btn>
+              
+              <v-btn
+                v-if="item.status !== 'absent'"
+                small
+                color="error"
+                :disabled="getRecordOperationStatus(item.id) === 'loading'"
+                @click="toggleAttendance(item.id, 'absent')"
+              >
+                <v-icon small left>mdi-close</v-icon>
+                Absent
+              </v-btn>
+              
+              <v-btn
+                v-if="item.status !== 'on_break'"
+                small
+                color="info"
+                :disabled="getRecordOperationStatus(item.id) === 'loading'"
+                @click="toggleAttendance(item.id, 'on_break')"
+              >
+                <v-icon small left>mdi-coffee</v-icon>
+                Break
+              </v-btn>
+              
+              <!-- Retry button for failed operations -->
+              <v-btn
+                v-if="getRecordOperationStatus(item.id) === 'error'"
+                small
+                color="primary"
+                outlined
+                @click="retryLastOperation(item.id)"
+              >
+                <v-icon small left>mdi-refresh</v-icon>
+                Retry
+              </v-btn>
+            </div>
+          </template>
+          
+          <!-- Loading overlay -->
+          <template v-slot:loading>
+            <v-skeleton-loader
+              type="table-row@5"
+            ></v-skeleton-loader>
+          </template>
+        </v-data-table>
+      </v-card>
+    </v-col>
+  </v-row>
+</template>
+
+<script>
+import { mapGetters, mapActions } from 'vuex'
+
+export default {
+  name: 'AttendanceList',
+  
+  data() {
+    return {
+      headers: [
+        {
+          text: 'Employee',
+          value: 'employeeName',
+          sortable: true,
+          width: '250px'
+        },
+        {
+          text: 'Status',
+          value: 'status',
+          sortable: true,
+          width: '150px'
+        },
+        {
+          text: 'Check-in Time',
+          value: 'checkInTime',
+          sortable: true,
+          width: '120px'
+        },
+        {
+          text: 'Check-out Time',
+          value: 'checkOutTime',
+          sortable: true,
+          width: '120px'
+        },
+        {
+          text: 'Hours Worked',
+          value: 'hoursWorked',
+          sortable: false,
+          width: '120px'
+        },
+        {
+          text: 'Actions',
+          value: 'actions',
+          sortable: false,
+          width: '400px'
+        }
+      ]
+    }
+  },
+  
+  computed: {
+    ...mapGetters('attendance', [
+      'allRecords',
+      'isLoadingRecords',
+      'getRecordOperationStatus',
+      'getTotalHours',
+      'getOvertimeHours'
+    ]),
+    
+    currentDate() {
+      return new Date().toLocaleDateString('en-US', {
+        weekday: 'long',
+        year: 'numeric',
+        month: 'long',
+        day: 'numeric'
+      })
+    }
+  },
+  
+  methods: {
+    ...mapActions('attendance', [
+      'toggleAttendance',
+      'clearRecordOperation',
+      'clockIn',
+      'clockOut'
+    ]),
+    
+    getStatusColor(status) {
+      const colors = {
+        present: 'success',
+        absent: 'error',
+        late: 'warning',
+        active: 'primary',
+        on_break: 'info',
+        clocked_out: 'grey'
+      }
+      return colors[status] || 'grey'
+    },
+    
+    getStatusTextColor(status) {
+      return 'white'
+    },
+    
+    getStatusIcon(status) {
+      const icons = {
+        present: 'mdi-check-circle',
+        absent: 'mdi-close-circle',
+        late: 'mdi-clock-alert',
+        active: 'mdi-account-clock',
+        on_break: 'mdi-coffee',
+        clocked_out: 'mdi-logout'
+      }
+      return icons[status] || 'mdi-help-circle'
+    },
+    
+    async retryLastOperation(recordId) {
+      // Clear the error status and retry the last known operation
+      // In a real app, you'd store the last operation details
+      this.clearRecordOperation(recordId)
+      
+      // For demo purposes, we'll just toggle to present
+      // In production, you'd store the intended operation
+      await this.toggleAttendance(recordId, 'present')
+    }
+  }
+}
+</script>
+
+<style scoped>
+.opacity-60 {
+  opacity: 0.6;
+}
+
+.gap-2 > * {
+  margin-right: 8px;
+}
+
+.gap-2 > *:last-child {
+  margin-right: 0;
+}
+</style>
\ No newline at end of file
diff --git a/repository_after/src/components/BulkOperations.vue b/repository_after/src/components/BulkOperations.vue
new file mode 100644
index 0000000..bd6623b
--- /dev/null
+++ b/repository_after/src/components/BulkOperations.vue
@@ -0,0 +1,295 @@
+<template>
+  <v-row class="mt-4">
+    <v-col cols="12">
+      <v-card>
+        <v-card-title>
+          Bulk Operations
+          <v-spacer></v-spacer>
+          <v-chip
+            v-if="bulkOperations.status === 'loading'"
+            color="primary"
+            text-color="white"
+            small
+          >
+            <v-progress-circular
+              indeterminate
+              size="16"
+              width="2"
+              class="mr-2"
+            ></v-progress-circular>
+            Processing...
+          </v-chip>
+        </v-card-title>
+        
+        <v-card-text>
+          <v-row>
+            <!-- Quick actions -->
+            <v-col cols="12" md="6">
+              <v-subheader>Quick Actions</v-subheader>
+              <div class="d-flex flex-wrap gap-2">
+                <v-btn
+                  color="success"
+                  :disabled="bulkOperations.status === 'loading'"
+                  @click="markAllPresent"
+                >
+                  <v-icon left>mdi-check-all</v-icon>
+                  Mark All Present
+                </v-btn>
+                
+                <v-btn
+                  color="warning"
+                  :disabled="bulkOperations.status === 'loading'"
+                  @click="markAbsentAsLate"
+                >
+                  <v-icon left>mdi-clock-alert</v-icon>
+                  Absent â†’ Late
+                </v-btn>
+                
+                <v-btn
+                  color="primary"
+                  outlined
+                  :disabled="bulkOperations.status === 'loading'"
+                  @click="simulateNetworkIssue"
+                >
+                  <v-icon left>mdi-wifi-off</v-icon>
+                  Test Network Failure
+                </v-btn>
+              </div>
+            </v-col>
+            
+            <!-- Custom bulk operation -->
+            <v-col cols="12" md="6">
+              <v-subheader>Custom Bulk Update</v-subheader>
+              <div class="d-flex align-center gap-2">
+                <v-select
+                  v-model="selectedEmployees"
+                  :items="employeeOptions"
+                  item-text="name"
+                  item-value="id"
+                  multiple
+                  chips
+                  deletable-chips
+                  label="Select Employees"
+                  dense
+                  outlined
+                  class="flex-grow-1"
+                ></v-select>
+                
+                <v-select
+                  v-model="bulkStatus"
+                  :items="statusOptions"
+                  label="Status"
+                  dense
+                  outlined
+                  style="min-width: 120px;"
+                ></v-select>
+                
+                <v-btn
+                  color="primary"
+                  :disabled="!canPerformBulkUpdate || bulkOperations.status === 'loading'"
+                  @click="performCustomBulkUpdate"
+                >
+                  Update
+                </v-btn>
+              </div>
+            </v-col>
+          </v-row>
+          
+          <!-- Bulk operation status -->
+          <v-row v-if="bulkOperations.status === 'error'" class="mt-2">
+            <v-col cols="12">
+              <v-alert
+                type="error"
+                dismissible
+                @input="clearBulkError"
+              >
+                <div class="d-flex align-center">
+                  <div class="flex-grow-1">
+                    <strong>Bulk Operation Failed</strong>
+                    <div>{{ bulkOperations.lastErrorMessage }}</div>
+                  </div>
+                  <v-btn
+                    color="white"
+                    text
+                    small
+                    @click="retryLastBulkOperation"
+                  >
+                    Retry
+                  </v-btn>
+                </div>
+              </v-alert>
+            </v-col>
+          </v-row>
+          
+          <!-- Success feedback -->
+          <v-row v-if="bulkOperations.status === 'success'" class="mt-2">
+            <v-col cols="12">
+              <v-alert
+                type="success"
+                dismissible
+                @input="clearBulkSuccess"
+              >
+                Bulk operation completed successfully!
+              </v-alert>
+            </v-col>
+          </v-row>
+        </v-card-text>
+      </v-card>
+    </v-col>
+  </v-row>
+</template>
+
+<script>
+import { mapGetters, mapActions } from 'vuex'
+import mockApi from '@/services/mockApi'
+
+export default {
+  name: 'BulkOperations',
+  
+  data() {
+    return {
+      selectedEmployees: [],
+      bulkStatus: 'present',
+      lastBulkOperation: null,
+      
+      statusOptions: [
+        { text: 'Present', value: 'present' },
+        { text: 'Absent', value: 'absent' },
+        { text: 'Late', value: 'late' }
+      ]
+    }
+  },
+  
+  computed: {
+    ...mapGetters('attendance', [
+      'allRecords',
+      'bulkOperations'
+    ]),
+    
+    employeeOptions() {
+      return this.allRecords.map(record => ({
+        id: record.id,
+        name: `${record.employeeName} (${record.employeeId})`
+      }))
+    },
+    
+    canPerformBulkUpdate() {
+      return this.selectedEmployees.length > 0 && this.bulkStatus
+    }
+  },
+  
+  methods: {
+    ...mapActions('attendance', [
+      'bulkUpdateAttendance',
+      'addNotification'
+    ]),
+    
+    async markAllPresent() {
+      const updates = this.allRecords
+        .filter(record => record.status !== 'present')
+        .map(record => ({
+          id: record.id,
+          status: 'present'
+        }))
+      
+      if (updates.length === 0) {
+        this.addNotification({
+          type: 'info',
+          message: 'All employees are already marked as present',
+          timeout: 3000
+        })
+        return
+      }
+      
+      this.lastBulkOperation = { type: 'markAllPresent', updates }
+      await this.bulkUpdateAttendance(updates)
+    },
+    
+    async markAbsentAsLate() {
+      const updates = this.allRecords
+        .filter(record => record.status === 'absent')
+        .map(record => ({
+          id: record.id,
+          status: 'late'
+        }))
+      
+      if (updates.length === 0) {
+        this.addNotification({
+          type: 'info',
+          message: 'No absent employees to mark as late',
+          timeout: 3000
+        })
+        return
+      }
+      
+      this.lastBulkOperation = { type: 'markAbsentAsLate', updates }
+      await this.bulkUpdateAttendance(updates)
+    },
+    
+    async performCustomBulkUpdate() {
+      const updates = this.selectedEmployees.map(employeeId => ({
+        id: employeeId,
+        status: this.bulkStatus
+      }))
+      
+      this.lastBulkOperation = { type: 'custom', updates }
+      await this.bulkUpdateAttendance(updates)
+      
+      // Clear selection after successful operation
+      if (this.bulkOperations.status === 'success') {
+        this.selectedEmployees = []
+      }
+    },
+    
+    async simulateNetworkIssue() {
+      // Temporarily increase failure rate to simulate network issues
+      const originalFailureRate = mockApi.failureRate
+      mockApi.setFailureRate(0.8) // 80% failure rate
+      
+      this.addNotification({
+        type: 'info',
+        message: 'Simulating network issues (80% failure rate)',
+        timeout: 3000
+      })
+      
+      // Perform a bulk operation that will likely fail
+      await this.markAllPresent()
+      
+      // Reset failure rate after a delay
+      setTimeout(() => {
+        mockApi.setFailureRate(originalFailureRate)
+        this.addNotification({
+          type: 'info',
+          message: 'Network simulation ended - normal failure rate restored',
+          timeout: 3000
+        })
+      }, 5000)
+    },
+    
+    async retryLastBulkOperation() {
+      if (this.lastBulkOperation) {
+        await this.bulkUpdateAttendance(this.lastBulkOperation.updates)
+      }
+    },
+    
+    clearBulkError() {
+      // The error will be cleared when the next operation starts
+    },
+    
+    clearBulkSuccess() {
+      // The success status will be cleared when the next operation starts
+    }
+  }
+}
+</script>
+
+<style scoped>
+.gap-2 > * {
+  margin-right: 8px;
+  margin-bottom: 8px;
+}
+
+.gap-2 > *:last-child {
+  margin-right: 0;
+}
+</style>
\ No newline at end of file
diff --git a/repository_after/src/components/FilterPanel.vue b/repository_after/src/components/FilterPanel.vue
new file mode 100644
index 0000000..96ac0d4
--- /dev/null
+++ b/repository_after/src/components/FilterPanel.vue
@@ -0,0 +1,278 @@
+<template>
+  <v-card class="mb-4">
+    <v-card-title>
+      <v-icon left>mdi-filter</v-icon>
+      Filters
+      <v-spacer></v-spacer>
+      <v-btn
+        v-if="hasActiveFilters"
+        text
+        small
+        color="primary"
+        @click="clearAllFilters"
+      >
+        <v-icon left small>mdi-filter-remove</v-icon>
+        Clear All
+      </v-btn>
+    </v-card-title>
+    
+    <v-card-text>
+      <v-row>
+        <!-- Department Filter -->
+        <v-col cols="12" md="3">
+          <v-select
+            v-model="selectedDepartment"
+            :items="departmentOptions"
+            label="Department"
+            clearable
+            outlined
+            dense
+            @change="updateDepartmentFilter"
+          >
+            <template v-slot:prepend-inner>
+              <v-icon>mdi-office-building</v-icon>
+            </template>
+          </v-select>
+        </v-col>
+        
+        <!-- Status Filter -->
+        <v-col cols="12" md="3">
+          <v-select
+            v-model="selectedStatus"
+            :items="statusOptions"
+            label="Status"
+            clearable
+            outlined
+            dense
+            @change="updateStatusFilter"
+          >
+            <template v-slot:prepend-inner>
+              <v-icon>mdi-account-check</v-icon>
+            </template>
+          </v-select>
+        </v-col>
+        
+        <!-- Date Range Filter -->
+        <v-col cols="12" md="6">
+          <v-row>
+            <v-col cols="6">
+              <v-text-field
+                v-model="startDate"
+                label="Start Date"
+                type="date"
+                outlined
+                dense
+                @change="updateDateRangeFilter"
+              >
+                <template v-slot:prepend-inner>
+                  <v-icon>mdi-calendar-start</v-icon>
+                </template>
+              </v-text-field>
+            </v-col>
+            <v-col cols="6">
+              <v-text-field
+                v-model="endDate"
+                label="End Date"
+                type="date"
+                outlined
+                dense
+                @change="updateDateRangeFilter"
+              >
+                <template v-slot:prepend-inner>
+                  <v-icon>mdi-calendar-end</v-icon>
+                </template>
+              </v-text-field>
+            </v-col>
+          </v-row>
+        </v-col>
+      </v-row>
+      
+      <!-- Active Filters Display -->
+      <v-row v-if="hasActiveFilters" class="mt-2">
+        <v-col cols="12">
+          <v-subheader class="pl-0">Active Filters:</v-subheader>
+          <div class="d-flex flex-wrap gap-2">
+            <v-chip
+              v-if="selectedDepartment"
+              small
+              close
+              color="primary"
+              @click:close="clearDepartmentFilter"
+            >
+              <v-icon left small>mdi-office-building</v-icon>
+              {{ selectedDepartment }}
+            </v-chip>
+            
+            <v-chip
+              v-if="selectedStatus"
+              small
+              close
+              :color="getStatusColor(selectedStatus)"
+              @click:close="clearStatusFilter"
+            >
+              <v-icon left small>{{ getStatusIcon(selectedStatus) }}</v-icon>
+              {{ selectedStatus.replace('_', ' ').toUpperCase() }}
+            </v-chip>
+            
+            <v-chip
+              v-if="startDate || endDate"
+              small
+              close
+              color="info"
+              @click:close="clearDateRangeFilter"
+            >
+              <v-icon left small>mdi-calendar-range</v-icon>
+              {{ formatDateRange }}
+            </v-chip>
+          </div>
+        </v-col>
+      </v-row>
+    </v-card-text>
+  </v-card>
+</template>
+
+<script>
+import { mapGetters, mapActions } from 'vuex'
+
+export default {
+  name: 'FilterPanel',
+  
+  data() {
+    return {
+      selectedDepartment: null,
+      selectedStatus: null,
+      startDate: null,
+      endDate: null,
+      
+      statusOptions: [
+        { text: 'Present', value: 'present' },
+        { text: 'Absent', value: 'absent' },
+        { text: 'Late', value: 'late' },
+        { text: 'Active', value: 'active' },
+        { text: 'On Break', value: 'on_break' },
+        { text: 'Clocked Out', value: 'clocked_out' }
+      ]
+    }
+  },
+  
+  computed: {
+    ...mapGetters('attendance', [
+      'departments',
+      'currentFilters'
+    ]),
+    
+    departmentOptions() {
+      return this.departments.map(dept => ({
+        text: dept,
+        value: dept
+      }))
+    },
+    
+    hasActiveFilters() {
+      return this.selectedDepartment || 
+             this.selectedStatus || 
+             this.startDate || 
+             this.endDate
+    },
+    
+    formatDateRange() {
+      if (this.startDate && this.endDate) {
+        return `${this.startDate} to ${this.endDate}`
+      } else if (this.startDate) {
+        return `From ${this.startDate}`
+      } else if (this.endDate) {
+        return `Until ${this.endDate}`
+      }
+      return ''
+    }
+  },
+  
+  watch: {
+    currentFilters: {
+      handler(newFilters) {
+        this.selectedDepartment = newFilters.department
+        this.selectedStatus = newFilters.status
+        this.startDate = newFilters.dateRange.start
+        this.endDate = newFilters.dateRange.end
+      },
+      immediate: true,
+      deep: true
+    }
+  },
+  
+  methods: {
+    ...mapActions('attendance', [
+      'setDepartmentFilter',
+      'setStatusFilter', 
+      'setDateRangeFilter',
+      'clearFilters'
+    ]),
+    
+    updateDepartmentFilter() {
+      this.setDepartmentFilter(this.selectedDepartment)
+    },
+    
+    updateStatusFilter() {
+      this.setStatusFilter(this.selectedStatus)
+    },
+    
+    updateDateRangeFilter() {
+      this.setDateRangeFilter({
+        start: this.startDate,
+        end: this.endDate
+      })
+    },
+    
+    clearDepartmentFilter() {
+      this.selectedDepartment = null
+      this.updateDepartmentFilter()
+    },
+    
+    clearStatusFilter() {
+      this.selectedStatus = null
+      this.updateStatusFilter()
+    },
+    
+    clearDateRangeFilter() {
+      this.startDate = null
+      this.endDate = null
+      this.updateDateRangeFilter()
+    },
+    
+    clearAllFilters() {
+      this.clearFilters()
+    },
+    
+    getStatusColor(status) {
+      const colors = {
+        present: 'success',
+        absent: 'error',
+        late: 'warning',
+        active: 'primary',
+        on_break: 'info',
+        clocked_out: 'grey'
+      }
+      return colors[status] || 'grey'
+    },
+    
+    getStatusIcon(status) {
+      const icons = {
+        present: 'mdi-check-circle',
+        absent: 'mdi-close-circle',
+        late: 'mdi-clock-alert',
+        active: 'mdi-account-clock',
+        on_break: 'mdi-coffee',
+        clocked_out: 'mdi-logout'
+      }
+      return icons[status] || 'mdi-help-circle'
+    }
+  }
+}
+</script>
+
+<style scoped>
+.gap-2 > * {
+  margin-right: 8px;
+  margin-bottom: 4px;
+}
+</style>
\ No newline at end of file
diff --git a/repository_after/src/components/NotificationSystem.vue b/repository_after/src/components/NotificationSystem.vue
new file mode 100644
index 0000000..85d01c4
--- /dev/null
+++ b/repository_after/src/components/NotificationSystem.vue
@@ -0,0 +1,198 @@
+<template>
+  <div>
+    <!-- Snackbars for notifications -->
+    <v-snackbar
+      v-for="notification in pendingNotifications"
+      :key="notification.id"
+      v-model="notification.show"
+      :color="getNotificationColor(notification.type)"
+      :timeout="notification.persistent ? -1 : (notification.timeout || 5000)"
+      :top="true"
+      :right="true"
+      :multi-line="notification.message.length > 50"
+      class="notification-snackbar"
+      :style="{ 'margin-top': getNotificationOffset(notification) + 'px' }"
+    >
+      <div class="d-flex align-center">
+        <v-icon class="mr-2">{{ getNotificationIcon(notification.type) }}</v-icon>
+        <div class="flex-grow-1">
+          {{ notification.message }}
+        </div>
+        
+        <!-- Action button -->
+        <v-btn
+          v-if="notification.action"
+          text
+          small
+          color="white"
+          class="ml-2"
+          @click="handleNotificationAction(notification)"
+        >
+          {{ notification.action.text }}
+        </v-btn>
+        
+        <!-- Close button for persistent notifications -->
+        <v-btn
+          v-if="notification.persistent"
+          icon
+          small
+          color="white"
+          @click="dismissNotification(notification.id)"
+        >
+          <v-icon small>mdi-close</v-icon>
+        </v-btn>
+      </div>
+    </v-snackbar>
+    
+    <!-- Alert for critical errors -->
+    <v-alert
+      v-for="notification in criticalNotifications"
+      :key="`alert-${notification.id}`"
+      :type="notification.type"
+      dismissible
+      prominent
+      class="ma-4"
+      @input="dismissNotification(notification.id)"
+    >
+      <template v-slot:prepend>
+        <v-icon large>{{ getNotificationIcon(notification.type) }}</v-icon>
+      </template>
+      
+      <div class="d-flex align-center">
+        <div class="flex-grow-1">
+          <div class="headline">{{ getNotificationTitle(notification.type) }}</div>
+          <div>{{ notification.message }}</div>
+        </div>
+        
+        <v-btn
+          v-if="notification.action"
+          :color="notification.type"
+          outlined
+          @click="handleNotificationAction(notification)"
+        >
+          {{ notification.action.text }}
+        </v-btn>
+      </div>
+    </v-alert>
+  </div>
+</template>
+
+<script>
+import { mapGetters, mapActions } from 'vuex'
+
+export default {
+  name: 'NotificationSystem',
+  
+  data() {
+    return {
+      visibleNotifications: new Set()
+    }
+  },
+  
+  computed: {
+    ...mapGetters('attendance', [
+      'pendingNotifications'
+    ]),
+    
+    // Separate critical notifications that should be shown as alerts
+    criticalNotifications() {
+      return this.pendingNotifications.filter(n => 
+        n.type === 'error' && n.persistent && n.critical
+      )
+    },
+    
+    // Regular notifications shown as snackbars
+    regularNotifications() {
+      return this.pendingNotifications.filter(n => 
+        !(n.type === 'error' && n.persistent && n.critical)
+      )
+    }
+  },
+  
+  watch: {
+    pendingNotifications: {
+      handler(newNotifications) {
+        // Auto-show new notifications
+        newNotifications.forEach(notification => {
+          if (!this.visibleNotifications.has(notification.id)) {
+            this.$set(notification, 'show', true)
+            this.visibleNotifications.add(notification.id)
+          }
+        })
+        
+        // Clean up dismissed notifications
+        this.visibleNotifications.forEach(id => {
+          if (!newNotifications.find(n => n.id === id)) {
+            this.visibleNotifications.delete(id)
+          }
+        })
+      },
+      immediate: true,
+      deep: true
+    }
+  },
+  
+  methods: {
+    ...mapActions('attendance', [
+      'dismissNotification'
+    ]),
+    
+    getNotificationColor(type) {
+      const colors = {
+        success: 'success',
+        error: 'error',
+        warning: 'warning',
+        info: 'info'
+      }
+      return colors[type] || 'info'
+    },
+    
+    getNotificationIcon(type) {
+      const icons = {
+        success: 'mdi-check-circle',
+        error: 'mdi-alert-circle',
+        warning: 'mdi-alert',
+        info: 'mdi-information'
+      }
+      return icons[type] || 'mdi-information'
+    },
+    
+    getNotificationTitle(type) {
+      const titles = {
+        success: 'Success',
+        error: 'Error',
+        warning: 'Warning',
+        info: 'Information'
+      }
+      return titles[type] || 'Notification'
+    },
+    
+    getNotificationOffset(notification) {
+      // Calculate vertical offset for stacked notifications
+      const index = this.regularNotifications.findIndex(n => n.id === notification.id)
+      return index * 80 // 80px spacing between notifications
+    },
+    
+    handleNotificationAction(notification) {
+      if (notification.action && notification.action.callback) {
+        notification.action.callback()
+      }
+      
+      // Dismiss the notification after action
+      this.dismissNotification(notification.id)
+    }
+  }
+}
+</script>
+
+<style scoped>
+.notification-snackbar {
+  position: fixed !important;
+  z-index: 9999;
+}
+
+/* Ensure notifications stack properly */
+.notification-snackbar .v-snack__wrapper {
+  margin-bottom: 8px;
+}
+</style>
\ No newline at end of file
diff --git a/repository_after/src/components/RetryDialog.vue b/repository_after/src/components/RetryDialog.vue
new file mode 100644
index 0000000..9531461
--- /dev/null
+++ b/repository_after/src/components/RetryDialog.vue
@@ -0,0 +1,152 @@
+<template>
+  <v-dialog
+    :value="value"
+    @input="$emit('input', $event)"
+    max-width="600px"
+    persistent
+  >
+    <v-card>
+      <v-card-title class="headline">
+        <v-icon left color="error">mdi-alert-circle</v-icon>
+        Failed Operations
+        <v-spacer></v-spacer>
+        <v-chip color="error" text-color="white" small>
+          {{ retryQueue.length }} failed
+        </v-chip>
+      </v-card-title>
+      
+      <v-card-text>
+        <div v-if="retryQueue.length === 0" class="text-center py-4">
+          <v-icon size="64" color="success">mdi-check-circle</v-icon>
+          <div class="mt-2 text-h6">All operations completed successfully!</div>
+        </div>
+        
+        <div v-else>
+          <p class="mb-4">
+            The following operations failed and can be retried:
+          </p>
+          
+          <v-list>
+            <v-list-item
+              v-for="operation in retryQueue"
+              :key="operation.id"
+              class="px-0"
+            >
+              <v-list-item-avatar>
+                <v-icon color="error">mdi-alert-circle</v-icon>
+              </v-list-item-avatar>
+              
+              <v-list-item-content>
+                <v-list-item-title>
+                  {{ operation.description }}
+                </v-list-item-title>
+                <v-list-item-subtitle>
+                  Failed {{ getTimeAgo(operation.timestamp) }}
+                </v-list-item-subtitle>
+              </v-list-item-content>
+              
+              <v-list-item-action>
+                <v-btn
+                  color="primary"
+                  small
+                  outlined
+                  @click="$emit('retry', operation)"
+                >
+                  <v-icon left small>mdi-refresh</v-icon>
+                  Retry
+                </v-btn>
+              </v-list-item-action>
+            </v-list-item>
+          </v-list>
+        </div>
+      </v-card-text>
+      
+      <v-card-actions>
+        <v-btn
+          v-if="retryQueue.length > 0"
+          color="primary"
+          @click="retryAll"
+        >
+          <v-icon left>mdi-refresh-circle</v-icon>
+          Retry All
+        </v-btn>
+        
+        <v-btn
+          v-if="retryQueue.length > 0"
+          color="error"
+          text
+          @click="$emit('clear')"
+        >
+          <v-icon left>mdi-delete</v-icon>
+          Clear All
+        </v-btn>
+        
+        <v-spacer></v-spacer>
+        
+        <v-btn
+          color="grey darken-1"
+          text
+          @click="$emit('input', false)"
+        >
+          Close
+        </v-btn>
+      </v-card-actions>
+    </v-card>
+  </v-dialog>
+</template>
+
+<script>
+export default {
+  name: 'RetryDialog',
+  
+  props: {
+    value: {
+      type: Boolean,
+      default: false
+    },
+    retryQueue: {
+      type: Array,
+      default: () => []
+    }
+  },
+  
+  methods: {
+    getTimeAgo(timestamp) {
+      const now = Date.now()
+      const diff = now - timestamp
+      const seconds = Math.floor(diff / 1000)
+      const minutes = Math.floor(seconds / 60)
+      const hours = Math.floor(minutes / 60)
+      
+      if (hours > 0) {
+        return `${hours} hour${hours > 1 ? 's' : ''} ago`
+      } else if (minutes > 0) {
+        return `${minutes} minute${minutes > 1 ? 's' : ''} ago`
+      } else {
+        return `${seconds} second${seconds > 1 ? 's' : ''} ago`
+      }
+    },
+    
+    async retryAll() {
+      // Retry all operations in sequence
+      for (const operation of this.retryQueue) {
+        await new Promise(resolve => {
+          this.$emit('retry', operation)
+          // Small delay between retries to avoid overwhelming the system
+          setTimeout(resolve, 100)
+        })
+      }
+    }
+  }
+}
+</script>
+
+<style scoped>
+.v-list-item {
+  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
+}
+
+.v-list-item:last-child {
+  border-bottom: none;
+}
+</style>
\ No newline at end of file
diff --git a/repository_after/src/main.js b/repository_after/src/main.js
new file mode 100644
index 0000000..fdc2a1a
--- /dev/null
+++ b/repository_after/src/main.js
@@ -0,0 +1,12 @@
+import Vue from 'vue'
+import App from './App.vue'
+import store from './store'
+import vuetify from './plugins/vuetify'
+
+Vue.config.productionTip = false
+
+new Vue({
+  store,
+  vuetify,
+  render: h => h(App)
+}).$mount('#app')
\ No newline at end of file
diff --git a/repository_after/src/plugins/vuetify.js b/repository_after/src/plugins/vuetify.js
new file mode 100644
index 0000000..9fa72c7
--- /dev/null
+++ b/repository_after/src/plugins/vuetify.js
@@ -0,0 +1,21 @@
+import Vue from 'vue'
+import Vuetify from 'vuetify'
+import 'vuetify/dist/vuetify.min.css'
+
+Vue.use(Vuetify)
+
+export default new Vuetify({
+  theme: {
+    themes: {
+      light: {
+        primary: '#1976D2',
+        secondary: '#424242',
+        accent: '#82B1FF',
+        error: '#FF5252',
+        info: '#2196F3',
+        success: '#4CAF50',
+        warning: '#FFC107'
+      }
+    }
+  }
+})
\ No newline at end of file
diff --git a/repository_after/src/services/mockApi.js b/repository_after/src/services/mockApi.js
new file mode 100644
index 0000000..fc228be
--- /dev/null
+++ b/repository_after/src/services/mockApi.js
@@ -0,0 +1,302 @@
+/**
+ * Mock API service that simulates network conditions with configurable delays and failure rates
+ */
+class MockApiService {
+  constructor(options = {}) {
+    this.baseDelay = options.baseDelay || 500
+    this.failureRate = options.failureRate || 0.2
+    this.networkJitter = options.networkJitter || 200
+    
+    // Mock server state
+    this.serverState = {
+      attendanceRecords: [
+        { 
+          id: 1, 
+          employeeId: 'EMP001', 
+          employeeName: 'John Doe', 
+          department: 'Engineering',
+          date: '2026-01-23', 
+          status: 'present', 
+          checkInTime: '09:00',
+          checkOutTime: '17:30',
+          shiftStart: '09:00',
+          shiftEnd: '17:00'
+        },
+        { 
+          id: 2, 
+          employeeId: 'EMP002', 
+          employeeName: 'Jane Smith', 
+          department: 'Marketing',
+          date: '2026-01-23', 
+          status: 'absent', 
+          checkInTime: null,
+          checkOutTime: null,
+          shiftStart: '09:00',
+          shiftEnd: '17:00'
+        },
+        { 
+          id: 3, 
+          employeeId: 'EMP003', 
+          employeeName: 'Bob Johnson', 
+          department: 'Engineering',
+          date: '2026-01-23', 
+          status: 'active', 
+          checkInTime: '09:15',
+          checkOutTime: null,
+          shiftStart: '09:00',
+          shiftEnd: '17:00'
+        },
+        { 
+          id: 4, 
+          employeeId: 'EMP004', 
+          employeeName: 'Alice Brown', 
+          department: 'HR',
+          date: '2026-01-23', 
+          status: 'late', 
+          checkInTime: '09:30',
+          checkOutTime: '17:45',
+          shiftStart: '09:00',
+          shiftEnd: '17:00'
+        },
+        { 
+          id: 5, 
+          employeeId: 'EMP005', 
+          employeeName: 'Charlie Wilson', 
+          department: 'Sales',
+          date: '2026-01-23', 
+          status: 'on_break', 
+          checkInTime: '08:45',
+          checkOutTime: null,
+          shiftStart: '09:00',
+          shiftEnd: '17:00'
+        }
+      ]
+    }
+  }
+
+  /**
+   * Simulate network delay with jitter
+   */
+  _simulateNetworkDelay() {
+    const jitter = Math.random() * this.networkJitter
+    return this.baseDelay + jitter
+  }
+
+  /**
+   * Simulate network failure based on failure rate
+   */
+  _shouldSimulateFailure() {
+    return Math.random() < this.failureRate
+  }
+
+  /**
+   * Create a promise that resolves or rejects based on network simulation
+   */
+  _createNetworkPromise(successCallback, errorMessage = 'Network error') {
+    return new Promise((resolve, reject) => {
+      const delay = this._simulateNetworkDelay()
+      
+      setTimeout(() => {
+        if (this._shouldSimulateFailure()) {
+          reject(new Error(errorMessage))
+        } else {
+          resolve(successCallback())
+        }
+      }, delay)
+    })
+  }
+
+  /**
+   * Fetch all attendance records
+   */
+  fetchAttendanceRecords() {
+    return this._createNetworkPromise(
+      () => ({ data: [...this.serverState.attendanceRecords] }),
+      'Failed to fetch attendance records'
+    )
+  }
+
+  /**
+   * Toggle attendance status for a specific record
+   */
+  toggleAttendance(recordId, newStatus) {
+    return this._createNetworkPromise(
+      () => {
+        const record = this.serverState.attendanceRecords.find(r => r.id === recordId)
+        if (!record) {
+          throw new Error('Record not found')
+        }
+        
+        // Update server state
+        record.status = newStatus
+        if (newStatus === 'present' && !record.checkInTime) {
+          record.checkInTime = new Date().toLocaleTimeString('en-US', { 
+            hour12: false, 
+            hour: '2-digit', 
+            minute: '2-digit' 
+          })
+        } else if (newStatus === 'absent') {
+          record.checkInTime = null
+        }
+        
+        return { data: { ...record } }
+      },
+      'Failed to update attendance status'
+    )
+  }
+
+  /**
+   * Bulk update multiple attendance records
+   */
+  bulkUpdateAttendance(updates) {
+    return this._createNetworkPromise(
+      () => {
+        const updatedRecords = []
+        
+        updates.forEach(update => {
+          const record = this.serverState.attendanceRecords.find(r => r.id === update.id)
+          if (record) {
+            record.status = update.status
+            if (update.status === 'present' && !record.checkInTime) {
+              record.checkInTime = new Date().toLocaleTimeString('en-US', { 
+                hour12: false, 
+                hour: '2-digit', 
+                minute: '2-digit' 
+              })
+            } else if (update.status === 'absent') {
+              record.checkInTime = null
+            }
+            updatedRecords.push({ ...record })
+          }
+        })
+        
+        return { data: updatedRecords }
+      },
+      'Failed to bulk update attendance records'
+    )
+  }
+
+  /**
+   * Clock in an employee
+   */
+  clockIn(recordId, time) {
+    return this._createNetworkPromise(
+      () => {
+        const record = this.serverState.attendanceRecords.find(r => r.id === recordId)
+        if (!record) {
+          throw new Error('Record not found')
+        }
+        
+        if (record.status === 'active') {
+          throw new Error('Employee is already clocked in')
+        }
+        
+        // Check for shift conflicts
+        const conflicts = this._checkShiftConflicts(record.employeeId, record.date, time, record.shiftEnd)
+        if (conflicts.length > 0) {
+          throw new Error('Shift conflict detected')
+        }
+        
+        record.status = 'active'
+        record.checkInTime = time || new Date().toLocaleTimeString('en-US', { 
+          hour12: false, 
+          hour: '2-digit', 
+          minute: '2-digit' 
+        })
+        
+        return { data: { ...record } }
+      },
+      'Failed to clock in'
+    )
+  }
+
+  /**
+   * Clock out an employee
+   */
+  clockOut(recordId, time) {
+    return this._createNetworkPromise(
+      () => {
+        const record = this.serverState.attendanceRecords.find(r => r.id === recordId)
+        if (!record) {
+          throw new Error('Record not found')
+        }
+        
+        if (record.status !== 'active') {
+          throw new Error('Employee is not currently clocked in')
+        }
+        
+        record.status = 'clocked_out'
+        record.checkOutTime = time || new Date().toLocaleTimeString('en-US', { 
+          hour12: false, 
+          hour: '2-digit', 
+          minute: '2-digit' 
+        })
+        
+        return { data: { ...record } }
+      },
+      'Failed to clock out'
+    )
+  }
+
+  /**
+   * Check for shift conflicts
+   */
+  _checkShiftConflicts(employeeId, date, shiftStart, shiftEnd) {
+    const conflicts = []
+    
+    this.serverState.attendanceRecords.forEach(record => {
+      if (record.employeeId === employeeId && record.date === date && record.status === 'active') {
+        if (record.shiftStart && record.shiftEnd) {
+          const existingStart = new Date(`${date} ${record.shiftStart}`)
+          const existingEnd = new Date(`${date} ${record.shiftEnd}`)
+          const newStart = new Date(`${date} ${shiftStart}`)
+          const newEnd = new Date(`${date} ${shiftEnd}`)
+          
+          // Check for overlap
+          if (newStart < existingEnd && newEnd > existingStart) {
+            conflicts.push(record)
+          }
+        }
+      }
+    })
+    
+    return conflicts
+  }
+
+  /**
+   * Get current server state (for testing purposes)
+   */
+  getServerState() {
+    return { ...this.serverState }
+  }
+
+  /**
+   * Reset server state to initial values
+   */
+  resetServerState() {
+    this.serverState.attendanceRecords = [
+      { id: 1, employeeId: 'EMP001', employeeName: 'John Doe', date: '2026-01-23', status: 'present', checkInTime: '09:00' },
+      { id: 2, employeeId: 'EMP002', employeeName: 'Jane Smith', date: '2026-01-23', status: 'absent', checkInTime: null },
+      { id: 3, employeeId: 'EMP003', employeeName: 'Bob Johnson', date: '2026-01-23', status: 'present', checkInTime: '09:15' },
+      { id: 4, employeeId: 'EMP004', employeeName: 'Alice Brown', date: '2026-01-23', status: 'late', checkInTime: '09:30' },
+      { id: 5, employeeId: 'EMP005', employeeName: 'Charlie Wilson', date: '2026-01-23', status: 'present', checkInTime: '08:45' }
+    ]
+  }
+
+  /**
+   * Configure failure rate for testing
+   */
+  setFailureRate(rate) {
+    this.failureRate = Math.max(0, Math.min(1, rate))
+  }
+
+  /**
+   * Configure base delay for testing
+   */
+  setBaseDelay(delay) {
+    this.baseDelay = Math.max(0, delay)
+  }
+}
+
+// Export singleton instance
+export default new MockApiService()
\ No newline at end of file
diff --git a/repository_after/src/store/index.js b/repository_after/src/store/index.js
new file mode 100644
index 0000000..cb3add1
--- /dev/null
+++ b/repository_after/src/store/index.js
@@ -0,0 +1,12 @@
+import Vue from 'vue'
+import Vuex from 'vuex'
+import attendanceModule from './modules/attendance'
+
+Vue.use(Vuex)
+
+export default new Vuex.Store({
+  modules: {
+    attendance: attendanceModule
+  },
+  strict: process.env.NODE_ENV !== 'production'
+})
\ No newline at end of file
diff --git a/repository_after/src/store/modules/attendance.js b/repository_after/src/store/modules/attendance.js
new file mode 100644
index 0000000..df0e0c8
--- /dev/null
+++ b/repository_after/src/store/modules/attendance.js
@@ -0,0 +1,608 @@
+import mockApi from '@/services/mockApi'
+
+// State machine status constants
+export const STATUS = {
+  IDLE: 'idle',
+  LOADING: 'loading',
+  SUCCESS: 'success',
+  ERROR: 'error'
+}
+
+// Helper function to create async entity structure
+const createAsyncEntity = (initialData = null) => ({
+  data: initialData,
+  status: STATUS.IDLE,
+  lastErrorMessage: null
+})
+
+// Helper function to normalize records by ID
+const normalizeRecords = (records) => {
+  return records.reduce((acc, record) => {
+    acc[record.id] = record
+    return acc
+  }, {})
+}
+
+const state = {
+  // Normalized attendance records by ID
+  records: createAsyncEntity({}),
+  
+  // Individual record operations (for optimistic updates)
+  recordOperations: {},
+  
+  // Bulk operations
+  bulkOperations: createAsyncEntity(null),
+  
+  // UI state
+  notifications: [],
+  
+  // Retry queue for failed operations
+  retryQueue: [],
+  
+  // Filters
+  filters: {
+    department: null,
+    dateRange: {
+      start: null,
+      end: null
+    },
+    status: null
+  }
+}
+
+const getters = {
+  // Get all records as array
+  allRecords: (state) => {
+    if (!state.records.data) return []
+    let records = Object.values(state.records.data)
+    
+    // Apply filters
+    if (state.filters.department) {
+      records = records.filter(record => record.department === state.filters.department)
+    }
+    
+    if (state.filters.dateRange.start && state.filters.dateRange.end) {
+      records = records.filter(record => {
+        const recordDate = new Date(record.date)
+        const startDate = new Date(state.filters.dateRange.start)
+        const endDate = new Date(state.filters.dateRange.end)
+        return recordDate >= startDate && recordDate <= endDate
+      })
+    }
+    
+    if (state.filters.status) {
+      records = records.filter(record => record.status === state.filters.status)
+    }
+    
+    return records
+  },
+  
+  // Get record by ID
+  getRecordById: (state) => (id) => {
+    return state.records.data ? state.records.data[id] : null
+  },
+  
+  // Get records loading status
+  isLoadingRecords: (state) => {
+    return state.records.status === STATUS.LOADING
+  },
+  
+  // Get individual record operation status
+  getRecordOperationStatus: (state) => (id) => {
+    const operation = state.recordOperations[id]
+    return operation ? operation.status : STATUS.IDLE
+  },
+  
+  // Check if any operations are in progress
+  hasOperationsInProgress: (state) => {
+    return Object.values(state.recordOperations).some(op => op.status === STATUS.LOADING) ||
+           state.bulkOperations.status === STATUS.LOADING
+  },
+  
+  // Get pending notifications
+  pendingNotifications: (state) => {
+    return state.notifications.filter(n => !n.dismissed)
+  },
+  
+  // Get retry queue
+  retryQueue: (state) => state.retryQueue,
+  
+  // Get unique departments
+  departments: (state) => {
+    if (!state.records.data) return []
+    const departments = new Set()
+    Object.values(state.records.data).forEach(record => {
+      if (record.department) departments.add(record.department)
+    })
+    return Array.from(departments).sort()
+  },
+  
+  // Get total hours worked for a record
+  getTotalHours: (state) => (id) => {
+    const record = state.records.data ? state.records.data[id] : null
+    if (!record || !record.checkInTime || !record.checkOutTime) return 0
+    
+    const checkIn = new Date(`${record.date} ${record.checkInTime}`)
+    const checkOut = new Date(`${record.date} ${record.checkOutTime}`)
+    const diffMs = checkOut - checkIn
+    return Math.max(0, diffMs / (1000 * 60 * 60)) // Convert to hours
+  },
+  
+  // Get overtime hours for a record
+  getOvertimeHours: (state, getters) => (id) => {
+    const totalHours = getters.getTotalHours(id)
+    const standardHours = 8 // Standard work day
+    return Math.max(0, totalHours - standardHours)
+  },
+  
+  // Check for shift conflicts
+  getShiftConflicts: (state) => (employeeId, date, shiftStart, shiftEnd) => {
+    if (!state.records.data) return []
+    
+    const conflicts = []
+    Object.values(state.records.data).forEach(record => {
+      if (record.employeeId === employeeId && record.date === date && record.status === 'active') {
+        if (record.shiftStart && record.shiftEnd) {
+          const existingStart = new Date(`${date} ${record.shiftStart}`)
+          const existingEnd = new Date(`${date} ${record.shiftEnd}`)
+          const newStart = new Date(`${date} ${shiftStart}`)
+          const newEnd = new Date(`${date} ${shiftEnd}`)
+          
+          // Check for overlap
+          if (newStart < existingEnd && newEnd > existingStart) {
+            conflicts.push(record)
+          }
+        }
+      }
+    })
+    
+    return conflicts
+  },
+  
+  // Get current filters
+  currentFilters: (state) => state.filters
+}
+
+const mutations = {
+  // Records mutations
+  SET_RECORDS_STATUS(state, status) {
+    state.records.status = status
+  },
+  
+  SET_RECORDS_DATA(state, records) {
+    state.records.data = normalizeRecords(records)
+    state.records.status = STATUS.SUCCESS
+    state.records.lastErrorMessage = null
+  },
+  
+  SET_RECORDS_ERROR(state, errorMessage) {
+    state.records.status = STATUS.ERROR
+    state.records.lastErrorMessage = errorMessage
+  },
+  
+  // Individual record operation mutations
+  SET_RECORD_OPERATION_STATUS(state, { id, status, errorMessage = null }) {
+    Vue.set(state.recordOperations, id, {
+      status,
+      lastErrorMessage: errorMessage,
+      timestamp: Date.now()
+    })
+  },
+  
+  CLEAR_RECORD_OPERATION(state, id) {
+    Vue.delete(state.recordOperations, id)
+  },
+  
+  // Optimistic update mutations
+  OPTIMISTIC_UPDATE_RECORD(state, { id, updates, previousState }) {
+    if (state.records.data && state.records.data[id]) {
+      // Store previous state for rollback
+      Vue.set(state.recordOperations, id, {
+        ...state.recordOperations[id],
+        previousState,
+        optimisticUpdate: true
+      })
+      
+      // Apply optimistic update
+      Vue.set(state.records.data, id, {
+        ...state.records.data[id],
+        ...updates
+      })
+    }
+  },
+  
+  ROLLBACK_OPTIMISTIC_UPDATE(state, { id, previousState }) {
+    if (state.records.data && previousState) {
+      Vue.set(state.records.data, id, previousState)
+    }
+    // Clear the operation
+    Vue.delete(state.recordOperations, id)
+  },
+  
+  CONFIRM_OPTIMISTIC_UPDATE(state, { id, serverData }) {
+    if (state.records.data) {
+      Vue.set(state.records.data, id, serverData)
+    }
+    // Clear the operation
+    Vue.delete(state.recordOperations, id)
+  },
+  
+  // Bulk operations mutations
+  SET_BULK_OPERATION_STATUS(state, { status, errorMessage = null }) {
+    state.bulkOperations.status = status
+    state.bulkOperations.lastErrorMessage = errorMessage
+  },
+  
+  // Notification mutations
+  ADD_NOTIFICATION(state, notification) {
+    const id = Date.now() + Math.random()
+    state.notifications.push({
+      id,
+      ...notification,
+      dismissed: false,
+      timestamp: Date.now()
+    })
+  },
+  
+  DISMISS_NOTIFICATION(state, id) {
+    const notification = state.notifications.find(n => n.id === id)
+    if (notification) {
+      notification.dismissed = true
+    }
+  },
+  
+  CLEAR_OLD_NOTIFICATIONS(state) {
+    const cutoff = Date.now() - 30000 // 30 seconds
+    state.notifications = state.notifications.filter(n => 
+      !n.dismissed || n.timestamp > cutoff
+    )
+  },
+  
+  // Retry queue mutations
+  ADD_TO_RETRY_QUEUE(state, operation) {
+    state.retryQueue.push({
+      id: Date.now() + Math.random(),
+      ...operation,
+      timestamp: Date.now()
+    })
+  },
+  
+  REMOVE_FROM_RETRY_QUEUE(state, operationId) {
+    state.retryQueue = state.retryQueue.filter(op => op.id !== operationId)
+  },
+  
+  CLEAR_RETRY_QUEUE(state) {
+    state.retryQueue = []
+  },
+  
+  // Filter mutations
+  SET_DEPARTMENT_FILTER(state, department) {
+    state.filters.department = department
+  },
+  
+  SET_DATE_RANGE_FILTER(state, { start, end }) {
+    state.filters.dateRange.start = start
+    state.filters.dateRange.end = end
+  },
+  
+  SET_STATUS_FILTER(state, status) {
+    state.filters.status = status
+  },
+  
+  CLEAR_FILTERS(state) {
+    state.filters = {
+      department: null,
+      dateRange: { start: null, end: null },
+      status: null
+    }
+  }
+}
+
+const actions = {
+  // Fetch all attendance records
+  async fetchAttendanceRecords({ commit, dispatch }) {
+    commit('SET_RECORDS_STATUS', STATUS.LOADING)
+    
+    try {
+      const response = await mockApi.fetchAttendanceRecords()
+      commit('SET_RECORDS_DATA', response.data)
+      
+      // Clear any previous error notifications
+      dispatch('addNotification', {
+        type: 'success',
+        message: 'Attendance records loaded successfully',
+        timeout: 3000
+      })
+      
+    } catch (error) {
+      commit('SET_RECORDS_ERROR', error.message)
+      
+      // Add to retry queue
+      commit('ADD_TO_RETRY_QUEUE', {
+        action: 'fetchAttendanceRecords',
+        params: [],
+        description: 'Fetch attendance records'
+      })
+      
+      dispatch('addNotification', {
+        type: 'error',
+        message: `Failed to load attendance records: ${error.message}`,
+        persistent: true,
+        action: {
+          text: 'Retry',
+          callback: () => dispatch('fetchAttendanceRecords')
+        }
+      })
+    }
+  },
+  
+  // Toggle attendance with optimistic updates and rollback
+  async toggleAttendance({ commit, dispatch, getters }, { id, newStatus }) {
+    const currentRecord = getters.getRecordById(id)
+    if (!currentRecord) {
+      dispatch('addNotification', {
+        type: 'error',
+        message: 'Record not found'
+      })
+      return
+    }
+    
+    // Store previous state for rollback
+    const previousState = { ...currentRecord }
+    
+    // Set operation status to loading
+    commit('SET_RECORD_OPERATION_STATUS', { id, status: STATUS.LOADING })
+    
+    // Apply optimistic update
+    const optimisticUpdates = {
+      status: newStatus,
+      checkInTime: newStatus === 'present' && !currentRecord.checkInTime 
+        ? new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' })
+        : newStatus === 'absent' ? null : currentRecord.checkInTime
+    }
+    
+    commit('OPTIMISTIC_UPDATE_RECORD', {
+      id,
+      updates: optimisticUpdates,
+      previousState
+    })
+    
+    try {
+      // Make API call
+      const response = await mockApi.toggleAttendance(id, newStatus)
+      
+      // Confirm optimistic update with server data
+      commit('CONFIRM_OPTIMISTIC_UPDATE', {
+        id,
+        serverData: response.data
+      })
+      
+      dispatch('addNotification', {
+        type: 'success',
+        message: `Attendance updated for ${currentRecord.employeeName}`,
+        timeout: 3000
+      })
+      
+    } catch (error) {
+      // Rollback optimistic update
+      commit('ROLLBACK_OPTIMISTIC_UPDATE', {
+        id,
+        previousState
+      })
+      
+      commit('SET_RECORD_OPERATION_STATUS', {
+        id,
+        status: STATUS.ERROR,
+        errorMessage: error.message
+      })
+      
+      // Add to retry queue
+      commit('ADD_TO_RETRY_QUEUE', {
+        action: 'toggleAttendance',
+        params: [{ id, newStatus }],
+        description: `Toggle attendance for ${currentRecord.employeeName}`
+      })
+      
+      dispatch('addNotification', {
+        type: 'error',
+        message: `Failed to update attendance for ${currentRecord.employeeName}: ${error.message}`,
+        persistent: true,
+        action: {
+          text: 'Retry',
+          callback: () => dispatch('toggleAttendance', { id, newStatus })
+        }
+      })
+    }
+  },
+  
+  // Bulk update attendance records
+  async bulkUpdateAttendance({ commit, dispatch }, updates) {
+    commit('SET_BULK_OPERATION_STATUS', { status: STATUS.LOADING })
+    
+    try {
+      const response = await mockApi.bulkUpdateAttendance(updates)
+      
+      // Update individual records
+      response.data.forEach(record => {
+        commit('SET_RECORDS_DATA', [record])
+      })
+      
+      commit('SET_BULK_OPERATION_STATUS', { status: STATUS.SUCCESS })
+      
+      dispatch('addNotification', {
+        type: 'success',
+        message: `Successfully updated ${updates.length} attendance records`,
+        timeout: 3000
+      })
+      
+    } catch (error) {
+      commit('SET_BULK_OPERATION_STATUS', {
+        status: STATUS.ERROR,
+        errorMessage: error.message
+      })
+      
+      // Add to retry queue
+      commit('ADD_TO_RETRY_QUEUE', {
+        action: 'bulkUpdateAttendance',
+        params: [updates],
+        description: `Bulk update ${updates.length} records`
+      })
+      
+      dispatch('addNotification', {
+        type: 'error',
+        message: `Failed to bulk update attendance records: ${error.message}`,
+        persistent: true,
+        action: {
+          text: 'Retry',
+          callback: () => dispatch('bulkUpdateAttendance', updates)
+        }
+      })
+    }
+  },
+  
+  // Retry a failed operation
+  async retryOperation({ dispatch, commit }, operation) {
+    commit('REMOVE_FROM_RETRY_QUEUE', operation.id)
+    
+    // Dispatch the original action with its parameters
+    if (operation.action && operation.params) {
+      await dispatch(operation.action, ...operation.params)
+    }
+  },
+  
+  // Clear all retry operations
+  clearRetryQueue({ commit }) {
+    commit('CLEAR_RETRY_QUEUE')
+  },
+  
+  // Add notification
+  addNotification({ commit }, notification) {
+    commit('ADD_NOTIFICATION', notification)
+    
+    // Auto-dismiss non-persistent notifications
+    if (!notification.persistent && notification.timeout) {
+      setTimeout(() => {
+        commit('DISMISS_NOTIFICATION', notification.id)
+      }, notification.timeout)
+    }
+  },
+  
+  // Dismiss notification
+  dismissNotification({ commit }, id) {
+    commit('DISMISS_NOTIFICATION', id)
+  },
+  
+  // Clean up old notifications
+  cleanupNotifications({ commit }) {
+    commit('CLEAR_OLD_NOTIFICATIONS')
+  },
+  
+  // Clear record operation status
+  clearRecordOperation({ commit }, id) {
+    commit('CLEAR_RECORD_OPERATION', id)
+  },
+  
+  // Filter actions
+  setDepartmentFilter({ commit }, department) {
+    commit('SET_DEPARTMENT_FILTER', department)
+  },
+  
+  setDateRangeFilter({ commit }, { start, end }) {
+    commit('SET_DATE_RANGE_FILTER', { start, end })
+  },
+  
+  setStatusFilter({ commit }, status) {
+    commit('SET_STATUS_FILTER', status)
+  },
+  
+  clearFilters({ commit }) {
+    commit('CLEAR_FILTERS')
+  },
+  
+  // Clock in/out actions
+  async clockIn({ commit, dispatch, getters }, { id, time }) {
+    const record = getters.getRecordById(id)
+    if (!record) return
+    
+    // Set operation status to loading
+    commit('SET_RECORD_OPERATION_STATUS', { id, status: STATUS.LOADING })
+    
+    try {
+      const response = await mockApi.clockIn(id, time)
+      
+      // Update record with server data
+      commit('SET_RECORDS_DATA', [response.data])
+      commit('CLEAR_RECORD_OPERATION', id)
+      
+      dispatch('addNotification', {
+        type: 'success',
+        message: `${record.employeeName} clocked in successfully`,
+        timeout: 3000
+      })
+      
+      return true
+      
+    } catch (error) {
+      commit('SET_RECORD_OPERATION_STATUS', {
+        id,
+        status: STATUS.ERROR,
+        errorMessage: error.message
+      })
+      
+      dispatch('addNotification', {
+        type: 'error',
+        message: `Failed to clock in ${record.employeeName}: ${error.message}`,
+        persistent: true
+      })
+      
+      return false
+    }
+  },
+  
+  async clockOut({ commit, dispatch, getters }, { id, time }) {
+    const record = getters.getRecordById(id)
+    if (!record) return
+    
+    // Set operation status to loading
+    commit('SET_RECORD_OPERATION_STATUS', { id, status: STATUS.LOADING })
+    
+    try {
+      const response = await mockApi.clockOut(id, time)
+      
+      // Update record with server data
+      commit('SET_RECORDS_DATA', [response.data])
+      commit('CLEAR_RECORD_OPERATION', id)
+      
+      dispatch('addNotification', {
+        type: 'success',
+        message: `${record.employeeName} clocked out successfully`,
+        timeout: 3000
+      })
+      
+      return true
+      
+    } catch (error) {
+      commit('SET_RECORD_OPERATION_STATUS', {
+        id,
+        status: STATUS.ERROR,
+        errorMessage: error.message
+      })
+      
+      dispatch('addNotification', {
+        type: 'error',
+        message: `Failed to clock out ${record.employeeName}: ${error.message}`,
+        persistent: true
+      })
+      
+      return false
+    }
+  }
+}
+
+export default {
+  namespaced: true,
+  state,
+  getters,
+  mutations,
+  actions
+}
\ No newline at end of file
diff --git a/repository_after/vue.config.js b/repository_after/vue.config.js
new file mode 100644
index 0000000..9d9ef8f
--- /dev/null
+++ b/repository_after/vue.config.js
@@ -0,0 +1,15 @@
+const { defineConfig } = require('@vue/cli-service')
+
+module.exports = defineConfig({
+  devServer: {
+    port: 8080,
+    host: '0.0.0.0'
+  },
+  configureWebpack: {
+    resolve: {
+      alias: {
+        '@': require('path').resolve(__dirname, 'src')
+      }
+    }
+  }
+})
\ No newline at end of file
