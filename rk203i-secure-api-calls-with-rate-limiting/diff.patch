--- repository_before/telebirr_calls.ts	2026-01-29 13:53:47.474844500 +0300
+++ repository_after/telebirr_calls.ts	2026-01-29 13:49:21.328706600 +0300
@@ -1,72 +1,279 @@
 // telebirr_calls.ts
-// Original faulty implementation - no proper rate limiting, vulnerable to quantum attacks
+// Token Bucket rate limiting with signature generation
 
-// Stub DilithiumPQSigner - not properly implemented
+/**
+ * Mock Signature Implementation (Dilithium-inspired)
+ * Note: This is a simplified XOR-based mock, not a real PQ signature scheme
+ * Uses Buffer and loops for signature generation
+ */
 class DilithiumPQSigner {
+  private static readonly SEED = Buffer.from('dilithium-pq-seed-32bytes!!!!!'); // 32 bytes fixed seed
+  private static readonly SIGNATURE_SIZE = 64;
+
+  /**
+   * Sign data with XOR-based mock algorithm
+   * Deterministic for same input, but not cryptographically secure
+   */
   static sign(data: string): string {
-    return ''; // Not implemented - returns empty string
+    const dataBuffer = Buffer.from(data);
+    const signature = Buffer.alloc(this.SIGNATURE_SIZE);
+    
+    // O(1) - Fixed 64 iterations regardless of input
+    for (let i = 0; i < this.SIGNATURE_SIZE; i++) {
+      const dataIndex = i % Math.min(dataBuffer.length, 32);
+      const seedIndex = i % this.SEED.length;
+      signature[i] = (dataBuffer[dataIndex] ^ this.SEED[seedIndex] ^ (i * 7)) & 0xFF;
+    }
+    
+    return signature.toString('hex');
   }
+
+  /**
+   * Verify signature by re-signing and comparing
+   */
   static verify(data: string, signature: string): boolean {
-    return false; // Not implemented - always returns false
+    if (signature.length !== this.SIGNATURE_SIZE * 2) { // hex is 2x size
+      return false;
+    }
+    
+    const expectedSignature = this.sign(data);
+    
+    // Constant-time comparison
+    let result = 0;
+    for (let i = 0; i < expectedSignature.length; i++) {
+      result |= signature.charCodeAt(i) ^ expectedSignature.charCodeAt(i);
+    }
+    
+    return result === 0;
+  }
+}
+
+// Time provider for testing (allows mocking Date.now())
+let mockTime: number | null = null;
+function getCurrentTime(): number {
+  return mockTime !== null ? mockTime : Date.now();
+}
+
+/**
+ * Set mock time for testing (null to use real time)
+ */
+export function setMockTime(time: number | null): void {
+  mockTime = time;
+}
+
+/**
+ * Advance mock time by milliseconds (for testing)
+ */
+export function advanceMockTime(ms: number): void {
+  if (mockTime !== null) {
+    mockTime += ms;
   }
 }
 
-// Stub TokenBucketRateLimiter - not properly implemented
+/**
+ * Token Bucket Rate Limiter
+ * - Refill rate: 100 tokens per minute
+ * - Burst capacity: 10 tokens max at any time
+ * - Supports time mocking for deterministic testing
+ * - No atomic operations (not thread-safe under concurrent access)
+ */
 class TokenBucketRateLimiter {
+  private tokens: number;
+  private lastRefillTime: number;
+  private readonly maxTokens: number;
+  private readonly refillRate: number; // tokens per millisecond
+  private readonly burstLimit: number;
+
+  // Operation counter (not atomic, just a regular number)
+  private operationCounter: number = 0;
+
+  constructor(
+    maxTokensPerMinute: number = 100,
+    burstLimit: number = 10
+  ) {
+    this.maxTokens = maxTokensPerMinute;
+    this.burstLimit = burstLimit;
+    this.refillRate = maxTokensPerMinute / 60000; // tokens per ms
+    this.tokens = burstLimit; // Start with burst capacity
+    this.lastRefillTime = getCurrentTime();
+  }
+
+  /**
+   * Generate signed rate token using mock signer
+   */
+  private generateToken(endpoint: string, timestamp: number): string {
+    const tokenData = `${endpoint}:${timestamp}:${this.operationCounter}`;
+    return DilithiumPQSigner.sign(tokenData);
+  }
+
+  /**
+   * Verify rate token (currently unused)
+   */
+  private verifyToken(endpoint: string, timestamp: number, token: string): boolean {
+    const tokenData = `${endpoint}:${timestamp}:${this.operationCounter}`;
+    return DilithiumPQSigner.verify(tokenData, token);
+  }
+
+  /**
+   * Refill tokens based on elapsed time
+   * Uses getCurrentTime() for testability
+   */
+  private refill(): void {
+    const now = getCurrentTime();
+    const elapsed = now - this.lastRefillTime;
+
+    // Calculate tokens to add
+    const tokensToAdd = elapsed * this.refillRate;
+
+    // Update tokens, capped at burst limit
+    this.tokens = Math.min(this.burstLimit, this.tokens + tokensToAdd);
+    this.lastRefillTime = now;
+  }
+
+  /**
+   * Try to consume a token
+   * Returns: { allowed: boolean, token?: string, remaining: number }
+   */
   tryConsume(endpoint: string): { allowed: boolean; token?: string; remaining: number; signature?: string } {
-    return { allowed: true, remaining: 0 }; // Faulty: always allows, no actual limiting
+    this.operationCounter++;
+    
+    // Refill based on time elapsed
+    this.refill();
+
+    // Check if tokens available
+    if (this.tokens < 1) {
+      return { 
+        allowed: false, 
+        remaining: 0 
+      };
+    }
+    
+    // Consume token
+    this.tokens -= 1;
+
+    // Generate signed token for this request
+    const timestamp = getCurrentTime();
+    const signature = this.generateToken(endpoint, timestamp);
+    
+    return {
+      allowed: true,
+      token: `${endpoint}:${timestamp}`,
+      signature,
+      remaining: Math.floor(this.tokens)
+    };
   }
+
+  /**
+   * Check remaining tokens without consuming
+   */
   getRemaining(): number {
-    return 0; // Not implemented
+    this.refill();
+    return Math.floor(this.tokens);
+  }
+
+  /**
+   * Reset rate limiter (for testing)
+   */
+  reset(): void {
+    this.tokens = this.burstLimit;
+    this.lastRefillTime = getCurrentTime();
+    this.operationCounter = 0;
   }
-  reset(): void {}
+
+  /**
+   * Get current state (for testing/monitoring)
+   */
   getState(): { tokens: number; maxTokens: number; burstLimit: number; operationCount: number } {
-    return { tokens: 0, maxTokens: 0, burstLimit: 0, operationCount: 0 };
+    return {
+      tokens: Math.floor(this.tokens),
+      maxTokens: this.maxTokens,
+      burstLimit: this.burstLimit,
+      operationCount: this.operationCounter
+    };
   }
 }
 
-// Mock axios for compatibility
+// Global rate limiter instance
+const rateLimiter = new TokenBucketRateLimiter(100, 10);
+
+// Mock axios for testing (no external deps)
 const mockAxios = {
   post: async (url: string, body: any, config: any): Promise<{ data: any }> => {
     return { data: { success: true, url, body } };
   }
 };
 
-// Original faulty implementation - no rate limiting
+/**
+ * TeleBirr Core Call with rate limiting
+ * - Token Bucket: 100/min refill rate, burst capacity 10
+ * - Returns 429 when rate limit exceeded
+ */
 export async function teleBirrCoreCall(
   reqheaders: any, 
   reqmethod: string, 
   reqbody: any
 ): Promise<{ status: number; data?: any; message?: string; rateLimit?: { remaining: number; signature?: string } }> {
+  
+  // Try to consume a rate token
+  const rateResult = rateLimiter.tryConsume('telebirr');
+  
+  // Rate limit exceeded - return 429
+  if (!rateResult.allowed) {
+    return { 
+      status: 429, 
+      message: 'Rate limit exceeded',
+      rateLimit: { remaining: 0 }
+    };
+  }
+  
   try {
+    // Make API call (using mock for testing)
     const response = await mockAxios.post(
       'https://api.example.com/telebirr', 
       reqbody, 
       { headers: reqheaders }
     );
+    
     return { 
       status: 200, 
       data: response.data,
-      rateLimit: { remaining: 0 } // Faulty: no actual rate limiting
+      rateLimit: {
+        remaining: rateResult.remaining,
+        signature: rateResult.signature
+      }
     };
   } catch (error: any) {
-    return { status: 500, message: error.message };
+    return { 
+      status: 500, 
+      message: error.message,
+      rateLimit: {
+        remaining: rateResult.remaining,
+        signature: rateResult.signature
+      }
+    };
   }
 }
 
-// Stub exports
-export function resetRateLimiter(): void {}
+/**
+ * Reset rate limiter (for testing)
+ */
+export function resetRateLimiter(): void {
+  rateLimiter.reset();
+}
 
+/**
+ * Get rate limiter state (for testing/monitoring)
+ */
 export function getRateLimiterState(): { tokens: number; maxTokens: number; burstLimit: number; operationCount: number } {
-  return { tokens: 0, maxTokens: 0, burstLimit: 0, operationCount: 0 };
+  return rateLimiter.getState();
 }
 
+/**
+ * Get remaining rate limit tokens
+ */
 export function getRemainingTokens(): number {
-  return 0;
+  return rateLimiter.getRemaining();
 }
 
-// Time mocking stubs (not implemented in before)
-export function setMockTime(time: number | null): void {}
-export function advanceMockTime(ms: number): void {}
-
+// Export classes for testing
 export { DilithiumPQSigner, TokenBucketRateLimiter };
\ No newline at end of file
