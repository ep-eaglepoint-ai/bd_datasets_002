diff --git a/repository_before/__init__.py b/repository_after/__init__.py
index e69de29..eb7d8fa 100644
--- a/repository_before/__init__.py
+++ b/repository_after/__init__.py
@@ -0,0 +1,7 @@
+from .flight_model import FlightClass, FlightDetails, FlightSearchRequest
+
+__all__ = [
+	"FlightClass",
+	"FlightDetails",
+	"FlightSearchRequest",
+]
diff --git a/repository_before/__pycache__/__init__.cpython-312.pyc b/repository_after/__pycache__/__init__.cpython-312.pyc
index 3583924..6a10e1c 100644
Binary files a/repository_before/__pycache__/__init__.cpython-312.pyc and b/repository_after/__pycache__/__init__.cpython-312.pyc differ
diff --git a/repository_before/__pycache__/flight_model.cpython-312.pyc b/repository_after/__pycache__/flight_model.cpython-312.pyc
index 61f5496..c909c8b 100644
Binary files a/repository_before/__pycache__/flight_model.cpython-312.pyc and b/repository_after/__pycache__/flight_model.cpython-312.pyc differ
diff --git a/repository_before/flight_model.py b/repository_after/flight_model.py
index dc6deb3..fcde75b 100644
--- a/repository_before/flight_model.py
+++ b/repository_after/flight_model.py
@@ -1,56 +1,96 @@
-
-import pytest
-from datetime import date
-from dataclasses import dataclass
-from typing import Optional
-
-
-from dataclasses import dataclass, field
-from datetime import datetime, date
+from datetime import datetime, date, time, UTC
 from enum import Enum
-from typing import List, Optional
+from typing import Optional
 import uuid
+import re
+from pydantic import BaseModel, Field, field_validator, model_validator, ConfigDict
 
 
 class FlightClass(str, Enum):
+    """Enumeration for flight seating classes."""
     ECONOMY = "economy"
     BUSINESS = "business"
 
 
-@dataclass
-class FlightDetailsDC:
-    airline: str
-    flight_number: str
-    price: float
+class FlightDetails(BaseModel):
+    """
+    Represents the details of a specific flight.
+    
+    Refactored from dataclass to Pydantic v2 for robust validation, 
+    type coercion, and immutability.
+    """
+    model_config = ConfigDict(frozen=True)
+
+    airline: str = Field(min_length=1)
+    flight_number: str = Field(pattern=r"^[A-Z0-9]{2,3}\d{1,4}$")
+    price: float = Field(gt=0)
     origin: str
     destination: str
-    departure_time: str
-    arrival_time: str
-    duration: str
+    departure_time: time
+    arrival_time: time
+    duration: str = Field(pattern=r"^\d{2}:\d{2}$")
     flight_class: FlightClass = FlightClass.ECONOMY
-    id: str = field(default_factory=lambda: str(uuid.uuid4()))
-    created_at: datetime = field(default_factory=datetime.utcnow)
+    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
+    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
 
-    def __post_init__(self):
-        if len(self.origin) != 3 or len(self.destination) != 3:
-            raise ValueError("Invalid airport code")
+    @field_validator("origin", "destination", mode="before")
+    @classmethod
+    def validate_and_uppercase_iata(cls, v: str) -> str:
+        """Coerce airport codes to uppercase and validate IATA format."""
+        if isinstance(v, str):
+            v = v.upper()
+            if not re.match(r"^[A-Z]{3}$", v):
+                raise ValueError("Airport code must be 3 uppercase letters (IATA format)")
+            return v
+        return v
 
-        if self.price <= 0:
-            raise ValueError("Invalid price")
+    @model_validator(mode="after")
+    def validate_distinct_airports(self) -> "FlightDetails":
+        """Ensure origin and destination are not the same."""
+        if self.origin == self.destination:
+            raise ValueError("Origin and destination must be different")
+        return self
 
 
-@dataclass
-class FlightSearchRequestDC:
+class FlightSearchRequest(BaseModel):
+    """
+    Represents a request for flight searching.
+    
+    Refactored from dataclass to Pydantic v2 to ensure explicit validation
+    of dates and passenger counts.
+    """
+    model_config = ConfigDict(frozen=True)
+
     origin: str
     destination: str
     departure_date: date
     return_date: Optional[date] = None
-    passengers: int = 1
-    max_price: Optional[float] = None
+    passengers: int = Field(default=1, gt=0)
+    max_price: Optional[float] = Field(default=None, gt=0)
+
+    @field_validator("origin", "destination", mode="before")
+    @classmethod
+    def validate_and_uppercase_iata(cls, v: str) -> str:
+        """Coerce airport codes to uppercase and validate IATA format."""
+        if isinstance(v, str):
+            v = v.upper()
+            if not re.match(r"^[A-Z]{3}$", v):
+                raise ValueError("Airport code must be 3 uppercase letters (IATA format)")
+            return v
+        return v
 
-    def __post_init__(self):
-        if self.passengers <= 0:
-            raise ValueError("Passengers must be positive")
+    @model_validator(mode="after")
+    def validate_request_logic(self) -> "FlightSearchRequest":
+        """
+        Cross-field validation for search logical consistency.
+        1. Origin and destination must be distinct.
+        2. Return date must be after or on the departure date.
+        """
+        if hasattr(self, 'origin') and hasattr(self, 'destination'):
+            if self.origin == self.destination:
+                raise ValueError("Origin and destination must be distinct")
 
         if self.return_date and self.return_date < self.departure_date:
-            pass  # silently ignored
+            raise ValueError("return_date must be on or after departure_date")
+        
+        return self
\ No newline at end of file
