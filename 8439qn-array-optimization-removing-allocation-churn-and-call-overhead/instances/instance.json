{
            "instance_id": "8439QN",
            "problem_statement": "The legacy code presents a classic simulation bottleneck where, despite a theoretically correct algorithmic complexity, the constant factors are excessively high due to Python's dynamic overhead. The primary performance degradation stems from \"Allocation Thrashing,\" where copy.deepcopy recursively clones the entire grid structure inside every simulation step, requiring a shift to a \"Double Buffer\" architecture to eliminate memory churn. Additionally, the system suffers from severe \"Call Overhead\" and redundant bounds checking within the innermost loop; invoking a helper function to calculate neighbors for every single cell (N^2 times) creates stack frame creation costs that vastly exceed the expense of the actual mathematical averaging. To achieve the required magnitude of speedup without external C-extensions, the solution must inline this logic, minimize list lookups, and segregate boundary handling from the hot path.",
            "base_commit": "repository_before/",
            "test_patch": "tests/",
            "github_url": "https://github.com/ep-eaglepoint-ai/bd_datasets_002/tree/main/8439qn-array-optimization-removing-allocation-churn-and-call-overhead",
            "environment_setup": "Dockerfile",
            "FAIL_TO_PASS": [
                "tests/test_optimization.py::TestPerformanceOptimization::test_large_grid_completes_quickly",
                "tests/test_optimization.py::TestCodeStructure::test_no_deepcopy_uses_double_buffer",
                "tests/test_optimization.py::TestCodeStructure::test_neighbor_logic_inlined",
                "tests/test_optimization.py::TestCodeStructure::test_type_hints_present",
                "tests/test_optimization.py::TestMemoryAllocation::test_double_buffer_pattern_used"
            ],
            "PASS_TO_PASS": [
                "tests/test_functional.py::TestFunctionalEquivalence::test_small_grid_equivalence",
                "tests/test_functional.py::TestFunctionalEquivalence::test_medium_grid_equivalence",
                "tests/test_functional.py::TestFunctionalEquivalence::test_mathematical_formula_preserved",
                "tests/test_functional.py::TestBoundaryConditions::test_corner_cells_have_two_neighbors",
                "tests/test_functional.py::TestBoundaryConditions::test_edge_cells_have_three_neighbors",
                "tests/test_functional.py::TestBoundaryConditions::test_interior_cells_have_four_neighbors",
                "tests/test_functional.py::TestBoundaryConditions::test_boundary_calculation_correctness",
                "tests/test_functional.py::TestEdgeCases::test_single_cell_grid",
                "tests/test_functional.py::TestEdgeCases::test_two_cell_grid",
                "tests/test_functional.py::TestEdgeCases::test_zero_iterations",
                "tests/test_functional.py::TestEdgeCases::test_many_iterations",
                "tests/test_functional.py::TestOutputFormat::test_output_is_list_of_lists",
                "tests/test_functional.py::TestOutputFormat::test_output_dimensions_correct",
                "tests/test_optimization.py::TestPerformanceOptimization::test_performance_improvement_medium_grid",
                "tests/test_optimization.py::TestPerformanceOptimization::test_performance_improvement_small_grid",
                "tests/test_optimization.py::TestCodeStructure::test_no_numpy_import",
                "tests/test_optimization.py::TestMemoryAllocation::test_no_list_creation_in_hot_loop"
            ]
        }
        