diff --git a/repository_before/requirements.txt b/repository_after/requirements.txt
index 78a3e54..9a4f871 100644
--- a/repository_before/requirements.txt
+++ b/repository_after/requirements.txt
@@ -1,7 +1,9 @@
+# Add your Python dependencies here
 asyncio
 aiohttp==3.9.1
 aiofiles==23.2.1
 psycopg[binary]==3.1.16
+psycopg-pool==3.2.0
 pytest==7.4.3
 pytest-asyncio==0.21.1
-memory-profiler==0.61.0
+memory-profiler==0.61.0
\ No newline at end of file
diff --git a/repository_before/src/__init__.py b/repository_after/src/__init__.py
index 2b1b616..e69de29 100644
--- a/repository_before/src/__init__.py
+++ b/repository_after/src/__init__.py
@@ -1 +0,0 @@
-"""Package initialization"""
diff --git a/repository_before/src/__pycache__/__init__.cpython-311.pyc b/repository_after/src/__pycache__/__init__.cpython-311.pyc
index d56f631..483c414 100644
Binary files a/repository_before/src/__pycache__/__init__.cpython-311.pyc and b/repository_after/src/__pycache__/__init__.cpython-311.pyc differ
diff --git a/repository_before/src/__pycache__/database.cpython-311.pyc b/repository_after/src/__pycache__/database.cpython-311.pyc
index 1e48746..ab3304d 100644
Binary files a/repository_before/src/__pycache__/database.cpython-311.pyc and b/repository_after/src/__pycache__/database.cpython-311.pyc differ
diff --git a/repository_before/src/__pycache__/event_processor.cpython-311.pyc b/repository_after/src/__pycache__/event_processor.cpython-311.pyc
index c044159..81d3a03 100644
Binary files a/repository_before/src/__pycache__/event_processor.cpython-311.pyc and b/repository_after/src/__pycache__/event_processor.cpython-311.pyc differ
diff --git a/repository_before/src/__pycache__/http_client.cpython-311.pyc b/repository_after/src/__pycache__/http_client.cpython-311.pyc
index 3cd936a..ea53510 100644
Binary files a/repository_before/src/__pycache__/http_client.cpython-311.pyc and b/repository_after/src/__pycache__/http_client.cpython-311.pyc differ
diff --git a/repository_before/src/__pycache__/models.cpython-311.pyc b/repository_after/src/__pycache__/models.cpython-311.pyc
index acab109..291dd2a 100644
Binary files a/repository_before/src/__pycache__/models.cpython-311.pyc and b/repository_after/src/__pycache__/models.cpython-311.pyc differ
diff --git a/repository_before/src/database.py b/repository_after/src/database.py
index d8782e4..8c8b709 100644
--- a/repository_before/src/database.py
+++ b/repository_after/src/database.py
@@ -1,61 +1,56 @@
-
-
 import asyncio
 from typing import AsyncContextManager
 from contextlib import asynccontextmanager
-import psycopg
 from psycopg_pool import AsyncConnectionPool
 
-
 class DatabasePool:
     """Manages database connection pool"""
-    
+
     def __init__(self, connection_string: str, max_size: int = 20):
         self.pool = AsyncConnectionPool(
             connection_string,
             min_size=5,
             max_size=max_size,
-            timeout=30
+            timeout=30,
+            # Ensure connections are healthy when returned
+            kwargs={'autocommit': True}
         )
-    
+
     async def initialize(self):
-        """Initialize the connection pool"""
         await self.pool.open()
-    
+
     async def close(self):
-        """Close all connections"""
         await self.pool.close()
-    
+
     @asynccontextmanager
     async def connection(self):
-        """Get a connection from the pool"""
         async with self.pool.connection() as conn:
             yield conn
-    
+
     @asynccontextmanager
     async def transaction(self):
         """
-        Get a connection with transaction context
-        
-        BUG WARNING: If this context is not properly used,
-        transactions may remain open indefinitely!
+        Get a connection with transaction context safely.
         """
         async with self.pool.connection() as conn:
+            # The transaction context manager ensures COMMIT on success
+            # and ROLLBACK on exception.
             async with conn.transaction():
                 yield conn
 
-
 # Global database pool instance
 _db_pool: DatabasePool | None = None
 
-
 async def get_db_pool() -> DatabasePool:
-    """Get the global database pool"""
     global _db_pool
     if _db_pool is None:
-        # Using mock connection string for demonstration
-        _db_pool = DatabasePool(
-            "postgresql://user:pass@localhost/market_db"
-        )
+        _db_pool = DatabasePool("postgresql://user:pass@localhost/market_db")
         await _db_pool.initialize()
     return _db_pool
+
+async def close_db_pool():
+    """Helper to cleanly shutdown the pool"""
+    global _db_pool
+    if _db_pool:
+        await _db_pool.close()
+        _db_pool = None
\ No newline at end of file
diff --git a/repository_before/src/event_processor.py b/repository_after/src/event_processor.py
index 7a29f96..5f5f8a6 100644
--- a/repository_before/src/event_processor.py
+++ b/repository_after/src/event_processor.py
@@ -1,80 +1,68 @@
 import asyncio
 import aiofiles
 from datetime import datetime
-from typing import Optional
+from typing import Optional, List, Dict
 
 from .database import get_db_pool
 from .http_client import get_http_client
 from .models import MarketEvent, EnrichmentData
 
-
 class ProcessingError(Exception):
-   
     pass
 
-
 class EventProcessor:
-    
-    
     def __init__(self):
         self.processed_count = 0
         self.error_count = 0
-    
+        # Limit concurrency to match DB pool size (20)
+        # preventing "Timeout waiting for connection" under load.
+        self._semaphore = asyncio.Semaphore(20)
+
     async def process_event(self, event: MarketEvent) -> None:
-        asyncio.create_task(self._process_event_async(event))
-    
+        """Process event with concurrency control"""
+        async with self._semaphore:
+            await self._process_event_async(event)
+
     async def _process_event_async(self, event: MarketEvent) -> None:
         try:
-            # Fetch enrichment data
             enrichment = await self._fetch_enrichment(event.symbol)
-            
+
             if enrichment is None:
                 print(f"Enrichment failed for {event.symbol}")
                 self.error_count += 1
                 return
-            
+
             await self._store_event(event, enrichment)
-            
             await self._write_audit_log(event, enrichment)
-            
+
             self.processed_count += 1
-            
+
         except Exception as e:
             print(f"Processing error: {e}")
             self.error_count += 1
 
-    
     async def _fetch_enrichment(self, symbol: str) -> Optional[EnrichmentData]:
         try:
             client = await get_http_client()
-            
-            # Mock API call (would be real in production)
             url = f"https://api.marketdata.com/v1/symbols/{symbol}"
-            response_text = await asyncio.wait_for(
-                client.get(url),
-                timeout=5.0
-            )
-            
-            # Mock enrichment data
+
+            # Response is fully consumed inside client.get() now
+            await client.get(url)
+
             return EnrichmentData(
                 company_name=f"{symbol} Corp",
                 sector="Technology",
                 market_cap=1000000000.0
             )
-            
-        except asyncio.TimeoutError:
-            print(f"Enrichment timeout for {symbol}")
-            return None
         except Exception as e:
             print(f"Enrichment error: {e}")
             return None
-    
+
     async def _store_event(self, event: MarketEvent, enrichment: EnrichmentData) -> None:
         db_pool = await get_db_pool()
-        async with db_pool.connection() as conn:
-            await conn.execute("BEGIN")
-            
-            # Insert event
+
+        # Use transaction context to ensure Commit/Rollback
+        async with db_pool.transaction() as conn:
             await conn.execute(
                 """
                 INSERT INTO market_events (symbol, price, volume, timestamp, enrichment)
@@ -88,16 +76,9 @@ class EventProcessor:
                     enrichment.to_json()
                 )
             )
-            
-    
+
     async def _write_audit_log(self, event: MarketEvent, enrichment: EnrichmentData) -> None:
-        """
-        Write audit log entry
-        
-        BUG: File handle is never explicitly closed!
-        """
         filename = f"audit_{event.timestamp.strftime('%Y%m%d')}.log"
-        
         log_entry = (
             f"{event.timestamp.isoformat()},"
             f"{event.symbol},"
@@ -105,28 +86,29 @@ class EventProcessor:
             f"{event.volume},"
             f"{enrichment.company_name}\n"
         )
-        
-        file = await aiofiles.open(filename, mode='a')
-        await file.write(log_entry)
-        
 
+        # Explicitly close file handle using context manager
+        async with aiofiles.open(filename, mode='a') as file:
+            await file.write(log_entry)
 
-async def process_events_batch(events: list[MarketEvent]) -> dict:
+async def process_events_batch(events: List[MarketEvent]) -> Dict:
     """
     Process a batch of events
-    
     Returns statistics about processing
     """
     processor = EventProcessor()
-    
     print(f"Processing {len(events)} events...")
-    
-    for event in events:
-        await processor.process_event(event)
-    
+
+    # Create coroutines
+    tasks = [processor.process_event(event) for event in events]
+
+    # Await all tasks to ensure they finish before returning.
+    # return_exceptions=True prevents one crash from stopping others.
+    await asyncio.gather(*tasks, return_exceptions=True)
+
     return {
         'total': len(events),
         'processed': processor.processed_count,
         'errors': processor.error_count,
         'active_tasks': len(asyncio.all_tasks())
-    }
+    }
\ No newline at end of file
diff --git a/repository_before/src/http_client.py b/repository_after/src/http_client.py
index 71dbf96..32a6677 100644
--- a/repository_before/src/http_client.py
+++ b/repository_after/src/http_client.py
@@ -1,49 +1,48 @@
-
-
 import aiohttp
 from typing import Optional
 
-
 class HttpClient:
     """Async HTTP client wrapper"""
-    
+
     def __init__(self):
         self._session: Optional[aiohttp.ClientSession] = None
-    
+
     async def initialize(self):
-        """Initialize the HTTP session"""
-        self._session = aiohttp.ClientSession(
-            timeout=aiohttp.ClientTimeout(total=10),
-            connector=aiohttp.TCPConnector(limit=100)
-        )
-    
+        if self._session is None or self._session.closed:
+            self._session = aiohttp.ClientSession(
+                timeout=aiohttp.ClientTimeout(total=10),
+                connector=aiohttp.TCPConnector(limit=100)
+            )
+
     async def close(self):
-        """Close the HTTP session"""
         if self._session:
             await self._session.close()
-    
+            self._session = None
+
     async def get(self, url: str) -> str:
         """
-        Perform GET request
-        
-        BUG WARNING: If response is not fully consumed,
-        connection may not be returned to pool!
+        Perform GET request safely inside a context manager.
         """
         if not self._session:
             await self.initialize()
-        
+
+        # FIX: Context manager ensures connection is released back to pool
         async with self._session.get(url) as response:
+            response.raise_for_status()
             return await response.text()
 
-
 # Global HTTP client instance
 _http_client: HttpClient | None = None
 
-
 async def get_http_client() -> HttpClient:
-    """Get the global HTTP client"""
     global _http_client
     if _http_client is None:
         _http_client = HttpClient()
         await _http_client.initialize()
     return _http_client
+
+async def close_http_client():
+    global _http_client
+    if _http_client:
+        await _http_client.close()
+        _http_client = None
\ No newline at end of file
diff --git a/repository_before/src/models.py b/repository_after/src/models.py
index 2feccae..63ab428 100644
--- a/repository_before/src/models.py
+++ b/repository_after/src/models.py
@@ -1,7 +1,7 @@
 from dataclasses import dataclass
 from datetime import datetime
 from typing import Optional
-
+import json
 
 @dataclass
 class MarketEvent:
@@ -10,23 +10,21 @@ class MarketEvent:
     price: float
     volume: int
     timestamp: datetime
-    
+
     def __str__(self):
         return f"MarketEvent({self.symbol}, ${self.price}, vol={self.volume})"
 
-
 @dataclass
 class EnrichmentData:
     """Enrichment data from external API"""
     company_name: str
     sector: str
     market_cap: Optional[float] = None
-    
+
     def to_json(self) -> str:
         """Convert to JSON string"""
-        import json
         return json.dumps({
             'company_name': self.company_name,
             'sector': self.sector,
             'market_cap': self.market_cap
-        })
+        })
\ No newline at end of file
