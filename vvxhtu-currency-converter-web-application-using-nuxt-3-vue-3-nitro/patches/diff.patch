diff --git a/repository_after/utils/currencyConverter.ts b/repository_after/utils/currencyConverter.ts
new file mode 100644
index 0000000..c57ef56
--- /dev/null
+++ b/repository_after/utils/currencyConverter.ts
@@ -0,0 +1,469 @@
+/**
+ * Currency Converter - Production-grade implementation
+ * Uses arbitrary-precision decimal math for financial correctness
+ * Supports cross-rate conversion via canonical base currency (EUR)
+ */
+
+// ============================================================================
+// TYPES & INTERFACES
+// ============================================================================
+
+export interface CurrencyRate {
+  code: string;
+  rate: string;
+  date: string;
+  source: string;
+}
+
+export interface ExchangeRateData {
+  base: string;
+  date: string;
+  timestamp: number;
+  source: string;
+  rates: Record<string, string>;
+}
+
+export interface ConversionResult {
+  fromCurrency: string;
+  toCurrency: string;
+  fromAmount: string;
+  toAmount: string;
+  rate: string;
+  inverseRate: string;
+  rawUnrounded: string;
+  roundedTo: number;
+  timestamp: number;
+  locked: boolean;
+}
+
+export interface CurrencyMetadata {
+  code: string;
+  name: string;
+  symbol: string;
+  minorUnits: number;
+}
+
+export interface ConversionOptions {
+  roundingStrategy?: 'HALF_UP' | 'HALF_DOWN' | 'FLOOR' | 'CEIL';
+  allowNegative?: boolean;
+  lockRate?: boolean;
+  lockedRateValue?: string;
+}
+
+// ============================================================================
+// CURRENCY METADATA - ISO 4217 Minor Units
+// ============================================================================
+
+export const CURRENCY_MINOR_UNITS: Record<string, number> = {
+  'JPY': 0, 'KRW': 0, 'VND': 0, 'CLP': 0, 'ISK': 0, 'HUF': 0,
+  'USD': 2, 'EUR': 2, 'GBP': 2, 'CAD': 2, 'AUD': 2, 'CHF': 2,
+  'CNY': 2, 'INR': 2, 'MXN': 2, 'BRL': 2, 'ZAR': 2, 'SGD': 2,
+  'HKD': 2, 'NOK': 2, 'SEK': 2, 'DKK': 2, 'NZD': 2, 'PLN': 2,
+  'THB': 2, 'MYR': 2, 'PHP': 2, 'IDR': 2, 'TRY': 2, 'RUB': 2,
+  'AED': 2, 'SAR': 2, 'EGP': 2, 'NGN': 2, 'KES': 2, 'GHS': 2,
+  'KWD': 3, 'BHD': 3, 'OMR': 3, 'TND': 3, 'LYD': 3, 'JOD': 3,
+};
+
+export const SUPPORTED_CURRENCIES: CurrencyMetadata[] = [
+  { code: 'EUR', name: 'Euro', symbol: '€', minorUnits: 2 },
+  { code: 'USD', name: 'US Dollar', symbol: '$', minorUnits: 2 },
+  { code: 'GBP', name: 'British Pound', symbol: '£', minorUnits: 2 },
+  { code: 'JPY', name: 'Japanese Yen', symbol: '¥', minorUnits: 0 },
+  { code: 'CHF', name: 'Swiss Franc', symbol: 'CHF', minorUnits: 2 },
+  { code: 'CAD', name: 'Canadian Dollar', symbol: 'C$', minorUnits: 2 },
+  { code: 'AUD', name: 'Australian Dollar', symbol: 'A$', minorUnits: 2 },
+  { code: 'CNY', name: 'Chinese Yuan', symbol: '¥', minorUnits: 2 },
+  { code: 'INR', name: 'Indian Rupee', symbol: '₹', minorUnits: 2 },
+  { code: 'KWD', name: 'Kuwaiti Dinar', symbol: 'KD', minorUnits: 3 },
+  { code: 'BHD', name: 'Bahraini Dinar', symbol: 'BD', minorUnits: 3 },
+];
+
+// ============================================================================
+// DECIMAL MATH - Arbitrary Precision (No Floating Point)
+// ============================================================================
+
+export class DecimalMath {
+  private static readonly DEFAULT_PRECISION = 20;
+
+  static isValidNumber(value: string): boolean {
+    if (typeof value !== 'string' || value.trim() === '') {
+      return false;
+    }
+    const pattern = /^-?\d+(\.\d+)?$/;
+    return pattern.test(value.trim());
+  }
+
+  static add(a: string, b: string): string {
+    this.validateInputs(a, b);
+    const [aInt, aDec] = this.splitDecimal(a);
+    const [bInt, bDec] = this.splitDecimal(b);
+    const maxDecLen = Math.max(aDec.length, bDec.length);
+    const aPadded = aDec.padEnd(maxDecLen, '0');
+    const bPadded = bDec.padEnd(maxDecLen, '0');
+    const aFull = BigInt(aInt + aPadded);
+    const bFull = BigInt(bInt + bPadded);
+    const sum = aFull + bFull;
+    return this.insertDecimalPoint(sum.toString(), maxDecLen);
+  }
+
+  static subtract(a: string, b: string): string {
+    this.validateInputs(a, b);
+    const [aInt, aDec] = this.splitDecimal(a);
+    const [bInt, bDec] = this.splitDecimal(b);
+    const maxDecLen = Math.max(aDec.length, bDec.length);
+    const aPadded = aDec.padEnd(maxDecLen, '0');
+    const bPadded = bDec.padEnd(maxDecLen, '0');
+    const aFull = BigInt(aInt + aPadded);
+    const bFull = BigInt(bInt + bPadded);
+    const diff = aFull - bFull;
+    return this.insertDecimalPoint(diff.toString(), maxDecLen);
+  }
+
+  static multiply(a: string, b: string): string {
+    this.validateInputs(a, b);
+    const [aInt, aDec] = this.splitDecimal(a);
+    const [bInt, bDec] = this.splitDecimal(b);
+    const totalDecLen = aDec.length + bDec.length;
+    const aFull = BigInt(aInt + aDec);
+    const bFull = BigInt(bInt + bDec);
+    const product = aFull * bFull;
+    return this.insertDecimalPoint(product.toString(), totalDecLen);
+  }
+
+  static divide(a: string, b: string, precision: number = this.DEFAULT_PRECISION): string {
+    this.validateInputs(a, b);
+    if (this.isZero(b)) {
+      throw new Error('Division by zero');
+    }
+    const [aInt, aDec] = this.splitDecimal(a);
+    const [bInt, bDec] = this.splitDecimal(b);
+    const scale = precision + bDec.length;
+    const aScaled = BigInt(aInt + aDec) * BigInt(10 ** scale);
+    const bScaled = BigInt(bInt + bDec);
+    const quotient = aScaled / bScaled;
+    const totalDecLen = scale - bDec.length + aDec.length;
+    return this.insertDecimalPoint(quotient.toString(), totalDecLen);
+  }
+
+  static isZero(value: string): boolean {
+    const cleaned = value.replace(/^-/, '').replace(/^0+/, '').replace(/\.?0+$/, '');
+    return cleaned === '' || cleaned === '.';
+  }
+
+  static isNegative(value: string): boolean {
+    return value.trim().startsWith('-') && !this.isZero(value);
+  }
+
+  static compare(a: string, b: string): number {
+    const diff = this.subtract(a, b);
+    if (this.isZero(diff)) return 0;
+    return this.isNegative(diff) ? -1 : 1;
+  }
+
+  static round(value: string, decimalPlaces: number, strategy: string = 'HALF_UP'): string {
+    if (!this.isValidNumber(value)) {
+      throw new Error(`Invalid number for rounding: ${value}`);
+    }
+    const [intPart, decPart] = this.splitDecimal(value);
+    if (decPart.length <= decimalPlaces) {
+      return intPart + (decimalPlaces > 0 ? '.' + decPart.padEnd(decimalPlaces, '0') : '');
+    }
+    const isNeg = intPart.startsWith('-');
+    const absInt = isNeg ? intPart.slice(1) : intPart;
+    const keepDec = decPart.slice(0, decimalPlaces);
+    const nextDigit = parseInt(decPart[decimalPlaces], 10);
+    let rounded = BigInt(absInt + keepDec);
+    let shouldRoundUp = false;
+    switch (strategy) {
+      case 'HALF_UP': shouldRoundUp = nextDigit >= 5; break;
+      case 'HALF_DOWN': shouldRoundUp = nextDigit > 5; break;
+      case 'FLOOR': shouldRoundUp = false; break;
+      case 'CEIL': shouldRoundUp = nextDigit > 0; break;
+      default: shouldRoundUp = nextDigit >= 5;
+    }
+    if (shouldRoundUp) {
+      rounded += BigInt(1);
+    }
+    let result = rounded.toString();
+    if (decimalPlaces > 0) {
+      result = result.padStart(decimalPlaces + 1, '0');
+      const intLen = result.length - decimalPlaces;
+      result = result.slice(0, intLen) + '.' + result.slice(intLen);
+    }
+    return (isNeg ? '-' : '') + result;
+  }
+
+  private static validateInputs(a: string, b: string): void {
+    if (!this.isValidNumber(a)) throw new Error(`Invalid number: ${a}`);
+    if (!this.isValidNumber(b)) throw new Error(`Invalid number: ${b}`);
+  }
+
+  private static splitDecimal(value: string): [string, string] {
+    const parts = value.split('.');
+    return [parts[0], parts[1] || ''];
+  }
+
+  private static insertDecimalPoint(value: string, decimalPlaces: number): string {
+    if (decimalPlaces === 0) return value;
+    const isNeg = value.startsWith('-');
+    let abs = isNeg ? value.slice(1) : value;
+    abs = abs.padStart(decimalPlaces + 1, '0');
+    const intLen = abs.length - decimalPlaces;
+    const result = abs.slice(0, intLen) + '.' + abs.slice(intLen);
+    const cleaned = result.replace(/\.?0+$/, '').replace(/^0+(?=\d)/, '');
+    return (isNeg ? '-' : '') + (cleaned || '0');
+  }
+}
+
+// ============================================================================
+// CROSS-RATE ENGINE
+// ============================================================================
+
+export class CrossRateEngine {
+  private rates: ExchangeRateData | null = null;
+  private lockedRates: Map<string, string> = new Map();
+
+  setRates(data: ExchangeRateData): void {
+    this.rates = data;
+  }
+
+  getRates(): ExchangeRateData | null {
+    return this.rates;
+  }
+
+  lockRate(fromCurrency: string, toCurrency: string, rate: string): void {
+    const key = `${fromCurrency}_${toCurrency}`;
+    this.lockedRates.set(key, rate);
+  }
+
+  getLockedRate(fromCurrency: string, toCurrency: string): string | null {
+    const key = `${fromCurrency}_${toCurrency}`;
+    return this.lockedRates.get(key) || null;
+  }
+
+  clearLockedRates(): void {
+    this.lockedRates.clear();
+  }
+
+  getCrossRate(fromCurrency: string, toCurrency: string): string {
+    if (!this.rates) {
+      throw new Error('Exchange rates not loaded');
+    }
+    const base = this.rates.base;
+    if (fromCurrency === toCurrency) return '1';
+    if (fromCurrency === base) {
+      const rate = this.rates.rates[toCurrency];
+      if (!rate) throw new Error(`Rate not available for ${toCurrency}`);
+      return rate;
+    }
+    if (toCurrency === base) {
+      const rate = this.rates.rates[fromCurrency];
+      if (!rate) throw new Error(`Rate not available for ${fromCurrency}`);
+      return DecimalMath.divide('1', rate);
+    }
+    const rateA = this.rates.rates[fromCurrency];
+    const rateB = this.rates.rates[toCurrency];
+    if (!rateA) throw new Error(`Rate not available for ${fromCurrency}`);
+    if (!rateB) throw new Error(`Rate not available for ${toCurrency}`);
+    if (DecimalMath.isZero(rateA)) throw new Error(`Invalid zero rate for ${fromCurrency}`);
+    return DecimalMath.divide(rateB, rateA);
+  }
+}
+
+// ============================================================================
+// RATE FETCHER
+// ============================================================================
+
+export class RateFetcher {
+  private cache: ExchangeRateData | null = null;
+  private cacheTimestamp: number = 0;
+  private readonly cacheTTL: number = 60000;
+
+  private static readonly MOCK_RATES: Record<string, string> = {
+    'USD': '1.0856', 'GBP': '0.8567', 'JPY': '162.34', 'CHF': '0.9423',
+    'CAD': '1.4789', 'AUD': '1.6543', 'CNY': '7.8234', 'INR': '90.5678',
+    'KWD': '0.3342', 'BHD': '0.4102',
+  };
+
+  async fetchRates(forceRefresh: boolean = false): Promise<ExchangeRateData> {
+    if (!forceRefresh && this.cache && Date.now() - this.cacheTimestamp < this.cacheTTL) {
+      return this.cache;
+    }
+    const data: ExchangeRateData = {
+      base: 'EUR',
+      date: new Date().toISOString().split('T')[0],
+      timestamp: Date.now(),
+      source: 'European Central Bank (simulated)',
+      rates: { ...RateFetcher.MOCK_RATES },
+    };
+    this.validateRateData(data);
+    this.cache = data;
+    this.cacheTimestamp = Date.now();
+    return data;
+  }
+
+  private validateRateData(data: ExchangeRateData): void {
+    if (!data || typeof data !== 'object') throw new Error('Invalid rate data');
+    if (typeof data.base !== 'string' || data.base.length !== 3) throw new Error('Invalid base');
+    if (!data.rates || typeof data.rates !== 'object') throw new Error('Missing rates');
+    for (const [code, rate] of Object.entries(data.rates)) {
+      if (typeof code !== 'string' || code.length !== 3) throw new Error(`Invalid code: ${code}`);
+      if (typeof rate !== 'string' || !DecimalMath.isValidNumber(rate)) throw new Error(`Invalid rate: ${rate}`);
+    }
+  }
+
+  getCacheStatus(): { cached: boolean; age: number; ttl: number } {
+    return {
+      cached: this.cache !== null,
+      age: this.cache ? Date.now() - this.cacheTimestamp : 0,
+      ttl: this.cacheTTL,
+    };
+  }
+
+  clearCache(): void {
+    this.cache = null;
+    this.cacheTimestamp = 0;
+  }
+}
+
+// ============================================================================
+// CURRENCY CONVERTER
+// ============================================================================
+
+export class CurrencyConverter {
+  private crossRateEngine: CrossRateEngine;
+  private rateFetcher: RateFetcher;
+  private lastUpdated: number = 0;
+
+  constructor() {
+    this.crossRateEngine = new CrossRateEngine();
+    this.rateFetcher = new RateFetcher();
+  }
+
+  async initialize(): Promise<void> {
+    const rates = await this.rateFetcher.fetchRates();
+    this.crossRateEngine.setRates(rates);
+    this.lastUpdated = rates.timestamp;
+  }
+
+  async refreshRates(): Promise<ExchangeRateData> {
+    const rates = await this.rateFetcher.fetchRates(true);
+    this.crossRateEngine.setRates(rates);
+    this.lastUpdated = rates.timestamp;
+    return rates;
+  }
+
+  getLastUpdated(): number {
+    return this.lastUpdated;
+  }
+
+  isValidCurrencyCode(code: string): boolean {
+    if (typeof code !== 'string') return false;
+    const trimmed = code.trim().toUpperCase();
+    return /^[A-Z]{3}$/.test(trimmed);
+  }
+
+  isCurrencySupported(code: string): boolean {
+    if (!this.isValidCurrencyCode(code)) return false;
+    const rates = this.crossRateEngine.getRates();
+    if (!rates) return false;
+    const upperCode = code.toUpperCase();
+    return upperCode === rates.base || upperCode in rates.rates;
+  }
+
+  getMinorUnits(currencyCode: string): number {
+    const code = currencyCode.toUpperCase();
+    return CURRENCY_MINOR_UNITS[code] ?? 2;
+  }
+
+  convert(
+    amount: string,
+    fromCurrency: string,
+    toCurrency: string,
+    options: ConversionOptions = {}
+  ): ConversionResult {
+    const { roundingStrategy = 'HALF_UP', allowNegative = false, lockRate = false, lockedRateValue } = options;
+
+    if (!DecimalMath.isValidNumber(amount)) throw new Error(`Invalid amount: ${amount}`);
+    if (!this.isValidCurrencyCode(fromCurrency)) throw new Error(`Invalid currency code: ${fromCurrency}`);
+    if (!this.isValidCurrencyCode(toCurrency)) throw new Error(`Invalid currency code: ${toCurrency}`);
+
+    const from = fromCurrency.toUpperCase();
+    const to = toCurrency.toUpperCase();
+
+    if (!this.isCurrencySupported(from)) throw new Error(`Unsupported currency: ${from}`);
+    if (!this.isCurrencySupported(to)) throw new Error(`Unsupported currency: ${to}`);
+    if (!allowNegative && DecimalMath.isNegative(amount)) throw new Error('Negative amounts not allowed');
+
+    let rate: string;
+    if (lockedRateValue) {
+      rate = lockedRateValue;
+    } else if (lockRate) {
+      const locked = this.crossRateEngine.getLockedRate(from, to);
+      if (locked) {
+        rate = locked;
+      } else {
+        rate = this.crossRateEngine.getCrossRate(from, to);
+        this.crossRateEngine.lockRate(from, to, rate);
+      }
+    } else {
+      rate = this.crossRateEngine.getCrossRate(from, to);
+    }
+
+    const rawResult = DecimalMath.multiply(amount, rate);
+    const minorUnits = this.getMinorUnits(to);
+    const roundedResult = DecimalMath.round(rawResult, minorUnits, roundingStrategy);
+    const inverseRate = DecimalMath.divide('1', rate);
+
+    return {
+      fromCurrency: from,
+      toCurrency: to,
+      fromAmount: amount,
+      toAmount: roundedResult,
+      rate,
+      inverseRate,
+      rawUnrounded: rawResult,
+      roundedTo: minorUnits,
+      timestamp: Date.now(),
+      locked: lockRate,
+    };
+  }
+
+  swap(amount: string, fromCurrency: string, toCurrency: string, options: ConversionOptions = {}): ConversionResult {
+    return this.convert(amount, toCurrency, fromCurrency, options);
+  }
+
+  getAvailableCurrencies(): string[] {
+    const rates = this.crossRateEngine.getRates();
+    if (!rates) return [];
+    return [rates.base, ...Object.keys(rates.rates)];
+  }
+
+  searchCurrencies(query: string): CurrencyMetadata[] {
+    const q = query.toLowerCase();
+    return SUPPORTED_CURRENCIES.filter(
+      (c: CurrencyMetadata) => c.code.toLowerCase().includes(q) || c.name.toLowerCase().includes(q)
+    );
+  }
+
+  getRateMetadata(): { base: string; date: string; source: string; timestamp: number } | null {
+    const rates = this.crossRateEngine.getRates();
+    if (!rates) return null;
+    return { base: rates.base, date: rates.date, source: rates.source, timestamp: rates.timestamp };
+  }
+
+  isDataStale(maxAgeMs: number = 3600000): boolean {
+    if (!this.lastUpdated) return true;
+    return Date.now() - this.lastUpdated >= maxAgeMs;
+  }
+
+  lockCurrentRate(fromCurrency: string, toCurrency: string): string {
+    const rate = this.crossRateEngine.getCrossRate(fromCurrency.toUpperCase(), toCurrency.toUpperCase());
+    this.crossRateEngine.lockRate(fromCurrency.toUpperCase(), toCurrency.toUpperCase(), rate);
+    return rate;
+  }
+
+  clearLockedRates(): void {
+    this.crossRateEngine.clearLockedRates();
+  }
+}
diff --git a/tests/currencyConverter.test.ts b/tests/currencyConverter.test.ts
new file mode 100644
index 0000000..c523088
--- /dev/null
+++ b/tests/currencyConverter.test.ts
@@ -0,0 +1,355 @@
+/**
+ * Test suite for Currency Converter
+ * Tests arbitrary-precision math, cross-rate conversion, and proper rounding
+ */
+
+import {
+  CurrencyConverter,
+  DecimalMath,
+  CrossRateEngine,
+  RateFetcher,
+  CURRENCY_MINOR_UNITS,
+  SUPPORTED_CURRENCIES,
+} from '../repository_after/utils/currencyConverter';
+
+describe('Currency Converter Application', () => {
+
+  describe('Requirement 1: Currency Selection and Conversion UI', () => {
+    let converter: CurrencyConverter;
+
+    beforeEach(async () => {
+      converter = new CurrencyConverter();
+      await converter.initialize();
+    });
+
+    test('should validate currency codes correctly', () => {
+      expect(converter.isValidCurrencyCode('USD')).toBe(true);
+      expect(converter.isValidCurrencyCode('eur')).toBe(true);
+      expect(converter.isValidCurrencyCode('USDD')).toBe(false);
+      expect(converter.isValidCurrencyCode('US')).toBe(false);
+      expect(converter.isValidCurrencyCode('')).toBe(false);
+      expect(converter.isValidCurrencyCode('123')).toBe(false);
+    });
+
+    test('should check if currency is supported', () => {
+      expect(converter.isCurrencySupported('EUR')).toBe(true);
+      expect(converter.isCurrencySupported('USD')).toBe(true);
+      expect(converter.isCurrencySupported('XYZ')).toBe(false);
+    });
+
+    test('should return list of available currencies', () => {
+      const currencies = converter.getAvailableCurrencies();
+      expect(currencies).toContain('EUR');
+      expect(currencies).toContain('USD');
+      expect(currencies.length).toBeGreaterThan(2);
+    });
+
+    test('should search currencies by code or name', () => {
+      const results = converter.searchCurrencies('dol');
+      expect(results.some(c => c.code === 'USD')).toBe(true);
+    });
+
+    test('should swap currencies correctly', async () => {
+      const result = converter.convert('100', 'EUR', 'USD');
+      const swapped = converter.swap('100', 'EUR', 'USD');
+
+      expect(result.fromCurrency).toBe('EUR');
+      expect(result.toCurrency).toBe('USD');
+      expect(swapped.fromCurrency).toBe('USD');
+      expect(swapped.toCurrency).toBe('EUR');
+    });
+
+    test('should provide last updated timestamp', () => {
+      const timestamp = converter.getLastUpdated();
+      expect(timestamp).toBeGreaterThan(0);
+      expect(timestamp).toBeLessThanOrEqual(Date.now());
+    });
+
+    test('should detect stale data', () => {
+      expect(converter.isDataStale(3600000)).toBe(false);
+      expect(converter.isDataStale(0)).toBe(true);
+    });
+
+    test('should provide rate metadata', () => {
+      const metadata = converter.getRateMetadata();
+      expect(metadata).not.toBeNull();
+      expect(metadata!.base).toBe('EUR');
+      expect(metadata!.source).toBeDefined();
+      expect(metadata!.date).toBeDefined();
+    });
+  });
+
+  describe('Requirement 2: Server-side Rate Fetching (Nitro API)', () => {
+    test('RateFetcher should fetch rates with proper structure', async () => {
+      const fetcher = new RateFetcher();
+      const rates = await fetcher.fetchRates();
+
+      expect(rates.base).toBe('EUR');
+      expect(rates.rates).toBeDefined();
+      expect(typeof rates.timestamp).toBe('number');
+      expect(rates.source).toBeDefined();
+    });
+
+    test('RateFetcher should cache rates', async () => {
+      const fetcher = new RateFetcher();
+      await fetcher.fetchRates();
+
+      const status = fetcher.getCacheStatus();
+      expect(status.cached).toBe(true);
+      expect(status.ttl).toBeGreaterThan(0);
+    });
+
+    test('RateFetcher should respect force refresh', async () => {
+      const fetcher = new RateFetcher();
+      const rates1 = await fetcher.fetchRates();
+      const rates2 = await fetcher.fetchRates(true);
+
+      expect(rates2.timestamp).toBeGreaterThanOrEqual(rates1.timestamp);
+    });
+
+    test('RateFetcher should clear cache', async () => {
+      const fetcher = new RateFetcher();
+      await fetcher.fetchRates();
+      fetcher.clearCache();
+
+      const status = fetcher.getCacheStatus();
+      expect(status.cached).toBe(false);
+    });
+
+    test('Rate data should have valid string rates', async () => {
+      const fetcher = new RateFetcher();
+      const rates = await fetcher.fetchRates();
+
+      for (const [code, rate] of Object.entries(rates.rates)) {
+        expect(typeof rate).toBe('string');
+        expect(DecimalMath.isValidNumber(rate)).toBe(true);
+      }
+    });
+  });
+
+  describe('Requirement 3: Arbitrary-Precision Decimal Math', () => {
+    test('DecimalMath should validate number strings', () => {
+      expect(DecimalMath.isValidNumber('123.45')).toBe(true);
+      expect(DecimalMath.isValidNumber('-123.45')).toBe(true);
+      expect(DecimalMath.isValidNumber('0.001')).toBe(true);
+      expect(DecimalMath.isValidNumber('')).toBe(false);
+      expect(DecimalMath.isValidNumber('abc')).toBe(false);
+      expect(DecimalMath.isValidNumber('12.34.56')).toBe(false);
+    });
+
+    test('DecimalMath should add with precision', () => {
+      const result = DecimalMath.add('0.1', '0.2');
+      expect(result).toBe('0.3');
+    });
+
+    test('DecimalMath should subtract with precision', () => {
+      const result = DecimalMath.subtract('1.0', '0.9');
+      expect(parseFloat(result)).toBeCloseTo(0.1, 10);
+    });
+
+    test('DecimalMath should multiply with precision', () => {
+      const result = DecimalMath.multiply('0.1', '0.2');
+      expect(result).toBe('0.02');
+    });
+
+    test('DecimalMath should divide with precision', () => {
+      const result = DecimalMath.divide('1', '3', 10);
+      expect(result.startsWith('0.333333')).toBe(true);
+    });
+
+    test('DecimalMath should handle large numbers without overflow', () => {
+      const large = '99999999999999999999.99';
+      const result = DecimalMath.add(large, '0.01');
+      expect(result).toBe('100000000000000000000');
+    });
+
+    test('DecimalMath should detect zero correctly', () => {
+      expect(DecimalMath.isZero('0')).toBe(true);
+      expect(DecimalMath.isZero('0.0')).toBe(true);
+      expect(DecimalMath.isZero('0.00')).toBe(true);
+      expect(DecimalMath.isZero('0.001')).toBe(false);
+    });
+
+    test('DecimalMath should detect negative correctly', () => {
+      expect(DecimalMath.isNegative('-1')).toBe(true);
+      expect(DecimalMath.isNegative('1')).toBe(false);
+      expect(DecimalMath.isNegative('-0')).toBe(false);
+    });
+
+    test('DecimalMath should round with HALF_UP strategy', () => {
+      expect(DecimalMath.round('1.235', 2, 'HALF_UP')).toBe('1.24');
+      expect(DecimalMath.round('1.234', 2, 'HALF_UP')).toBe('1.23');
+      expect(DecimalMath.round('1.245', 2, 'HALF_UP')).toBe('1.25');
+    });
+
+    test('DecimalMath should round to zero decimal places (JPY)', () => {
+      expect(DecimalMath.round('123.6', 0, 'HALF_UP')).toBe('124');
+      expect(DecimalMath.round('123.4', 0, 'HALF_UP')).toBe('123');
+    });
+
+    test('DecimalMath should round to three decimal places (KWD)', () => {
+      expect(DecimalMath.round('1.2345', 3, 'HALF_UP')).toBe('1.235');
+      expect(DecimalMath.round('1.2344', 3, 'HALF_UP')).toBe('1.234');
+    });
+
+    test('DecimalMath should throw on division by zero', () => {
+      expect(() => DecimalMath.divide('1', '0')).toThrow('Division by zero');
+    });
+
+    test('DecimalMath should compare numbers correctly', () => {
+      expect(DecimalMath.compare('1.1', '1.0')).toBe(1);
+      expect(DecimalMath.compare('1.0', '1.1')).toBe(-1);
+      expect(DecimalMath.compare('1.0', '1.0')).toBe(0);
+    });
+  });
+
+  describe('Requirement 4: Cross-Rate Conversion', () => {
+    let converter: CurrencyConverter;
+
+    beforeEach(async () => {
+      converter = new CurrencyConverter();
+      await converter.initialize();
+    });
+
+    test('CrossRateEngine should calculate same currency rate as 1', () => {
+      const engine = new CrossRateEngine();
+      engine.setRates({
+        base: 'EUR',
+        date: '2024-01-01',
+        timestamp: Date.now(),
+        source: 'Test',
+        rates: { 'USD': '1.1', 'GBP': '0.85' }
+      });
+
+      expect(engine.getCrossRate('EUR', 'EUR')).toBe('1');
+      expect(engine.getCrossRate('USD', 'USD')).toBe('1');
+    });
+
+    test('CrossRateEngine should calculate cross-rate via base currency', () => {
+      const engine = new CrossRateEngine();
+      engine.setRates({
+        base: 'EUR',
+        date: '2024-01-01',
+        timestamp: Date.now(),
+        source: 'Test',
+        rates: { 'USD': '1.1', 'GBP': '0.85' }
+      });
+
+      const rate = engine.getCrossRate('USD', 'GBP');
+      const expected = parseFloat(DecimalMath.divide('0.85', '1.1'));
+      expect(parseFloat(rate)).toBeCloseTo(expected, 5);
+    });
+
+    test('CrossRateEngine should handle conversion from base currency', () => {
+      const engine = new CrossRateEngine();
+      engine.setRates({
+        base: 'EUR',
+        date: '2024-01-01',
+        timestamp: Date.now(),
+        source: 'Test',
+        rates: { 'USD': '1.1' }
+      });
+
+      expect(engine.getCrossRate('EUR', 'USD')).toBe('1.1');
+    });
+
+    test('CrossRateEngine should handle conversion to base currency', () => {
+      const engine = new CrossRateEngine();
+      engine.setRates({
+        base: 'EUR',
+        date: '2024-01-01',
+        timestamp: Date.now(),
+        source: 'Test',
+        rates: { 'USD': '1.1' }
+      });
+
+      const rate = engine.getCrossRate('USD', 'EUR');
+      expect(parseFloat(rate)).toBeCloseTo(1 / 1.1, 5);
+    });
+
+    test('CrossRateEngine should throw on missing rate', () => {
+      const engine = new CrossRateEngine();
+      engine.setRates({
+        base: 'EUR',
+        date: '2024-01-01',
+        timestamp: Date.now(),
+        source: 'Test',
+        rates: { 'USD': '1.1' }
+      });
+
+      expect(() => engine.getCrossRate('EUR', 'XYZ')).toThrow();
+    });
+
+    test('CurrencyConverter should use correct minor units for JPY (0 decimals)', async () => {
+      const result = converter.convert('100', 'EUR', 'JPY');
+
+      expect(result.roundedTo).toBe(0);
+      expect(result.toAmount).not.toContain('.');
+    });
+
+    test('CurrencyConverter should use correct minor units for KWD (3 decimals)', async () => {
+      const result = converter.convert('100', 'EUR', 'KWD');
+
+      expect(result.roundedTo).toBe(3);
+      const decimals = result.toAmount.split('.')[1];
+      expect(decimals?.length).toBeLessThanOrEqual(3);
+    });
+
+    test('CurrencyConverter should reject negative amounts by default', async () => {
+      expect(() => converter.convert('-100', 'EUR', 'USD')).toThrow('Negative amounts not allowed');
+    });
+
+    test('CurrencyConverter should allow negative amounts when configured', async () => {
+      const result = converter.convert('-100', 'EUR', 'USD', { allowNegative: true });
+      expect(parseFloat(result.toAmount)).toBeLessThan(0);
+    });
+
+    test('CurrencyConverter should provide raw unrounded value for auditing', async () => {
+      const result = converter.convert('100.123', 'EUR', 'USD');
+
+      expect(result.rawUnrounded).toBeDefined();
+      expect(result.toAmount).not.toBe(result.rawUnrounded);
+    });
+
+    test('CurrencyConverter should support lock rate mode', async () => {
+      const rate = converter.lockCurrentRate('EUR', 'USD');
+      expect(rate).toBeDefined();
+      expect(parseFloat(rate)).toBeGreaterThan(0);
+    });
+
+    test('CurrencyConverter should use locked rate for conversion', async () => {
+      const result1 = converter.convert('100', 'EUR', 'USD', { lockRate: true });
+      const lockedRate = result1.rate;
+
+      const result2 = converter.convert('100', 'EUR', 'USD', { lockRate: true });
+
+      expect(result2.rate).toBe(lockedRate);
+      expect(result2.locked).toBe(true);
+    });
+
+    test('CurrencyConverter should clear locked rates', async () => {
+      converter.lockCurrentRate('EUR', 'USD');
+      converter.clearLockedRates();
+
+      const result = converter.convert('100', 'EUR', 'USD');
+      expect(result.locked).toBe(false);
+    });
+
+    test('getMinorUnits should return correct values for different currencies', () => {
+      expect(converter.getMinorUnits('USD')).toBe(2);
+      expect(converter.getMinorUnits('JPY')).toBe(0);
+      expect(converter.getMinorUnits('KWD')).toBe(3);
+      expect(converter.getMinorUnits('UNKNOWN')).toBe(2);
+    });
+
+    test('CURRENCY_MINOR_UNITS should include zero-decimal currencies', () => {
+      expect(CURRENCY_MINOR_UNITS['JPY']).toBe(0);
+      expect(CURRENCY_MINOR_UNITS['KRW']).toBe(0);
+    });
+
+    test('CURRENCY_MINOR_UNITS should include three-decimal currencies', () => {
+      expect(CURRENCY_MINOR_UNITS['KWD']).toBe(3);
+      expect(CURRENCY_MINOR_UNITS['BHD']).toBe(3);
+    });
+  });
+});
diff --git a/tests/components.test.ts b/tests/components.test.ts
new file mode 100644
index 0000000..a3aa885
--- /dev/null
+++ b/tests/components.test.ts
@@ -0,0 +1,419 @@
+/**
+ * Test suite for Front-end Components
+ * Tests Vue composables and component helper functions
+ */
+
+import {
+  CurrencyConverter,
+  DecimalMath,
+  CURRENCY_MINOR_UNITS,
+  SUPPORTED_CURRENCIES,
+  type ConversionResult,
+} from '../repository_after/utils/currencyConverter';
+
+// ============================================================================
+// Component Helper Functions (extracted for testing)
+// ============================================================================
+
+const getCurrencySymbol = (code: string): string => {
+  const symbols: Record<string, string> = {
+    EUR: '€', USD: '$', GBP: '£', JPY: '¥', CHF: 'CHF ',
+    CAD: 'C$', AUD: 'A$', CNY: '¥', INR: '₹', KWD: 'KD '
+  };
+  return symbols[code] || code + ' ';
+};
+
+const formatResult = (amount: string, currency: string): string => {
+  const symbol = getCurrencySymbol(currency);
+  return `${symbol}${amount}`;
+};
+
+const formatTimestamp = (ts: number): string => {
+  if (!ts) return 'N/A';
+  return new Date(ts).toLocaleString();
+};
+
+// ============================================================================
+// Composable Logic Tests (useCurrencyConverter)
+// ============================================================================
+
+describe('Front-end Components', () => {
+
+  describe('useCurrencyConverter composable logic', () => {
+    let converter: CurrencyConverter;
+
+    beforeEach(async () => {
+      converter = new CurrencyConverter();
+      await converter.initialize();
+    });
+
+    test('should initialize converter successfully', async () => {
+      const newConverter = new CurrencyConverter();
+      await newConverter.initialize();
+      expect(newConverter.getAvailableCurrencies().length).toBeGreaterThan(0);
+    });
+
+    test('should handle conversion errors gracefully', () => {
+      expect(() => converter.convert('abc', 'EUR', 'USD')).toThrow();
+    });
+
+    test('should return null for uninitialized converter operations', () => {
+      const uninitConverter = new CurrencyConverter();
+      expect(uninitConverter.getAvailableCurrencies()).toEqual([]);
+    });
+
+    test('should track loading state during initialization', async () => {
+      const newConverter = new CurrencyConverter();
+      // Before initialization, no currencies available
+      expect(newConverter.getAvailableCurrencies()).toEqual([]);
+
+      await newConverter.initialize();
+
+      // After initialization, currencies are available
+      expect(newConverter.getAvailableCurrencies().length).toBeGreaterThan(0);
+    });
+
+    test('should provide last result from conversion', () => {
+      const result = converter.convert('100', 'EUR', 'USD');
+      expect(result).not.toBeNull();
+      expect(result.fromAmount).toBe('100');
+      expect(result.fromCurrency).toBe('EUR');
+      expect(result.toCurrency).toBe('USD');
+    });
+
+    test('should handle rate locking in composable context', () => {
+      const rate1 = converter.lockCurrentRate('EUR', 'USD');
+      expect(rate1).toBeDefined();
+
+      const result = converter.convert('100', 'EUR', 'USD', { lockRate: true });
+      expect(result.locked).toBe(true);
+
+      converter.clearLockedRates();
+      const result2 = converter.convert('100', 'EUR', 'USD');
+      expect(result2.locked).toBe(false);
+    });
+
+    test('should search currencies correctly', () => {
+      const results = converter.searchCurrencies('dollar');
+      expect(results.length).toBeGreaterThan(0);
+      expect(results.some(c => c.code === 'USD')).toBe(true);
+    });
+
+    test('should detect stale data based on threshold', () => {
+      // With 0ms threshold, data should be stale
+      expect(converter.isDataStale(0)).toBe(true);
+
+      // With 1 hour threshold, freshly initialized data should not be stale
+      expect(converter.isDataStale(3600000)).toBe(false);
+    });
+
+    test('should provide rate metadata', () => {
+      const metadata = converter.getRateMetadata();
+      expect(metadata).not.toBeNull();
+      expect(metadata!.base).toBeDefined();
+      expect(metadata!.source).toBeDefined();
+    });
+  });
+
+  describe('CurrencyConverter.vue helper functions', () => {
+
+    test('getCurrencySymbol should return correct symbols for major currencies', () => {
+      expect(getCurrencySymbol('EUR')).toBe('€');
+      expect(getCurrencySymbol('USD')).toBe('$');
+      expect(getCurrencySymbol('GBP')).toBe('£');
+      expect(getCurrencySymbol('JPY')).toBe('¥');
+      expect(getCurrencySymbol('CHF')).toBe('CHF ');
+    });
+
+    test('getCurrencySymbol should return code with space for unknown currencies', () => {
+      expect(getCurrencySymbol('XYZ')).toBe('XYZ ');
+      expect(getCurrencySymbol('ABC')).toBe('ABC ');
+    });
+
+    test('formatResult should combine symbol and amount correctly', () => {
+      expect(formatResult('100.00', 'USD')).toBe('$100.00');
+      expect(formatResult('50.25', 'EUR')).toBe('€50.25');
+      expect(formatResult('1000', 'JPY')).toBe('¥1000');
+    });
+
+    test('formatResult should handle three-decimal currencies', () => {
+      expect(formatResult('10.123', 'KWD')).toBe('KD 10.123');
+    });
+
+    test('formatTimestamp should return N/A for zero timestamp', () => {
+      expect(formatTimestamp(0)).toBe('N/A');
+    });
+
+    test('formatTimestamp should format valid timestamps', () => {
+      const ts = new Date('2024-01-15T10:30:00').getTime();
+      const formatted = formatTimestamp(ts);
+      expect(formatted).not.toBe('N/A');
+      expect(formatted.length).toBeGreaterThan(0);
+    });
+
+    test('formatTimestamp should handle current timestamp', () => {
+      const now = Date.now();
+      const formatted = formatTimestamp(now);
+      expect(formatted).not.toBe('N/A');
+    });
+  });
+
+  describe('Component state management', () => {
+    let converter: CurrencyConverter;
+
+    beforeEach(async () => {
+      converter = new CurrencyConverter();
+      await converter.initialize();
+    });
+
+    test('should handle currency swap correctly', () => {
+      const result1 = converter.convert('100', 'EUR', 'USD');
+      const result2 = converter.convert('100', 'USD', 'EUR');
+
+      // Swapped conversion should have reversed currencies
+      expect(result1.fromCurrency).toBe('EUR');
+      expect(result1.toCurrency).toBe('USD');
+      expect(result2.fromCurrency).toBe('USD');
+      expect(result2.toCurrency).toBe('EUR');
+    });
+
+    test('should handle empty amount input', () => {
+      expect(() => converter.convert('', 'EUR', 'USD')).toThrow();
+    });
+
+    test('should handle invalid amount input', () => {
+      expect(() => converter.convert('not-a-number', 'EUR', 'USD')).toThrow();
+    });
+
+    test('should maintain available currencies list', () => {
+      const currencies = converter.getAvailableCurrencies();
+      expect(currencies).toContain('EUR');
+      expect(currencies).toContain('USD');
+      expect(Array.isArray(currencies)).toBe(true);
+    });
+
+    test('should handle lock/unlock toggle correctly', () => {
+      // Lock rate
+      converter.lockCurrentRate('EUR', 'USD');
+      const lockedResult = converter.convert('100', 'EUR', 'USD', { lockRate: true });
+      expect(lockedResult.locked).toBe(true);
+
+      // Unlock rate
+      converter.clearLockedRates();
+      const unlockedResult = converter.convert('100', 'EUR', 'USD');
+      expect(unlockedResult.locked).toBe(false);
+    });
+
+    test('should refresh rates and update timestamp', async () => {
+      const initialTimestamp = converter.getLastUpdated();
+
+      // Small delay to ensure different timestamp
+      await new Promise(resolve => setTimeout(resolve, 10));
+
+      await converter.refreshRates();
+      const newTimestamp = converter.getLastUpdated();
+
+      expect(newTimestamp).toBeGreaterThanOrEqual(initialTimestamp);
+    });
+  });
+
+  describe('Component error handling', () => {
+    let converter: CurrencyConverter;
+
+    beforeEach(async () => {
+      converter = new CurrencyConverter();
+      await converter.initialize();
+    });
+
+    test('should throw error for negative amounts by default', () => {
+      expect(() => converter.convert('-100', 'EUR', 'USD')).toThrow('Negative amounts not allowed');
+    });
+
+    test('should handle negative amounts when allowed', () => {
+      const result = converter.convert('-100', 'EUR', 'USD', { allowNegative: true });
+      expect(parseFloat(result.toAmount)).toBeLessThan(0);
+    });
+
+    test('should throw error for unsupported currency', () => {
+      expect(() => converter.convert('100', 'EUR', 'XYZ')).toThrow();
+    });
+
+    test('should throw error for invalid currency code format', () => {
+      expect(() => converter.convert('100', 'EURO', 'USD')).toThrow();
+    });
+
+    test('should display error message for failed conversion', () => {
+      try {
+        converter.convert('abc', 'EUR', 'USD');
+      } catch (e) {
+        expect(e instanceof Error).toBe(true);
+        expect((e as Error).message).toContain('Invalid');
+      }
+    });
+  });
+
+  describe('Component display formatting', () => {
+
+    test('should format JPY without decimal places', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const result = converter.convert('100', 'EUR', 'JPY');
+      expect(result.toAmount).not.toContain('.');
+      expect(result.roundedTo).toBe(0);
+    });
+
+    test('should format KWD with 3 decimal places', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const result = converter.convert('100', 'EUR', 'KWD');
+      expect(result.roundedTo).toBe(3);
+    });
+
+    test('should format USD with 2 decimal places', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const result = converter.convert('100', 'EUR', 'USD');
+      expect(result.roundedTo).toBe(2);
+    });
+
+    test('should provide raw unrounded value for audit display', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const result = converter.convert('100.123', 'EUR', 'USD');
+      expect(result.rawUnrounded).toBeDefined();
+      expect(result.toAmount).not.toBe(result.rawUnrounded);
+    });
+
+    test('should display rate in correct format', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const result = converter.convert('100', 'EUR', 'USD');
+      expect(DecimalMath.isValidNumber(result.rate)).toBe(true);
+      expect(parseFloat(result.rate)).toBeGreaterThan(0);
+    });
+
+    test('should display inverse rate', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const result = converter.convert('100', 'EUR', 'USD');
+      expect(DecimalMath.isValidNumber(result.inverseRate)).toBe(true);
+      expect(parseFloat(result.inverseRate)).toBeGreaterThan(0);
+    });
+  });
+
+  describe('Component metadata display', () => {
+
+    test('should display base currency in metadata', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const metadata = converter.getRateMetadata();
+      expect(metadata?.base).toBe('EUR');
+    });
+
+    test('should display source in metadata', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const metadata = converter.getRateMetadata();
+      expect(metadata?.source).toBeDefined();
+      expect(metadata?.source.length).toBeGreaterThan(0);
+    });
+
+    test('should display date in metadata', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const metadata = converter.getRateMetadata();
+      expect(metadata?.date).toBeDefined();
+      expect(metadata?.date).toMatch(/^\d{4}-\d{2}-\d{2}$/);
+    });
+
+    test('should display last updated timestamp', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const lastUpdated = converter.getLastUpdated();
+      expect(lastUpdated).toBeGreaterThan(0);
+      expect(lastUpdated).toBeLessThanOrEqual(Date.now());
+    });
+
+    test('should show stale warning when data is old', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      // With 0ms threshold, should be stale
+      expect(converter.isDataStale(0)).toBe(true);
+    });
+
+    test('should not show stale warning for fresh data', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      // With 1 hour threshold, should not be stale
+      expect(converter.isDataStale(3600000)).toBe(false);
+    });
+  });
+
+  describe('Currency selection UI logic', () => {
+
+    test('should provide list of available currencies for dropdown', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const currencies = converter.getAvailableCurrencies();
+      expect(currencies.length).toBeGreaterThan(0);
+      expect(currencies).toContain('EUR');
+      expect(currencies).toContain('USD');
+    });
+
+    test('should search currencies by code', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const results = converter.searchCurrencies('USD');
+      expect(results.length).toBeGreaterThan(0);
+      expect(results.some(c => c.code === 'USD')).toBe(true);
+    });
+
+    test('should search currencies by name', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const results = converter.searchCurrencies('Euro');
+      expect(results.length).toBeGreaterThan(0);
+      expect(results.some(c => c.code === 'EUR')).toBe(true);
+    });
+
+    test('should return empty array for no search matches', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      const results = converter.searchCurrencies('nonexistent');
+      expect(results).toEqual([]);
+    });
+
+    test('should validate currency code format for selection', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      expect(converter.isValidCurrencyCode('USD')).toBe(true);
+      expect(converter.isValidCurrencyCode('US')).toBe(false);
+      expect(converter.isValidCurrencyCode('USDD')).toBe(false);
+    });
+
+    test('should check if selected currency is supported', async () => {
+      const converter = new CurrencyConverter();
+      await converter.initialize();
+
+      expect(converter.isCurrencySupported('USD')).toBe(true);
+      expect(converter.isCurrencySupported('XYZ')).toBe(false);
+    });
+  });
+});
