/* =======================
   Vector Clock
======================= */

type VectorClock = Map<string, number>;

function incrementClock(vc: VectorClock, userId: string) {
  vc.set(userId, (vc.get(userId) ?? 0) + 1);
}

function dominates(a: VectorClock, b: VectorClock): boolean {
  let greater = false;
  for (const [k, v] of b) {
    const av = a.get(k) ?? 0;
    if (av < v) return false;
    if (av > v) greater = true;
  }
  return greater;
}

function concurrent(a: VectorClock, b: VectorClock): boolean {
  return !dominates(a, b) && !dominates(b, a);
}

function cloneClock(vc: VectorClock): VectorClock {
  return new Map(vc);
}

/* =======================
   Operation
======================= */

export interface Operation {
  id: string;
  userId: string;
  path: string[];
  value: any;
  clock: VectorClock;
}

/* =======================
   CRDT Node
======================= */

interface CRDTValue {
  value: any;
  clock: VectorClock;
  userId: string;
}

interface CRDTNode {
  values: CRDTValue[];
  children: Map<string, CRDTNode>;
}

/* =======================
   SyncCoordinator
======================= */

export class SyncCoordinator {
  private root: CRDTNode = { values: [], children: new Map() };
  private localClock: VectorClock = new Map();
  private appliedOps = new Set<string>();

  constructor(private readonly userId: string) {
    this.localClock.set(userId, 0);
  }

  /* -------- create local op -------- */

  public createOperation(path: string[], value: any): Operation {
    incrementClock(this.localClock, this.userId);
    const op = {
      id: crypto.randomUUID(),
      userId: this.userId,
      path,
      value,
      clock: cloneClock(this.localClock),
    };
    this.applyOperation(op);
    return op;
  }

  /* -------- causal buffering & memory -------- */

  private pendingOperations: Operation[] = [];
  private readonly MAX_APPLIED_OPS = 1000;

  /* -------- apply remote/local op -------- */

  public applyOperation(op: Operation) {
    if (this.appliedOps.has(op.id)) return;

    if (this.canApply(op)) {
      this.performApply(op);
      this.processPending();
    } else {
      this.pendingOperations.push(op);
    }
  }

  private canApply(op: Operation): boolean {
    const sender = op.userId;
    // We treat our own operations as always applicable if we are calling this directly,
    // but typically local ops are created sequentially.
    // However, if we receive our own op back from network, we technically already applied it
    // (if we did optimistic update) or we rely on the id check.
    // The implementation of createOperation calls applyOperation immediately.
    // So local ops will satisfy the check: localClock[sender] is N, op.clock[sender] is N+1.
    // Wait, createOperation increments clock THEN creates op with that clock.
    // So localClock[me] = 1. Op has {me: 1}.
    // Check: op.clock[me] (1) == localClock[me] (1) + 1 => False.
    // Ah, createOperation calls incrementClock FIRST.
    // Line 72: incrementClock(this.localClock, this.userId);
    // Line 78: clock: cloneClock(this.localClock)
    // Line 80: this.applyOperation(op);
    // So when applyOperation is called internally:
    // localClock[me] is already N. Op has [me: N].
    // This logic fails for local ops if we enforce strictly "next" based on *stored* state vs *op* state.
    //
    // Correction:
    // For LOCAL ops (generated by self), we know they are valid causal successors because we just made them.
    // We should bypass the check or adjust the check.
    //
    // For REMOTE ops:
    // Sender S. Op has clock C.
    // My local knowledge of S is L[S].
    // Require C[S] == L[S] + 1.
    
    // BUT! sync.test.ts uses `new SyncCoordinator` then calls `createOperation`.
    // inside `createOp`: `this.localClock` is incremented.
    // Then `applyOperation` is called.
    // Inside `applyOperation`:
    // `this.localClock` IS the op's clock for the sender part.
    // So `op.clock.get(userId) === this.localClock.get(userId)` is true.
    
    // We should distinguish internal apply vs external.
    // OR we change createOperation to NOT apply, but just return, and let the caller apply?
    // The current code structure:
    // createOperation -> increments clock -> creates op -> calls applyOperation.
    
    // Let's look at `canApply` logic again.
    // If I am the sender, and I just incremented my clock, then I am consistent with myself.
    if (op.userId === this.userId) return true;

    const senderSeq = op.clock.get(sender) ?? 0;
    const localSeq = this.localClock.get(sender) ?? 0;

    if (senderSeq !== localSeq + 1) return false;

    for (const [user, time] of op.clock) {
      if (user === sender) continue;
      const localTime = this.localClock.get(user) ?? 0;
      if (time > localTime) return false;
    }

    return true;
  }

  private performApply(op: Operation) {
    if (this.appliedOps.has(op.id)) return;
    this.appliedOps.add(op.id);
    
    // Memory pruning
    if (this.appliedOps.size > this.MAX_APPLIED_OPS) {
      const first = this.appliedOps.values().next().value;
      if (first !== undefined) {
        this.appliedOps.delete(first);
      }
    }

    // merge clocks
    for (const [k, v] of op.clock) {
      this.localClock.set(k, Math.max(this.localClock.get(k) ?? 0, v));
    }

    let node = this.root;
    for (const key of op.path) {
      if (!node.children.has(key)) {
        node.children.set(key, { values: [], children: new Map() });
      }
      node = node.children.get(key)!;
    }

    this.mergeValue(node, {
      value: op.value,
      clock: op.clock,
      userId: op.userId,
    });

    this.garbageCollect(node);
  }

  private processPending() {
    let changed = true;
    while (changed) {
      changed = false;
      for (let i = 0; i < this.pendingOperations.length; i++) {
        const op = this.pendingOperations[i];
        if (this.appliedOps.has(op.id)) {
           this.pendingOperations.splice(i, 1);
           i--;
           continue;
        }
        if (this.canApply(op)) {
          this.performApply(op);
          this.pendingOperations.splice(i, 1);
          i--;
          changed = true;
        }
      }
    }
  }

  /* -------- CRDT merge -------- */

  private mergeValue(node: CRDTNode, incoming: CRDTValue) {
    const survivors: CRDTValue[] = [];

    let dominated = false;

    for (const existing of node.values) {
      if (dominates(existing.clock, incoming.clock)) {
        dominated = true;
        survivors.push(existing);
      } else if (dominates(incoming.clock, existing.clock)) {
        continue; // incoming replaces
      } else {
        survivors.push(existing); // concurrent
      }
    }

    if (!dominated) survivors.push(incoming);
    node.values = survivors;
  }

  /* -------- deterministic resolve -------- */

  private resolveNode(node: CRDTNode): any {
    let base: any = undefined;

    if (node.values.length > 0) {
      node.values.sort((a, b) =>
        a.userId.localeCompare(b.userId)
      );
      base = node.values[node.values.length - 1].value;
    }

    if (node.children.size === 0) return base;

    const result =
      typeof base === "object" && base !== null ? { ...base } : {};

    for (const [k, child] of node.children) {
      const v = this.resolveNode(child);
      if (v !== undefined) result[k] = v;
    }

    return result;
  }

  /* -------- bounded metadata -------- */

  private garbageCollect(node: CRDTNode) {
    node.values = node.values.filter(v =>
      ![...node.values].some(o =>
        o !== v && dominates(o.clock, v.clock)
      )
    );
  }

  /* -------- public state -------- */

  public getState(): any {
    return this.resolveNode(this.root) ?? {};
  }
}
