diff --git a/repository_before/__init__.py b/repository_before/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/repository_after/__pycache__/__init__.cpython-314.pyc b/repository_after/__pycache__/__init__.cpython-314.pyc
new file mode 100644
index 0000000..15cf6cb
Binary files /dev/null and b/repository_after/__pycache__/__init__.cpython-314.pyc differ
diff --git a/repository_after/__pycache__/client.cpython-314.pyc b/repository_after/__pycache__/client.cpython-314.pyc
new file mode 100644
index 0000000..b89e82c
Binary files /dev/null and b/repository_after/__pycache__/client.cpython-314.pyc differ
diff --git a/repository_after/__pycache__/server.cpython-314.pyc b/repository_after/__pycache__/server.cpython-314.pyc
new file mode 100644
index 0000000..b66cd15
Binary files /dev/null and b/repository_after/__pycache__/server.cpython-314.pyc differ
diff --git a/repository_after/client.py b/repository_after/client.py
new file mode 100644
index 0000000..ac808cb
--- /dev/null
+++ b/repository_after/client.py
@@ -0,0 +1,112 @@
+import httpx
+import uuid
+
+
+class TransactionOrchestrator:
+    def __init__(self, base_url: str):
+        self.base_url = base_url
+        self.client = httpx.Client(timeout=10.0)
+    
+    def transfer(self, source_user: str, target_user: str, amount: float):
+        # Single saga ID for the entire transaction
+        saga_id = str(uuid.uuid4())
+        
+        try:
+            # Step 1: Debit source user
+            debit_response = self.client.post(
+                f"{self.base_url}/debit",
+                json={"user": source_user, "amount": amount},
+                headers={"transaction-id": saga_id}  # Same saga ID
+            )
+            debit_response.raise_for_status()
+            
+            # Step 2: Credit target user
+            credit_response = self.client.post(
+                f"{self.base_url}/credit",
+                json={"user": target_user, "amount": amount},
+                headers={"transaction-id": saga_id}  # Same saga ID
+            )
+            credit_response.raise_for_status()
+            
+            return {"status": "success", "saga_id": saga_id}
+        
+        except httpx.HTTPStatusError as e:
+            if e.response.status_code == 500:
+                # Compensate: refund the source user
+                compensate_response = self.client.post(
+                    f"{self.base_url}/compensate_debit",
+                    json={"user": source_user, "amount": amount},
+                    headers={"transaction-id": saga_id}  # Same saga ID
+                )
+                compensate_response.raise_for_status()
+                return {"status": "rolled_back", "saga_id": saga_id}
+            raise
+    
+    def get_saga_state(self, saga_id: str):
+        response = self.client.get(f"{self.base_url}/saga/{saga_id}")
+        response.raise_for_status()
+        return response.json()
+    
+    def close(self):
+        self.client.close()
+
+
+def run_demo():
+    import time
+    from multiprocessing import Process
+    import uvicorn
+    
+    # Start server in background
+    def start_server():
+        from repository_after.server import app
+        uvicorn.run(app, host="127.0.0.1", port=8000, log_level="error")
+    
+    server_process = Process(target=start_server)
+    server_process.start()
+    time.sleep(2)  # Wait for server to start
+    
+    try:
+        orchestrator = TransactionOrchestrator("http://127.0.0.1:8000")
+        
+        # Get initial balances
+        initial_response = httpx.get("http://127.0.0.1:8000/balances")
+        initial_balances = initial_response.json()
+        initial_total = sum(initial_balances.values())
+        
+        print(f"Initial balances: {initial_balances}")
+        print(f"Initial total: {initial_total}")
+        
+        # Run 100 transfers
+        success_count = 0
+        rollback_count = 0
+        users = list(initial_balances.keys())
+        
+        for i in range(100):
+            source = users[i % len(users)]
+            target = users[(i + 1) % len(users)]
+            result = orchestrator.transfer(source, target, 10)
+            
+            if result["status"] == "success":
+                success_count += 1
+            else:
+                rollback_count += 1
+        
+        # Get final balances
+        final_response = httpx.get("http://127.0.0.1:8000/balances")
+        final_balances = final_response.json()
+        final_total = sum(final_balances.values())
+        
+        print(f"\nFinal balances: {final_balances}")
+        print(f"Final total: {final_total}")
+        print(f"\nSuccessful transfers: {success_count}")
+        print(f"Rolled back transfers: {rollback_count}")
+        print(f"Total money preserved: {initial_total == final_total}")
+        
+        orchestrator.close()
+    finally:
+        server_process.terminate()
+        server_process.join()
+
+
+if __name__ == "__main__":
+    run_demo()
diff --git a/repository_after/server.py b/repository_after/server.py
new file mode 100644
index 0000000..a1ade18
--- /dev/null
+++ b/repository_after/server.py
@@ -0,0 +1,135 @@
+from fastapi import FastAPI, HTTPException, Request
+from pydantic import BaseModel
+from enum import Enum
+import random
+
+app = FastAPI()
+
+class SagaState(str, Enum):
+    PENDING = "PENDING"
+    DEBITED = "DEBITED"
+    CREDITED = "CREDITED"
+    COMPENSATED = "COMPENSATED"
+
+balances = {"alice": 1000, "bob": 1000, "charlie": 1000}
+saga_states = {}  # saga_id -> {state, source_user, target_user, amount, results}
+
+
+class TransactionRequest(BaseModel):
+    user: str
+    amount: float
+
+
+@app.post("/debit")
+async def debit(request: TransactionRequest, req: Request):
+    transaction_id = req.headers.get("transaction-id")
+    if not transaction_id:
+        raise HTTPException(status_code=400, detail="transaction-id header is required")
+    
+    # Check if this saga already processed this step
+    if transaction_id in saga_states:
+        saga = saga_states[transaction_id]
+        if saga["state"] in [SagaState.DEBITED, SagaState.CREDITED, SagaState.COMPENSATED]:
+            return {"status": "success", "message": "already processed", "balance": saga.get("debit_result")}
+    
+    if request.user not in balances:
+        raise HTTPException(status_code=404, detail="user not found")
+    
+    balances[request.user] -= request.amount
+    result_balance = balances[request.user]
+    
+    # Track saga state
+    saga_states[transaction_id] = {
+        "state": SagaState.DEBITED,
+        "source_user": request.user,
+        "amount": request.amount,
+        "debit_result": result_balance
+    }
+    
+    return {"status": "success", "balance": result_balance}
+
+
+@app.post("/credit")
+async def credit(request: TransactionRequest, req: Request):
+    transaction_id = req.headers.get("transaction-id")
+    if not transaction_id:
+        raise HTTPException(status_code=400, detail="transaction-id header is required")
+    
+    # Check saga state
+    if transaction_id not in saga_states:
+        raise HTTPException(status_code=400, detail="saga not found - must call /debit first")
+    
+    saga = saga_states[transaction_id]
+    
+    # Idempotency: if already credited, return success
+    if saga["state"] == SagaState.CREDITED:
+        return {"status": "success", "message": "already processed", "balance": saga.get("credit_result")}
+    
+    # Cannot credit if already compensated
+    if saga["state"] == SagaState.COMPENSATED:
+        raise HTTPException(status_code=400, detail="saga already compensated")
+    
+    # Fault injection: 30% failure rate
+    if random.random() < 0.3:
+        raise HTTPException(status_code=500, detail="Internal Server Error")
+    
+    if request.user not in balances:
+        raise HTTPException(status_code=404, detail="user not found")
+    
+    balances[request.user] += request.amount
+    result_balance = balances[request.user]
+    
+    # Update saga state
+    saga["state"] = SagaState.CREDITED
+    saga["target_user"] = request.user
+    saga["credit_result"] = result_balance
+    
+    return {"status": "success", "balance": result_balance}
+
+
+@app.post("/compensate_debit")
+async def compensate_debit(request: TransactionRequest, req: Request):
+    transaction_id = req.headers.get("transaction-id")
+    if not transaction_id:
+        raise HTTPException(status_code=400, detail="transaction-id header is required")
+    
+    # Check saga state
+    if transaction_id not in saga_states:
+        raise HTTPException(status_code=400, detail="saga not found - must call /debit first")
+    
+    saga = saga_states[transaction_id]
+    
+    # Idempotency: if already compensated, return success
+    if saga["state"] == SagaState.COMPENSATED:
+        return {"status": "success", "message": "already compensated", "balance": saga.get("compensate_result")}
+    
+    # Cannot compensate if already credited
+    if saga["state"] == SagaState.CREDITED:
+        raise HTTPException(status_code=400, detail="saga already completed - cannot compensate")
+    
+    # Must be in DEBITED state to compensate
+    if saga["state"] != SagaState.DEBITED:
+        raise HTTPException(status_code=400, detail="saga not in DEBITED state")
+    
+    if request.user not in balances:
+        raise HTTPException(status_code=404, detail="user not found")
+    
+    balances[request.user] += request.amount
+    result_balance = balances[request.user]
+    
+    # Update saga state
+    saga["state"] = SagaState.COMPENSATED
+    saga["compensate_result"] = result_balance
+    
+    return {"status": "success", "balance": result_balance}
+
+
+@app.get("/balances")
+def get_balances():
+    return balances
+
+@app.get("/saga/{saga_id}")
+def get_saga_state(saga_id: str):
+    if saga_id not in saga_states:
+        raise HTTPException(status_code=404, detail="saga not found")
+    return saga_states[saga_id]
