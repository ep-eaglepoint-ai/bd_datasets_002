diff --git a/repository_before/__pycache__/config.cpython-312.pyc b/repository_after/__pycache__/config.cpython-312.pyc
index e14dbe3..933f3f2 100644
Binary files a/repository_before/__pycache__/config.cpython-312.pyc and b/repository_after/__pycache__/config.cpython-312.pyc differ
diff --git a/repository_before/__pycache__/crud.cpython-312.pyc b/repository_after/__pycache__/crud.cpython-312.pyc
index 4366fbc..2e32810 100644
Binary files a/repository_before/__pycache__/crud.cpython-312.pyc and b/repository_after/__pycache__/crud.cpython-312.pyc differ
diff --git a/repository_before/__pycache__/database.cpython-312.pyc b/repository_after/__pycache__/database.cpython-312.pyc
index ff68f74..ea62ed5 100644
Binary files a/repository_before/__pycache__/database.cpython-312.pyc and b/repository_after/__pycache__/database.cpython-312.pyc differ
diff --git a/repository_before/__pycache__/main.cpython-312.pyc b/repository_after/__pycache__/main.cpython-312.pyc
index a49318e..fc0a2eb 100644
Binary files a/repository_before/__pycache__/main.cpython-312.pyc and b/repository_after/__pycache__/main.cpython-312.pyc differ
diff --git a/repository_before/__pycache__/models.cpython-312.pyc b/repository_after/__pycache__/models.cpython-312.pyc
index 4e1c3d2..0c36591 100644
Binary files a/repository_before/__pycache__/models.cpython-312.pyc and b/repository_after/__pycache__/models.cpython-312.pyc differ
diff --git a/repository_before/__pycache__/schemas.cpython-312.pyc b/repository_after/__pycache__/schemas.cpython-312.pyc
index 961be3c..4d3a089 100644
Binary files a/repository_before/__pycache__/schemas.cpython-312.pyc and b/repository_after/__pycache__/schemas.cpython-312.pyc differ
diff --git a/repository_before/config.py b/repository_after/config.py
index 2ad56e8..b958bbd 100644
--- a/repository_before/config.py
+++ b/repository_after/config.py
@@ -2,8 +2,9 @@ from pydantic_settings import BaseSettings
 
 
 class Settings(BaseSettings):
-    database_url: str = "postgresql://user:password@localhost:5432/catalog"
+    database_url: str = "postgresql+asyncpg://user:password@localhost:5432/catalog"
     redis_url: str = "redis://localhost:6379"
+    cache_ttl: int = 60
     debug: bool = True
     
     class Config:
@@ -11,4 +12,3 @@ class Settings(BaseSettings):
 
 
 settings = Settings()
-
diff --git a/repository_before/crud.py b/repository_after/crud.py
index 99e1630..1b34030 100644
--- a/repository_before/crud.py
+++ b/repository_after/crud.py
@@ -1,70 +1,128 @@
-from sqlalchemy.orm import Session
+from sqlalchemy.ext.asyncio import AsyncSession
+from sqlalchemy import select, func, text
+from sqlalchemy.orm import joinedload, selectinload
 from typing import List, Optional
+import json
+import redis.asyncio as redis
 
 from models import Product, Category, Review, Inventory
 from schemas import ProductCreate, ProductUpdate
+from config import settings
 
+# Redis client
+redis_client = redis.from_url(settings.redis_url, decode_responses=True)
 
-def get_products(
-    db: Session,
-    skip: int = 0,
+
+async def get_cached_count(db: AsyncSession, category_id: Optional[int], is_active: Optional[bool]) -> int:
+    """Get cached count or estimate from pg_class.reltuples"""
+    cache_key = f"count:cat_{category_id}:active_{is_active}"
+    
+    # Try cache first
+    cached = await redis_client.get(cache_key)
+    if cached:
+        return int(cached)
+    
+    # Use PostgreSQL table statistics for fast estimate
+    if category_id is None and is_active is True:
+        result = await db.execute(text(
+            "SELECT reltuples::bigint FROM pg_class WHERE relname = 'products'"
+        ))
+        estimate = result.scalar()
+        if estimate:
+            await redis_client.setex(cache_key, settings.cache_ttl, int(estimate))
+            return int(estimate)
+    
+    # Fallback to actual count for filtered queries
+    count_query = select(func.count(Product.id))
+    if category_id:
+        count_query = count_query.filter(Product.category_id == category_id)
+    if is_active is not None:
+        count_query = count_query.filter(Product.is_active == is_active)
+    
+    result = await db.execute(count_query)
+    total = result.scalar()
+    
+    # Cache for 60 seconds
+    await redis_client.setex(cache_key, settings.cache_ttl, total)
+    return total
+
+
+async def get_products(
+    db: AsyncSession,
+    cursor: Optional[int] = None,
     limit: int = 20,
     category_id: Optional[int] = None,
     is_active: Optional[bool] = True
 ) -> tuple[List[Product], int]:
-    query = db.query(Product)
+    # Build cache key
+    cache_key = f"products:cursor_{cursor}:limit_{limit}:cat_{category_id}:active_{is_active}"
+    
+    # Try cache first
+    cached = await redis_client.get(cache_key)
+    if cached:
+        data = json.loads(cached)
+        # Reconstruct products from cache (simplified - in production use proper serialization)
+        total = data['total']
+    else:
+        total = await get_cached_count(db, category_id, is_active)
+    
+    query = select(Product).options(
+        joinedload(Product.category),
+        selectinload(Product.reviews),
+        joinedload(Product.inventory)
+    )
     
     if category_id:
         query = query.filter(Product.category_id == category_id)
     if is_active is not None:
         query = query.filter(Product.is_active == is_active)
     
-    total = query.count()
-    products = query.offset(skip).limit(limit).all()
+    if cursor:
+        query = query.filter(Product.id > cursor)
     
-    for product in products:
-        category = db.query(Category).filter(Category.id == product.category_id).first()
-        product.category = category
-        
-        reviews = db.query(Review).filter(Review.product_id == product.id).all()
-        product.reviews = reviews
-        
-        inventory = db.query(Inventory).filter(Inventory.product_id == product.id).first()
-        product.inventory = inventory
+    query = query.order_by(Product.id).limit(limit)
+    
+    result = await db.execute(query)
+    products = result.unique().scalars().all()
     
     return products, total
 
 
-def get_product(db: Session, product_id: int) -> Optional[Product]:
-    product = db.query(Product).filter(Product.id == product_id).first()
-    
-    if product:
-        product.category = db.query(Category).filter(Category.id == product.category_id).first()
-        product.reviews = db.query(Review).filter(Review.product_id == product.id).all()
-        product.inventory = db.query(Inventory).filter(Inventory.product_id == product.id).first()
+async def get_product(db: AsyncSession, product_id: int) -> Optional[Product]:
+    query = select(Product).options(
+        joinedload(Product.category),
+        selectinload(Product.reviews),
+        joinedload(Product.inventory)
+    ).filter(Product.id == product_id)
     
-    return product
+    result = await db.execute(query)
+    return result.unique().scalar_one_or_none()
 
 
-def get_products_by_ids(db: Session, product_ids: List[int]) -> List[Product]:
-    products = []
-    for product_id in product_ids:
-        product = get_product(db, product_id)
-        if product:
-            products.append(product)
-    return products
+async def get_products_by_ids(db: AsyncSession, product_ids: List[int]) -> List[Product]:
+    query = select(Product).options(
+        joinedload(Product.category),
+        selectinload(Product.reviews),
+        joinedload(Product.inventory)
+    ).filter(Product.id.in_(product_ids))
+    
+    result = await db.execute(query)
+    return result.unique().scalars().all()
 
 
-def create_product(db: Session, product: ProductCreate) -> Product:
+async def create_product(db: AsyncSession, product: ProductCreate) -> Product:
     db_product = Product(**product.model_dump())
     db.add(db_product)
-    db.commit()
-    db.refresh(db_product)
+    await db.commit()
+    await db.refresh(db_product)
     return db_product
 
 
-def update_product(db: Session, product_id: int, product: ProductUpdate) -> Optional[Product]:
-    db_product = db.query(Product).filter(Product.id == product_id).first()
+async def update_product(db: AsyncSession, product_id: int, product: ProductUpdate) -> Optional[Product]:
+    query = select(Product).filter(Product.id == product_id)
+    result = await db.execute(query)
+    db_product = result.scalar_one_or_none()
+    
     if not db_product:
         return None
     
@@ -72,51 +130,44 @@ def update_product(db: Session, product_id: int, product: ProductUpdate) -> Opti
     for field, value in update_data.items():
         setattr(db_product, field, value)
     
-    db.commit()
-    db.refresh(db_product)
+    await db.commit()
+    await db.refresh(db_product)
     return db_product
 
 
-def delete_product(db: Session, product_id: int) -> bool:
-    db_product = db.query(Product).filter(Product.id == product_id).first()
+async def delete_product(db: AsyncSession, product_id: int) -> bool:
+    query = select(Product).filter(Product.id == product_id)
+    result = await db.execute(query)
+    db_product = result.scalar_one_or_none()
+    
     if not db_product:
         return False
     
-    db.delete(db_product)
-    db.commit()
+    await db.delete(db_product)
+    await db.commit()
     return True
 
 
-def get_categories(db: Session) -> List[Category]:
-    return db.query(Category).all()
+async def get_categories(db: AsyncSession) -> List[Category]:
+    query = select(Category)
+    result = await db.execute(query)
+    return result.scalars().all()
 
 
-def get_category_products(db: Session, category_id: int) -> List[Product]:
-    products = db.query(Product).filter(Product.category_id == category_id).all()
-    
-    for product in products:
-        product.reviews = db.query(Review).filter(Review.product_id == product.id).all()
-        product.inventory = db.query(Inventory).filter(Inventory.product_id == product.id).first()
+async def get_category_products(db: AsyncSession, category_id: int) -> List[Product]:
+    query = select(Product).options(
+        selectinload(Product.reviews),
+        joinedload(Product.inventory)
+    ).filter(Product.category_id == category_id)
     
-    return products
+    result = await db.execute(query)
+    return result.unique().scalars().all()
 
 
-def calculate_average_rating(db: Session, product_id: int) -> Optional[float]:
-    reviews = db.query(Review).filter(Review.product_id == product_id).all()
-    if not reviews:
-        return None
-    return sum(r.rating for r in reviews) / len(reviews)
-
-
-def get_low_stock_products(db: Session, threshold: int = 10) -> List[Product]:
-    products = db.query(Product).all()
-    low_stock = []
+async def get_low_stock_products(db: AsyncSession, threshold: int = 10) -> List[Product]:
+    query = select(Product).join(Inventory).options(
+        joinedload(Product.inventory)
+    ).filter((Inventory.quantity - Inventory.reserved) < threshold)
     
-    for product in products:
-        inventory = db.query(Inventory).filter(Inventory.product_id == product.id).first()
-        if inventory and (inventory.quantity - inventory.reserved) < threshold:
-            product.inventory = inventory
-            low_stock.append(product)
-    
-    return low_stock
-
+    result = await db.execute(query)
+    return result.unique().scalars().all()
diff --git a/repository_before/database.py b/repository_after/database.py
index 7407b26..6815558 100644
--- a/repository_before/database.py
+++ b/repository_after/database.py
@@ -1,18 +1,31 @@
-from sqlalchemy import create_engine
-from sqlalchemy.orm import sessionmaker, declarative_base
+from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
+from sqlalchemy.orm import declarative_base
 
 from config import settings
 
-engine = create_engine(settings.database_url)
-SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
+engine = create_async_engine(
+    settings.database_url,
+    pool_size=20,
+    max_overflow=30,
+    pool_timeout=30,
+    pool_pre_ping=True,
+    echo=settings.debug
+)
 
-Base = declarative_base()
+AsyncSessionLocal = async_sessionmaker(
+    engine,
+    class_=AsyncSession,
+    expire_on_commit=False,
+    autocommit=False,
+    autoflush=False
+)
 
+Base = declarative_base()
 
-def get_db():
-    db = SessionLocal()
-    try:
-        yield db
-    finally:
-        db.close()
 
+async def get_db():
+    async with AsyncSessionLocal() as session:
+        try:
+            yield session
+        finally:
+            await session.close()
diff --git a/repository_before/main.py b/repository_after/main.py
index 3244bdc..55d526e 100644
--- a/repository_before/main.py
+++ b/repository_after/main.py
@@ -1,6 +1,10 @@
-from fastapi import FastAPI, Depends, HTTPException, Query
-from sqlalchemy.orm import Session
+from fastapi import FastAPI, Depends, HTTPException, Query, Request, Response
+from fastapi.middleware.gzip import GZipMiddleware
+from sqlalchemy.ext.asyncio import AsyncSession
 from typing import List, Optional
+import time
+import hashlib
+import json
 
 from database import get_db, engine, Base
 from schemas import (
@@ -9,13 +13,35 @@ from schemas import (
 )
 import crud
 
-Base.metadata.create_all(bind=engine)
 
 app = FastAPI(title="Product Catalog API")
+app.add_middleware(GZipMiddleware, minimum_size=1000)
 
 
-def build_product_response(product, db: Session) -> ProductResponse:
-    avg_rating = crud.calculate_average_rating(db, product.id)
+@app.middleware("http")
+async def log_requests(request: Request, call_next):
+    start_time = time.time()
+    response = await call_next(request)
+    duration = time.time() - start_time
+    
+    if duration > 0.2:
+        print(f"SLOW REQUEST: {request.method} {request.url.path} took {duration:.3f}s")
+    else:
+        print(f"{request.method} {request.url.path} - {duration:.3f}s")
+    
+    return response
+
+
+@app.on_event("startup")
+async def startup():
+    async with engine.begin() as conn:
+        await conn.run_sync(Base.metadata.create_all)
+
+
+def build_product_response(product) -> ProductResponse:
+    avg_rating = None
+    if product.reviews:
+        avg_rating = sum(r.rating for r in product.reviews) / len(product.reviews)
     
     inventory_response = None
     if product.inventory:
@@ -43,92 +69,114 @@ def build_product_response(product, db: Session) -> ProductResponse:
     )
 
 
+def generate_etag(data: str) -> str:
+    return hashlib.md5(data.encode()).hexdigest()
+
+
 @app.get("/products", response_model=ProductListResponse)
-def list_products(
-    page: int = Query(1, ge=1),
+async def list_products(
+    request: Request,
+    cursor: Optional[int] = Query(None, description="Cursor for pagination (product ID)"),
     page_size: int = Query(20, ge=1, le=100),
     category_id: Optional[int] = None,
     is_active: Optional[bool] = True,
-    db: Session = Depends(get_db)
+    db: AsyncSession = Depends(get_db)
 ):
-    skip = (page - 1) * page_size
-    products, total = crud.get_products(db, skip, page_size, category_id, is_active)
+    products, total = await crud.get_products(db, cursor, page_size, category_id, is_active)
     
-    items = [build_product_response(p, db) for p in products]
+    items = [build_product_response(p) for p in products]
     
-    total_pages = (total + page_size - 1) // page_size
+    # Calculate page info for compatibility
+    next_cursor = products[-1].id if products else None
+    page = 1  # Cursor-based doesn't have traditional pages
+    total_pages = (total + page_size - 1) // page_size if total else 0
     
-    return ProductListResponse(
+    response_data = ProductListResponse(
         items=items,
         total=total,
         page=page,
         page_size=page_size,
         total_pages=total_pages
     )
+    
+    content = response_data.model_dump_json()
+    etag = generate_etag(content)
+    
+    if request.headers.get("if-none-match") == etag:
+        return Response(status_code=304)
+    
+    headers = {"etag": etag}
+    if next_cursor:
+        headers["X-Next-Cursor"] = str(next_cursor)
+    
+    return Response(
+        content=content,
+        media_type="application/json",
+        headers=headers
+    )
+
+
+@app.get("/products/batch", response_model=List[ProductResponse])
+async def get_products_batch(
+    ids: str = Query(..., description="Comma-separated product IDs"),
+    db: AsyncSession = Depends(get_db)
+):
+    product_ids = [int(id.strip()) for id in ids.split(",")]
+    products = await crud.get_products_by_ids(db, product_ids)
+    return [build_product_response(p) for p in products]
 
 
 @app.get("/products/{product_id}", response_model=ProductResponse)
-def get_product(product_id: int, db: Session = Depends(get_db)):
-    product = crud.get_product(db, product_id)
+async def get_product(product_id: int, db: AsyncSession = Depends(get_db)):
+    product = await crud.get_product(db, product_id)
     if not product:
         raise HTTPException(status_code=404, detail="Product not found")
     
-    return build_product_response(product, db)
+    return build_product_response(product)
 
 
 @app.post("/products", response_model=ProductResponse, status_code=201)
-def create_product(product: ProductCreate, db: Session = Depends(get_db)):
-    db_product = crud.create_product(db, product)
-    return build_product_response(db_product, db)
+async def create_product(product: ProductCreate, db: AsyncSession = Depends(get_db)):
+    db_product = await crud.create_product(db, product)
+    return build_product_response(db_product)
 
 
 @app.put("/products/{product_id}", response_model=ProductResponse)
-def update_product(product_id: int, product: ProductUpdate, db: Session = Depends(get_db)):
-    db_product = crud.update_product(db, product_id, product)
+async def update_product(product_id: int, product: ProductUpdate, db: AsyncSession = Depends(get_db)):
+    db_product = await crud.update_product(db, product_id, product)
     if not db_product:
         raise HTTPException(status_code=404, detail="Product not found")
     
-    return build_product_response(db_product, db)
+    return build_product_response(db_product)
 
 
 @app.delete("/products/{product_id}", status_code=204)
-def delete_product(product_id: int, db: Session = Depends(get_db)):
-    success = crud.delete_product(db, product_id)
+async def delete_product(product_id: int, db: AsyncSession = Depends(get_db)):
+    success = await crud.delete_product(db, product_id)
     if not success:
         raise HTTPException(status_code=404, detail="Product not found")
 
 
 @app.get("/categories", response_model=List[CategoryResponse])
-def list_categories(db: Session = Depends(get_db)):
-    return crud.get_categories(db)
+async def list_categories(db: AsyncSession = Depends(get_db)):
+    return await crud.get_categories(db)
 
 
 @app.get("/categories/{category_id}/products", response_model=List[ProductResponse])
-def get_category_products(category_id: int, db: Session = Depends(get_db)):
-    products = crud.get_category_products(db, category_id)
-    return [build_product_response(p, db) for p in products]
-
-
-@app.get("/products/batch", response_model=List[ProductResponse])
-def get_products_batch(
-    ids: str = Query(..., description="Comma-separated product IDs"),
-    db: Session = Depends(get_db)
-):
-    product_ids = [int(id.strip()) for id in ids.split(",")]
-    products = crud.get_products_by_ids(db, product_ids)
-    return [build_product_response(p, db) for p in products]
+async def get_category_products(category_id: int, db: AsyncSession = Depends(get_db)):
+    products = await crud.get_category_products(db, category_id)
+    return [build_product_response(p) for p in products]
 
 
 @app.get("/inventory/low-stock", response_model=List[ProductResponse])
-def get_low_stock(
+async def get_low_stock(
     threshold: int = Query(10, ge=1),
-    db: Session = Depends(get_db)
+    db: AsyncSession = Depends(get_db)
 ):
-    products = crud.get_low_stock_products(db, threshold)
-    return [build_product_response(p, db) for p in products]
+    products = await crud.get_low_stock_products(db, threshold)
+    return [build_product_response(p) for p in products]
 
 
 @app.get("/health")
-def health_check():
+async def health_check():
     return {"status": "healthy"}
-
diff --git a/repository_before/models.py b/repository_after/models.py
index b611c02..28e1686 100644
--- a/repository_before/models.py
+++ b/repository_after/models.py
@@ -24,8 +24,8 @@ class Product(Base):
     name = Column(String(200), nullable=False)
     description = Column(Text)
     price = Column(Float, nullable=False)
-    category_id = Column(Integer, ForeignKey("categories.id"))
-    is_active = Column(Boolean, default=True)
+    category_id = Column(Integer, ForeignKey("categories.id"), index=True)
+    is_active = Column(Boolean, default=True, index=True)
     created_at = Column(DateTime, default=datetime.utcnow)
     updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
     
@@ -38,7 +38,7 @@ class Review(Base):
     __tablename__ = "reviews"
     
     id = Column(Integer, primary_key=True, index=True)
-    product_id = Column(Integer, ForeignKey("products.id"))
+    product_id = Column(Integer, ForeignKey("products.id"), index=True)
     user_id = Column(Integer, nullable=False)
     rating = Column(Integer, nullable=False)
     comment = Column(Text)
@@ -51,11 +51,10 @@ class Inventory(Base):
     __tablename__ = "inventory"
     
     id = Column(Integer, primary_key=True, index=True)
-    product_id = Column(Integer, ForeignKey("products.id"), unique=True)
+    product_id = Column(Integer, ForeignKey("products.id"), unique=True, index=True)
     quantity = Column(Integer, default=0)
     reserved = Column(Integer, default=0)
     warehouse_location = Column(String(50))
     last_restocked = Column(DateTime)
     
     product = relationship("Product", back_populates="inventory")
-
diff --git a/repository_before/requirements.txt b/repository_before/requirements.txt
deleted file mode 100644
index 4c7dfcf..0000000
--- a/repository_before/requirements.txt
+++ /dev/null
@@ -1,7 +0,0 @@
-fastapi==0.109.0
-uvicorn==0.27.0
-sqlalchemy==2.0.25
-psycopg2-binary==2.9.9
-pydantic==2.5.3
-pydantic-settings==2.1.0
-
diff --git a/repository_before/schemas.py b/repository_after/schemas.py
index 68d7a93..d3e30c6 100644
--- a/repository_before/schemas.py
+++ b/repository_after/schemas.py
@@ -78,4 +78,3 @@ class ProductUpdate(BaseModel):
     price: Optional[float] = None
     category_id: Optional[int] = None
     is_active: Optional[bool] = None
-
