--- repository_before/repository_after/.gitignore	2026-01-28 12:47:12
+++ repository_after/.gitignore	2026-01-28 12:36:14
@@ -0,0 +1,97 @@
+# Dependencies
+node_modules/
+npm-debug.log*
+yarn-debug.log*
+yarn-error.log*
+
+# Next.js build outputs
+.next/
+out/
+build/
+dist/
+
+# Environment variables
+.env
+.env.local
+.env.development.local
+.env.test.local
+.env.production.local
+
+# IDE and editor files
+.vscode/
+.idea/
+*.swp
+*.swo
+*~
+
+# OS generated files
+.DS_Store
+.DS_Store?
+._*
+.Spotlight-V100
+.Trashes
+ehthumbs.db
+Thumbs.db
+
+# Logs
+logs
+*.log
+
+# Runtime data
+pids
+*.pid
+*.seed
+*.pid.lock
+
+# Coverage directory used by tools like istanbul
+coverage/
+*.lcov
+
+# nyc test coverage
+.nyc_output
+
+# Dependency directories
+jspm_packages/
+
+# Optional npm cache directory
+.npm
+
+# Optional eslint cache
+.eslintcache
+
+# Optional REPL history
+.node_repl_history
+
+# Output of 'npm pack'
+*.tgz
+
+# Yarn Integrity file
+.yarn-integrity
+
+# parcel-bundler cache (https://parceljs.org/)
+.cache
+.parcel-cache
+
+# next.js build output
+.next
+
+# nuxt.js build output
+.nuxt
+
+# vuepress build output
+.vuepress/dist
+
+# Serverless directories
+.serverless
+
+# FuseBox cache
+.fusebox/
+
+# DynamoDB Local files
+.dynamodb/
+
+# TernJS port file
+.tern-port
+
+# SWC
+.swc/
--- repository_before/repository_after/jest.config.js	2026-01-28 12:47:12
+++ repository_after/jest.config.js	2026-01-28 11:40:44
@@ -0,0 +1,21 @@
+const nextJest = require('next/jest')
+
+const createJestConfig = nextJest({
+  // Provide the path to your Next.js app to load next.config.js and .env files
+  dir: './',
+})
+
+// Add any custom config to be passed to Jest
+const customJestConfig = {
+  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
+  moduleNameMapper: {
+    '^@/(.*)$': '<rootDir>/src/$1',
+  },
+  testEnvironment: 'jest-environment-jsdom',
+  testMatch: ['**/tests/**/*.test.ts', '**/tests/**/*.test.tsx'],
+  testPathIgnorePatterns: ['/node_modules/', '/.next/'],
+  roots: ['<rootDir>/..'],
+}
+
+// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
+module.exports = createJestConfig(customJestConfig)
--- repository_before/repository_after/jest.setup.js	2026-01-28 12:47:12
+++ repository_after/jest.setup.js	2026-01-28 10:14:56
@@ -0,0 +1 @@
+import '@testing-library/jest-dom'
--- repository_before/repository_after/next-env.d.ts	2026-01-28 12:47:12
+++ repository_after/next-env.d.ts	2026-01-28 09:59:49
@@ -0,0 +1,5 @@
+/// <reference types="next" />
+/// <reference types="next/image-types/global" />
+
+// NOTE: This file should not be edited
+// see https://nextjs.org/docs/basic-features/typescript for more information.
--- repository_before/repository_after/next.config.js	2026-01-28 12:47:12
+++ repository_after/next.config.js	2026-01-28 09:32:29
@@ -0,0 +1,15 @@
+/** @type {import('next').NextConfig} */
+const nextConfig = {
+  experimental: {
+    appDir: true,
+  },
+  webpack: (config) => {
+    config.resolve.fallback = {
+      ...config.resolve.fallback,
+      fs: false,
+    };
+    return config;
+  },
+}
+
+module.exports = nextConfig
--- repository_before/repository_after/package.json	2026-01-28 12:47:12
+++ repository_after/package.json	2026-01-28 10:14:49
@@ -0,0 +1,43 @@
+{
+  "name": "db-storage-explorer",
+  "version": "0.1.0",
+  "private": true,
+  "scripts": {
+    "dev": "next dev",
+    "build": "next build",
+    "start": "next start",
+    "lint": "next lint",
+    "test": "jest",
+    "test:watch": "jest --watch"
+  },
+  "dependencies": {
+    "@types/d3": "^7.4.0",
+    "@types/node": "^20.8.0",
+    "@types/react": "^18.3.27",
+    "@types/react-dom": "^18.3.7",
+    "@types/react-window": "^1.8.5",
+    "autoprefixer": "^10.4.16",
+    "classnames": "^2.3.2",
+    "d3": "^7.8.5",
+    "date-fns": "^2.30.0",
+    "next": "14.0.0",
+    "postcss": "^8.4.31",
+    "react": "^18.2.0",
+    "react-dom": "^18.2.0",
+    "react-dropzone": "^14.2.3",
+    "react-virtualized-auto-sizer": "^1.0.20",
+    "react-window": "^1.8.8",
+    "tailwindcss": "^3.3.0",
+    "typescript": "^5.2.2",
+    "zustand": "^4.4.4"
+  },
+  "devDependencies": {
+    "@testing-library/jest-dom": "^6.9.1",
+    "@testing-library/react": "^13.4.0",
+    "@types/jest": "^29.5.14",
+    "eslint": "^8.51.0",
+    "eslint-config-next": "14.0.0",
+    "jest": "^29.7.0",
+    "jest-environment-jsdom": "^29.7.0"
+  }
+}
--- repository_before/repository_after/postcss.config.js	2026-01-28 12:47:12
+++ repository_after/postcss.config.js	2026-01-28 09:32:48
@@ -0,0 +1,6 @@
+module.exports = {
+  plugins: {
+    tailwindcss: {},
+    autoprefixer: {},
+  },
+}
--- repository_before/repository_after/src/app/layout.tsx	2026-01-28 12:47:12
+++ repository_after/src/app/layout.tsx	2026-01-28 09:32:59
@@ -0,0 +1,21 @@
+import './globals.css'
+import { Inter } from 'next/font/google'
+
+const inter = Inter({ subsets: ['latin'] })
+
+export const metadata = {
+  title: 'Database Storage Explorer',
+  description: 'Analyze physical storage internals from database dumps',
+}
+
+export default function RootLayout({
+  children,
+}: {
+  children: React.ReactNode
+}) {
+  return (
+    <html lang="en">
+      <body className={inter.className}>{children}</body>
+    </html>
+  )
+}
--- repository_before/repository_after/src/app/page.tsx	2026-01-28 12:47:12
+++ repository_after/src/app/page.tsx	2026-01-28 09:33:26
@@ -0,0 +1,46 @@
+'use client'
+
+import { useState } from 'react'
+import FileImport from '@/components/FileImport'
+import StorageVisualization from '@/components/StorageVisualization'
+import MetricsPanel from '@/components/MetricsPanel'
+import { useStorageStore } from '@/store/storageStore'
+
+export default function Home() {
+  const [isFileLoaded, setIsFileLoaded] = useState(false)
+  const { currentSnapshot, snapshots } = useStorageStore()
+
+  const handleFileLoad = (success: boolean) => {
+    setIsFileLoaded(success)
+  }
+
+  return (
+    <main className="min-h-screen bg-gray-50">
+      <div className="container mx-auto px-4 py-8">
+        <header className="mb-8">
+          <h1 className="text-4xl font-bold text-gray-900 mb-2">
+            Database Storage Explorer
+          </h1>
+          <p className="text-lg text-gray-600">
+            Analyze physical storage internals from database dumps
+          </p>
+        </header>
+
+        {!isFileLoaded ? (
+          <div className="max-w-2xl mx-auto">
+            <FileImport onFileLoad={handleFileLoad} />
+          </div>
+        ) : (
+          <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
+            <div className="lg:col-span-3">
+              <StorageVisualization />
+            </div>
+            <div className="lg:col-span-1">
+              <MetricsPanel />
+            </div>
+          </div>
+        )}
+      </div>
+    </main>
+  )
+}
--- repository_before/repository_after/src/components/BinaryInspector.tsx	2026-01-28 12:47:12
+++ repository_after/src/components/BinaryInspector.tsx	2026-01-28 09:52:07
@@ -0,0 +1,348 @@
+'use client'
+
+import { useMemo } from 'react'
+import { StorageSnapshot, HeapPage, Tuple } from '@/types/storage'
+
+interface BinaryInspectorProps {
+  snapshot: StorageSnapshot
+  selectedPage?: HeapPage
+  selectedTuple?: Tuple
+}
+
+export default function BinaryInspector({ snapshot, selectedPage, selectedTuple }: BinaryInspectorProps) {
+  const binaryData = useMemo(() => {
+    if (selectedTuple) {
+      return {
+        type: 'tuple',
+        data: selectedTuple.data,
+        offset: 0,
+        size: selectedTuple.data.length
+      }
+    }
+    
+    if (selectedPage) {
+      const pageData = new Uint8Array(8192)
+      
+      const headerBytes = new TextEncoder().encode(JSON.stringify(selectedPage.header))
+      pageData.set(headerBytes.slice(0, 24), 0)
+      
+      selectedPage.linePointers.forEach((lp, index) => {
+        const offset = 24 + index * 4
+        pageData[offset] = lp.offset & 0xff
+        pageData[offset + 1] = (lp.offset >> 8) & 0xff
+        pageData[offset + 2] = (lp.offset >> 16) & 0xff
+        pageData[offset + 3] = (lp.offset >> 24) & 0xff
+      })
+      
+      selectedPage.tuples.forEach(tuple => {
+        if ((tuple.offset || 0) > 0) {
+          pageData.set(tuple.data, tuple.offset || 0)
+        }
+      })
+      
+      return {
+        type: 'page',
+        data: pageData,
+        offset: 0,
+        size: 8192
+      }
+    }
+    
+    return null
+  }, [selectedPage, selectedTuple])
+
+  const formatHexByte = (byte: number) => {
+    return ('0' + byte.toString(16).toUpperCase()).slice(-2)
+  }
+
+  const formatBinaryByte = (byte: number) => {
+    return ('00000000' + byte.toString(2)).slice(-8)
+  }
+
+  const formatAsciiChar = (byte: number) => {
+    return (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.'
+  }
+
+  const getByteInterpretation = (byte: number, offset: number) => {
+    const interpretations = []
+    
+    if (byte === 0) interpretations.push('NULL')
+    if (byte === 1) interpretations.push('TRUE')
+    if (byte === 255) interpretations.push('-1 (signed)')
+    
+    if (byte >= 48 && byte <= 57) {
+      interpretations.push(`'${String.fromCharCode(byte)}' (digit)`)
+    }
+    
+    if (byte >= 65 && byte <= 90) {
+      interpretations.push(`'${String.fromCharCode(byte)}' (uppercase)`)
+    }
+    
+    if (byte >= 97 && byte <= 122) {
+      interpretations.push(`'${String.fromCharCode(byte)}' (lowercase)`)
+    }
+    
+    if (offset % 4 === 0 && offset + 3 < (binaryData?.data.length || 0)) {
+      const view = new DataView(binaryData!.data.buffer, offset, 4)
+      interpretations.push(`i32: ${view.getInt32(0, true)}`)
+      interpretations.push(`u32: ${view.getUint32(0, true)}`)
+    }
+    
+    if (offset % 8 === 0 && offset + 7 < (binaryData?.data.length || 0)) {
+      const view = new DataView(binaryData!.data.buffer, offset, 8)
+      interpretations.push(`i64: ${view.getInt32(0, true)}`)
+      interpretations.push(`f64: ${view.getFloat64(0, true)}`)
+    }
+    
+    return interpretations
+  }
+
+  if (!binaryData) {
+    return (
+      <div className="p-6 text-center text-gray-500">
+        <div className="text-lg font-medium">No binary data selected</div>
+        <div className="text-sm">Select a page or tuple to inspect binary data</div>
+      </div>
+    )
+  }
+
+  return (
+    <div className="p-6">
+      <div className="mb-6">
+        <h3 className="text-lg font-medium text-gray-900 mb-2">
+          Binary Inspector
+        </h3>
+        <div className="text-sm text-gray-600">
+          {binaryData.type === 'tuple' ? 'Tuple Data' : 'Page Data'} | 
+          Size: {binaryData.size} bytes
+        </div>
+      </div>
+
+      <div className="mb-6">
+        <div className="flex items-center space-x-4 text-sm">
+          <div className="flex items-center">
+            <div className="w-4 h-4 bg-blue-100 border border-blue-300 mr-1"></div>
+            <span>Hex View</span>
+          </div>
+          <div className="flex items-center">
+            <div className="w-4 h-4 bg-green-100 border border-green-300 mr-1"></div>
+            <span>Binary View</span>
+          </div>
+          <div className="flex items-center">
+            <div className="w-4 h-4 bg-gray-100 border border-gray-300 mr-1"></div>
+            <span>ASCII View</span>
+          </div>
+        </div>
+      </div>
+
+      <div className="bg-white border border-gray-200 rounded-lg overflow-hidden">
+        <div className="max-h-96 overflow-y-auto">
+          <table className="min-w-full divide-y divide-gray-200">
+            <thead className="bg-gray-50 sticky top-0">
+              <tr>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Offset</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Hex</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Binary</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">ASCII</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Interpretation</th>
+              </tr>
+            </thead>
+            <tbody className="bg-white divide-y divide-gray-200">
+              {Array.from({ length: Math.min(binaryData.size, 256) }).map((_, index) => {
+                const offset = index
+                const byte = binaryData.data[offset]
+                const interpretations = getByteInterpretation(byte, offset)
+                
+                return (
+                  <tr key={offset} className="hover:bg-gray-50">
+                    <td className="px-4 py-2 text-sm font-mono">
+                      {('0000' + offset.toString(16)).slice(-4).toUpperCase()}
+                    </td>
+                    <td className="px-4 py-2 text-sm font-mono bg-blue-50">
+                      0x{formatHexByte(byte)}
+                    </td>
+                    <td className="px-4 py-2 text-sm font-mono bg-green-50 text-xs">
+                      {formatBinaryByte(byte)}
+                    </td>
+                    <td className="px-4 py-2 text-sm font-mono bg-gray-50">
+                      {formatAsciiChar(byte)}
+                    </td>
+                    <td className="px-4 py-2 text-xs">
+                      <div className="space-y-1">
+                        {interpretations.map((interp, i) => (
+                          <div key={i} className="text-gray-600">
+                            {interp}
+                          </div>
+                        ))}
+                      </div>
+                    </td>
+                  </tr>
+                )
+              })}
+            </tbody>
+          </table>
+        </div>
+      </div>
+
+      {binaryData.size > 256 && (
+        <div className="mt-4 text-sm text-gray-500 text-center">
+          Showing first 256 bytes of {binaryData.size} total bytes
+        </div>
+      )}
+
+      <div className="mt-6">
+        <h4 className="text-md font-medium text-gray-900 mb-3">Data Analysis</h4>
+        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
+          <div className="bg-gray-50 rounded-lg p-4">
+            <h5 className="text-sm font-medium text-gray-900 mb-2">Byte Statistics</h5>
+            <div className="space-y-1 text-sm">
+              <div className="flex justify-between">
+                <span>Zero bytes:</span>
+                <span className="font-mono">
+                  {Array.from(binaryData.data).filter(b => b === 0).length}
+                </span>
+              </div>
+              <div className="flex justify-between">
+                <span>Non-zero bytes:</span>
+                <span className="font-mono">
+                  {Array.from(binaryData.data).filter(b => b !== 0).length}
+                </span>
+              </div>
+              <div className="flex justify-between">
+                <span>Printable ASCII:</span>
+                <span className="font-mono">
+                  {Array.from(binaryData.data).filter(b => b >= 32 && b <= 126).length}
+                </span>
+              </div>
+            </div>
+          </div>
+
+          <div className="bg-gray-50 rounded-lg p-4">
+            <h5 className="text-sm font-medium text-gray-900 mb-2">Pattern Detection</h5>
+            <div className="space-y-1 text-sm">
+              <div className="flex justify-between">
+                <span>Repeating patterns:</span>
+                <span className="font-mono">
+                  {findRepeatingPatterns(binaryData.data).length}
+                </span>
+              </div>
+              <div className="flex justify-between">
+                <span>Null sequences:</span>
+                <span className="font-mono">
+                  {findNullSequences(binaryData.data).length}
+                </span>
+              </div>
+              <div className="flex justify-between">
+                <span>Text segments:</span>
+                <span className="font-mono">
+                  {findTextSegments(binaryData.data).length}
+                </span>
+              </div>
+            </div>
+          </div>
+
+          <div className="bg-gray-50 rounded-lg p-4">
+            <h5 className="text-sm font-medium text-gray-900 mb-2">Structure Info</h5>
+            <div className="space-y-1 text-sm">
+              <div className="flex justify-between">
+                <span>Data type:</span>
+                <span className="font-mono capitalize">{binaryData.type}</span>
+              </div>
+              <div className="flex justify-between">
+                <span>Endianness:</span>
+                <span className="font-mono">Little Endian</span>
+              </div>
+              <div className="flex justify-between">
+                <span>Alignment:</span>
+                <span className="font-mono">8-byte</span>
+              </div>
+            </div>
+          </div>
+        </div>
+      </div>
+    </div>
+  )
+}
+
+function findRepeatingPatterns(data: Uint8Array): Array<{pattern: string, count: number, offsets: number[]}> {
+  const patterns = new Map<string, {count: number, offsets: number[]}>()
+  
+  for (let i = 0; i < data.length - 3; i++) {
+    const pattern = Array.from(data.slice(i, i + 4))
+      .map((b: number) => ('00' + b.toString(16)).slice(-2))
+      .join('')
+    
+    if (!patterns.has(pattern)) {
+      patterns.set(pattern, {count: 0, offsets: []})
+    }
+    
+    const info = patterns.get(pattern)!
+    info.count++
+    info.offsets.push(i)
+  }
+  
+  return Array.from(patterns.entries())
+    .filter(([_, info]) => info.count > 1)
+    .map(([pattern, info]) => ({pattern, count: info.count, offsets: info.offsets}))
+    .sort((a, b) => b.count - a.count)
+    .slice(0, 5)
+}
+
+function findNullSequences(data: Uint8Array): Array<{offset: number, length: number}> {
+  const sequences = []
+  let currentStart = -1
+  let currentLength = 0
+  
+  for (let i = 0; i < data.length; i++) {
+    if (data[i] === 0) {
+      if (currentStart === -1) {
+        currentStart = i
+        currentLength = 1
+      } else {
+        currentLength++
+      }
+    } else {
+      if (currentStart !== -1 && currentLength > 1) {
+        sequences.push({offset: currentStart, length: currentLength})
+      }
+      currentStart = -1
+      currentLength = 0
+    }
+  }
+  
+  if (currentStart !== -1 && currentLength > 1) {
+    sequences.push({offset: currentStart, length: currentLength})
+  }
+  
+  return sequences
+}
+
+function findTextSegments(data: Uint8Array): Array<{offset: number, text: string}> {
+  const segments = []
+  let currentStart = -1
+  let currentText = ''
+  
+  for (let i = 0; i < data.length; i++) {
+    const byte = data[i]
+    if (byte >= 32 && byte <= 126) {
+      if (currentStart === -1) {
+        currentStart = i
+        currentText = String.fromCharCode(byte)
+      } else {
+        currentText += String.fromCharCode(byte)
+      }
+    } else {
+      if (currentStart !== -1 && currentText.length > 3) {
+        segments.push({offset: currentStart, text: currentText})
+      }
+      currentStart = -1
+      currentText = ''
+    }
+  }
+  
+  if (currentStart !== -1 && currentText.length > 3) {
+    segments.push({offset: currentStart, text: currentText})
+  }
+  
+  return segments
+}
--- repository_before/repository_after/src/components/FileImport.tsx	2026-01-28 12:47:12
+++ repository_after/src/components/FileImport.tsx	2026-01-28 09:36:24
@@ -0,0 +1,182 @@
+'use client'
+
+import { useCallback, useState } from 'react'
+import { useDropzone } from 'react-dropzone'
+import { useStorageStore } from '@/store/storageStore'
+import { StorageParser } from '@/utils/storageParser'
+import { InspectionLog } from '@/types/storage'
+
+interface FileImportProps {
+  onFileLoad: (success: boolean) => void
+}
+
+export default function FileImport({ onFileLoad }: FileImportProps) {
+  const [isProcessing, setIsProcessing] = useState(false)
+  const [error, setError] = useState<string | null>(null)
+  const { addSnapshot, addInspectionLog, setLoading, setError: setStoreError } = useStorageStore()
+
+  const processFile = useCallback(async (file: File) => {
+    setIsProcessing(true)
+    setError(null)
+    setLoading(true)
+    setStoreError(null)
+
+    try {
+      const snapshot = await StorageParser.parseFile(file)
+      
+      addSnapshot(snapshot)
+      
+      const log: InspectionLog = {
+        id: Math.random().toString(36).substr(2, 9),
+        timestamp: Date.now(),
+        action: 'import',
+        snapshotId: snapshot.id,
+        details: {
+          fileName: file.name,
+          fileSize: file.size,
+          totalPages: snapshot.metrics.totalPages,
+          heapPages: snapshot.heapPages.length,
+          indexPages: snapshot.indexPages.length,
+          corruptedPages: snapshot.corruptedPages.length
+        }
+      }
+      
+      addInspectionLog(log)
+      onFileLoad(true)
+    } catch (err) {
+      const errorMessage = err instanceof Error ? err.message : 'Failed to process file'
+      setError(errorMessage)
+      setStoreError(errorMessage)
+      onFileLoad(false)
+    } finally {
+      setIsProcessing(false)
+      setLoading(false)
+    }
+  }, [addSnapshot, addInspectionLog, setLoading, setStoreError, onFileLoad])
+
+  const onDrop = useCallback((acceptedFiles: File[]) => {
+    if (acceptedFiles.length === 0) return
+    
+    const file = acceptedFiles[0]
+    
+    const validExtensions = ['.dump', '.bin', '.json', '.dat', '.pgd']
+    const fileExtension = file.name.toLowerCase().slice(file.name.lastIndexOf('.'))
+    
+    if (validExtensions.indexOf(fileExtension) === -1) {
+      setError(`Invalid file type. Supported formats: ${validExtensions.join(', ')}`)
+      return
+    }
+    
+    if (file.size > 100 * 1024 * 1024) { // 100MB limit
+      setError('File too large. Maximum size is 100MB')
+      return
+    }
+    
+    processFile(file)
+  }, [processFile])
+
+  const { getRootProps, getInputProps, isDragActive } = useDropzone({
+    onDrop,
+    accept: {
+      'application/octet-stream': ['.dump', '.bin', '.dat', '.pgd'],
+      'application/json': ['.json'],
+      'text/plain': ['.txt']
+    },
+    maxSize: 100 * 1024 * 1024, // 100MB
+    multiple: false
+  })
+
+  return (
+    <div className="w-full max-w-2xl mx-auto">
+      <div className="bg-white rounded-lg shadow-md p-8">
+        <h2 className="text-2xl font-semibold text-gray-900 mb-6">
+          Import Database Storage Snapshot
+        </h2>
+        
+        <div
+          {...getRootProps()}
+          className={`
+            border-2 border-dashed rounded-lg p-12 text-center cursor-pointer transition-colors
+            ${isDragActive 
+              ? 'border-blue-500 bg-blue-50' 
+              : 'border-gray-300 hover:border-gray-400'
+            }
+            ${isProcessing ? 'opacity-50 cursor-not-allowed' : ''}
+          `}
+        >
+          <input {...getInputProps()} />
+          
+          <div className="flex flex-col items-center space-y-4">
+            <div className="w-16 h-16 bg-gray-200 rounded-full flex items-center justify-center">
+              {isProcessing ? (
+                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
+              ) : (
+                <svg className="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
+                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
+                </svg>
+              )}
+            </div>
+            
+            <div>
+              {isProcessing ? (
+                <p className="text-lg font-medium text-gray-900">Processing file...</p>
+              ) : isDragActive ? (
+                <p className="text-lg font-medium text-blue-600">Drop the file here...</p>
+              ) : (
+                <div>
+                  <p className="text-lg font-medium text-gray-900">
+                    Drag & drop a database dump file here, or click to select
+                  </p>
+                  <p className="text-sm text-gray-500 mt-2">
+                    Supports PostgreSQL dumps, binary page files, and JSON formats
+                  </p>
+                </div>
+              )}
+            </div>
+          </div>
+        </div>
+        
+        {error && (
+          <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded-md">
+            <div className="flex">
+              <div className="flex-shrink-0">
+                <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
+                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
+                </svg>
+              </div>
+              <div className="ml-3">
+                <h3 className="text-sm font-medium text-red-800">
+                  Import Error
+                </h3>
+                <p className="mt-1 text-sm text-red-700">
+                  {error}
+                </p>
+              </div>
+            </div>
+          </div>
+        )}
+        
+        <div className="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
+          <h3 className="text-sm font-medium text-blue-900 mb-2">Supported Formats:</h3>
+          <ul className="text-sm text-blue-700 space-y-1">
+            <li>• PostgreSQL binary dumps (.dump, .pgd)</li>
+            <li>• Raw page files (.bin, .dat)</li>
+            <li>• JSON storage snapshots (.json)</li>
+            <li>• Maximum file size: 100MB</li>
+          </ul>
+        </div>
+        
+        <div className="mt-6 p-4 bg-gray-50 border border-gray-200 rounded-md">
+          <h3 className="text-sm font-medium text-gray-900 mb-2">Features:</h3>
+          <ul className="text-sm text-gray-700 space-y-1">
+            <li>• Automatic format detection</li>
+            <li>• Corruption handling with detailed error reporting</li>
+            <li>• Deterministic parsing with validation</li>
+            <li>• Storage metrics calculation</li>
+            <li>• Page layout analysis</li>
+          </ul>
+        </div>
+      </div>
+    </div>
+  )
+}
--- repository_before/repository_after/src/components/FragmentationHeatmap.tsx	2026-01-28 12:47:12
+++ repository_after/src/components/FragmentationHeatmap.tsx	2026-01-28 09:58:22
@@ -0,0 +1,343 @@
+'use client'
+
+import { useMemo } from 'react'
+import { StorageSnapshot, HeatmapData } from '@/types/storage'
+
+interface FragmentationHeatmapProps {
+  snapshot: StorageSnapshot
+}
+
+export default function FragmentationHeatmap({ snapshot }: FragmentationHeatmapProps) {
+  const heatmapData = useMemo(() => {
+    const pages = snapshot.heatmapData || []
+    
+    if (pages.length === 0) {
+      return {
+        pages: [],
+        maxDensity: 0,
+        minDensity: 0,
+        maxFragmentation: 0,
+        minFragmentation: 0,
+        totalPages: 0
+      }
+    }
+    
+    const maxDensity = Math.max(...pages.map(p => p.density))
+    const minDensity = Math.min(...pages.map(p => p.density))
+    const maxFragmentation = Math.max(...pages.map(p => p.fragmentation))
+    const minFragmentation = Math.min(...pages.map(p => p.fragmentation))
+    
+    return {
+      pages,
+      maxDensity,
+      minDensity,
+      maxFragmentation,
+      minFragmentation,
+      totalPages: pages.length
+    }
+  }, [snapshot.heatmapData])
+
+  const getColorForDensity = (density: number) => {
+    const normalized = (density - heatmapData.minDensity) / (heatmapData.maxDensity - heatmapData.minDensity || 1)
+    
+    if (normalized > 0.8) return 'bg-green-600'
+    if (normalized > 0.6) return 'bg-green-500'
+    if (normalized > 0.4) return 'bg-yellow-500'
+    if (normalized > 0.2) return 'bg-orange-500'
+    return 'bg-red-500'
+  }
+
+  const getColorForFragmentation = (fragmentation: number) => {
+    if (fragmentation > 0.3) return 'bg-red-600'
+    if (fragmentation > 0.2) return 'bg-red-500'
+    if (fragmentation > 0.1) return 'bg-orange-500'
+    if (fragmentation > 0.05) return 'bg-yellow-500'
+    return 'bg-green-500'
+  }
+
+  if (!heatmapData.pages || heatmapData.pages.length === 0) {
+    return (
+      <div className="p-6 text-center text-gray-500">
+        <div className="text-lg font-medium">No heatmap data available</div>
+        <div className="text-sm">This snapshot contains no page density information</div>
+      </div>
+    )
+  }
+
+  return (
+    <div className="p-6">
+      <div className="mb-6">
+        <h3 className="text-lg font-medium text-gray-900 mb-2">
+          Fragmentation Heatmap
+        </h3>
+        <div className="text-sm text-gray-600">
+          {heatmapData.totalPages} pages | Density range: {heatmapData.minDensity.toFixed(1)}% - {heatmapData.maxDensity.toFixed(1)}%
+        </div>
+      </div>
+
+      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Page Density Heatmap</h4>
+          <div className="bg-gray-50 rounded-lg p-4">
+            <div className="mb-3 flex items-center space-x-4 text-xs">
+              <div className="flex items-center">
+                <div className="w-4 h-4 bg-green-600 mr-1"></div>
+                <span>High (&gt;80%)</span>
+              </div>
+              <div className="flex items-center">
+                <div className="w-4 h-4 bg-yellow-500 mr-1"></div>
+                <span>Medium (40-80%)</span>
+              </div>
+              <div className="flex items-center">
+                <div className="w-4 h-4 bg-red-500 mr-1"></div>
+                <span>Low (&lt;40%)</span>
+              </div>
+            </div>
+            <div className="grid grid-cols-20 gap-1">
+              {heatmapData.pages.map((page, index) => (
+                <div
+                  key={index}
+                  className={`aspect-square ${getColorForDensity(page.density)} cursor-pointer hover:opacity-80 rounded-sm`}
+                  title={`Page ${page.pageNumber}: ${page.density.toFixed(1)}% density, ${page.fragmentation.toFixed(1)}% fragmentation`}
+                ></div>
+              ))}
+            </div>
+          </div>
+        </div>
+
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Fragmentation Heatmap</h4>
+          <div className="bg-gray-50 rounded-lg p-4">
+            <div className="mb-3 flex items-center space-x-4 text-xs">
+              <div className="flex items-center">
+                <div className="w-4 h-4 bg-green-500 mr-1"></div>
+                <span>Low (&lt;5%)</span>
+              </div>
+              <div className="flex items-center">
+                <div className="w-4 h-4 bg-yellow-500 mr-1"></div>
+                <span>Medium (5-20%)</span>
+              </div>
+              <div className="flex items-center">
+                <div className="w-4 h-4 bg-red-600 mr-1"></div>
+                <span>High (&gt;30%)</span>
+              </div>
+            </div>
+            <div className="grid grid-cols-20 gap-1">
+              {heatmapData.pages.map((page, index) => (
+                <div
+                  key={index}
+                  className={`aspect-square ${getColorForFragmentation(page.fragmentation)} cursor-pointer hover:opacity-80 rounded-sm`}
+                  title={`Page ${page.pageNumber}: ${page.fragmentation.toFixed(1)}% fragmentation, ${page.density.toFixed(1)}% density`}
+                ></div>
+              ))}
+            </div>
+          </div>
+        </div>
+      </div>
+
+      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Density Distribution</h4>
+          <div className="bg-gray-50 rounded-lg p-4">
+            <div className="space-y-2">
+              {getDensityDistribution(heatmapData.pages).map((bucket, index) => (
+                <div key={index} className="flex items-center justify-between">
+                  <span className="text-sm text-gray-600 w-24">{bucket.range}:</span>
+                  <div className="flex-1 mx-2">
+                    <div className="bg-gray-200 rounded-full h-4">
+                      <div 
+                        className="bg-blue-500 h-4 rounded-full"
+                        style={{ width: `${bucket.percentage}%` }}
+                      ></div>
+                    </div>
+                  </div>
+                  <span className="text-sm font-mono w-12 text-right">{bucket.count}</span>
+                </div>
+              ))}
+            </div>
+          </div>
+        </div>
+
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Fragmentation Distribution</h4>
+          <div className="bg-gray-50 rounded-lg p-4">
+            <div className="space-y-2">
+              {getFragmentationDistribution(heatmapData.pages).map((bucket, index) => (
+                <div key={index} className="flex items-center justify-between">
+                  <span className="text-sm text-gray-600 w-24">{bucket.range}:</span>
+                  <div className="flex-1 mx-2">
+                    <div className="bg-gray-200 rounded-full h-4">
+                      <div 
+                        className="bg-red-500 h-4 rounded-full"
+                        style={{ width: `${bucket.percentage}%` }}
+                      ></div>
+                    </div>
+                  </div>
+                  <span className="text-sm font-mono w-12 text-right">{bucket.count}</span>
+                </div>
+              ))}
+            </div>
+          </div>
+        </div>
+
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Summary Statistics</h4>
+          <div className="bg-gray-50 rounded-lg p-4 text-sm space-y-2">
+            <div className="flex justify-between">
+              <span>Average Density:</span>
+              <span className="font-bold">
+                {(heatmapData.pages.reduce((sum, p) => sum + p.density, 0) / heatmapData.pages.length).toFixed(1)}%
+              </span>
+            </div>
+            <div className="flex justify-between">
+              <span>Average Fragmentation:</span>
+              <span className="font-bold">
+                {(heatmapData.pages.reduce((sum, p) => sum + p.fragmentation, 0) / heatmapData.pages.length).toFixed(1)}%
+              </span>
+            </div>
+            <div className="flex justify-between">
+              <span>Critical Pages:</span>
+              <span className="font-bold text-red-600">
+                {heatmapData.pages.filter(p => p.fragmentation > 0.3 || p.density < 40).length}
+              </span>
+            </div>
+            <div className="flex justify-between">
+              <span>Optimal Pages:</span>
+              <span className="font-bold text-green-600">
+                {heatmapData.pages.filter(p => p.fragmentation < 0.1 && p.density > 70).length}
+              </span>
+            </div>
+          </div>
+        </div>
+      </div>
+
+      <div>
+        <h4 className="text-md font-medium text-gray-900 mb-3">Page Details</h4>
+        <div className="bg-white border border-gray-200 rounded-lg overflow-hidden max-h-96 overflow-y-auto">
+          <table className="min-w-full divide-y divide-gray-200">
+            <thead className="bg-gray-50 sticky top-0">
+              <tr>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Page</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Density</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Fragmentation</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Status</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Recommendation</th>
+              </tr>
+            </thead>
+            <tbody className="bg-white divide-y divide-gray-200">
+              {heatmapData.pages.map((page) => (
+                <tr key={page.pageNumber} className="hover:bg-gray-50">
+                  <td className="px-4 py-2 text-sm font-medium">{page.pageNumber}</td>
+                  <td className="px-4 py-2 text-sm">
+                    <div className="flex items-center">
+                      <div className="flex-1 bg-gray-200 rounded-full h-2 mr-2">
+                        <div 
+                          className={`h-2 rounded-full ${
+                            page.density > 80 ? 'bg-green-500' :
+                            page.density > 60 ? 'bg-yellow-500' : 'bg-red-500'
+                          }`}
+                          style={{ width: `${page.density}%` }}
+                        ></div>
+                      </div>
+                      <span className="text-xs font-mono">{page.density.toFixed(1)}%</span>
+                    </div>
+                  </td>
+                  <td className="px-4 py-2 text-sm">
+                    <div className="flex items-center">
+                      <div className="flex-1 bg-gray-200 rounded-full h-2 mr-2">
+                        <div 
+                          className={`h-2 rounded-full ${
+                            page.fragmentation > 0.3 ? 'bg-red-500' :
+                            page.fragmentation > 0.1 ? 'bg-yellow-500' : 'bg-green-500'
+                          }`}
+                          style={{ width: `${page.fragmentation * 100}%` }}
+                        ></div>
+                      </div>
+                      <span className="text-xs font-mono">{(page.fragmentation * 100).toFixed(1)}%</span>
+                    </div>
+                  </td>
+                  <td className="px-4 py-2 text-sm">
+                    <span className={`inline-flex px-2 py-1 text-xs rounded-full ${
+                      getPageStatus(page) === 'HEALTHY' ? 'bg-green-100 text-green-800' :
+                      getPageStatus(page) === 'WARNING' ? 'bg-yellow-100 text-yellow-800' :
+                      'bg-red-100 text-red-800'
+                    }`}>
+                      {getPageStatus(page)}
+                    </span>
+                  </td>
+                  <td className="px-4 py-2 text-xs text-gray-600">
+                    {getRecommendation(page)}
+                  </td>
+                </tr>
+              ))}
+            </tbody>
+          </table>
+        </div>
+      </div>
+    </div>
+  )
+}
+
+function getDensityDistribution(pages: HeatmapData[]) {
+  const distribution = [
+    { range: '0-20%', count: 0, percentage: 0 },
+    { range: '20-40%', count: 0, percentage: 0 },
+    { range: '40-60%', count: 0, percentage: 0 },
+    { range: '60-80%', count: 0, percentage: 0 },
+    { range: '80-100%', count: 0, percentage: 0 }
+  ]
+
+  pages.forEach(page => {
+    const density = page.density
+    if (density <= 20) distribution[0].count++
+    else if (density <= 40) distribution[1].count++
+    else if (density <= 60) distribution[2].count++
+    else if (density <= 80) distribution[3].count++
+    else distribution[4].count++
+  })
+
+  distribution.forEach(bucket => {
+    bucket.percentage = (bucket.count / pages.length) * 100
+  })
+
+  return distribution
+}
+
+function getFragmentationDistribution(pages: HeatmapData[]) {
+  const distribution = [
+    { range: '0-5%', count: 0, percentage: 0 },
+    { range: '5-10%', count: 0, percentage: 0 },
+    { range: '10-20%', count: 0, percentage: 0 },
+    { range: '20-30%', count: 0, percentage: 0 },
+    { range: '30%+', count: 0, percentage: 0 }
+  ]
+
+  pages.forEach(page => {
+    const frag = page.fragmentation * 100
+    if (frag <= 5) distribution[0].count++
+    else if (frag <= 10) distribution[1].count++
+    else if (frag <= 20) distribution[2].count++
+    else if (frag <= 30) distribution[3].count++
+    else distribution[4].count++
+  })
+
+  distribution.forEach(bucket => {
+    bucket.percentage = (bucket.count / pages.length) * 100
+  })
+
+  return distribution
+}
+
+function getPageStatus(page: HeatmapData): string {
+  if (page.fragmentation > 0.3 || page.density < 40) return 'CRITICAL'
+  if (page.fragmentation > 0.1 || page.density < 60) return 'WARNING'
+  return 'HEALTHY'
+}
+
+function getRecommendation(page: HeatmapData): string {
+  if (page.fragmentation > 0.3) return 'Immediate VACUUM FULL needed'
+  if (page.fragmentation > 0.1) return 'Schedule VACUUM soon'
+  if (page.density < 40) return 'Consider table rewrite'
+  if (page.density < 60) return 'Monitor closely'
+  return 'No action needed'
+}
--- repository_before/repository_after/src/components/IndexVisualization.tsx	2026-01-28 12:47:12
+++ repository_after/src/components/IndexVisualization.tsx	2026-01-28 09:40:44
@@ -0,0 +1,346 @@
+'use client'
+
+import { useMemo } from 'react'
+import { StorageSnapshot, IndexPage } from '@/types/storage'
+
+interface IndexVisualizationProps {
+  snapshot: StorageSnapshot
+}
+
+export default function IndexVisualization({ snapshot }: IndexVisualizationProps) {
+  const indexAnalysis = useMemo(() => {
+    if (snapshot.indexPages.length === 0) return null
+
+    const totalPages = snapshot.indexPages.length
+    const leafPages = snapshot.indexPages.filter(p => p.node.isLeaf).length
+    const internalPages = totalPages - leafPages
+    const maxLevel = Math.max(...snapshot.indexPages.map(p => p.node.level))
+    const averageUtilization = snapshot.indexPages.reduce((sum, p) => sum + p.utilization, 0) / totalPages
+    const averageKeysPerPage = snapshot.indexPages.reduce((sum, p) => sum + p.node.keys.length, 0) / totalPages
+
+    return {
+      totalPages,
+      leafPages,
+      internalPages,
+      maxLevel,
+      averageUtilization,
+      averageKeysPerPage,
+      treeHeight: maxLevel + 1,
+      totalKeys: snapshot.indexPages.reduce((sum, p) => sum + p.node.keys.length, 0)
+    }
+  }, [snapshot.indexPages])
+
+  const treeStructure = useMemo(() => {
+    if (!indexAnalysis) return null
+
+    const levels = []
+    for (let level = indexAnalysis.maxLevel; level >= 0; level--) {
+      const pagesAtLevel = snapshot.indexPages.filter(p => p.node.level === level)
+      levels.push({
+        level,
+        pages: pagesAtLevel,
+        count: pagesAtLevel.length
+      })
+    }
+
+    return levels
+  }, [snapshot.indexPages, indexAnalysis])
+
+  if (!indexAnalysis) {
+    return (
+      <div className="p-6 text-center text-gray-500">
+        <div className="text-lg font-medium">No index pages found</div>
+        <div className="text-sm">This snapshot contains no index data to visualize</div>
+      </div>
+    )
+  }
+
+  return (
+    <div className="p-6">
+      <div className="mb-6">
+        <h3 className="text-lg font-medium text-gray-900 mb-2">
+          Index Structure Analysis
+        </h3>
+        <div className="text-sm text-gray-600">
+          {indexAnalysis.totalPages} index pages | Tree height: {indexAnalysis.treeHeight} | 
+          Total keys: {indexAnalysis.totalKeys}
+        </div>
+      </div>
+
+      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Index Statistics</h4>
+          <div className="bg-gray-50 rounded-lg p-4 text-sm space-y-2">
+            <div className="flex justify-between">
+              <span>Tree Height:</span>
+              <span className="font-bold">{indexAnalysis.treeHeight}</span>
+            </div>
+            <div className="flex justify-between">
+              <span>Total Pages:</span>
+              <span className="font-bold">{indexAnalysis.totalPages}</span>
+            </div>
+            <div className="flex justify-between">
+              <span>Leaf Pages:</span>
+              <span className="font-bold">{indexAnalysis.leafPages}</span>
+            </div>
+            <div className="flex justify-between">
+              <span>Internal Pages:</span>
+              <span className="font-bold">{indexAnalysis.internalPages}</span>
+            </div>
+            <div className="flex justify-between">
+              <span>Average Utilization:</span>
+              <span className="font-bold">{indexAnalysis.averageUtilization.toFixed(1)}%</span>
+            </div>
+            <div className="flex justify-between">
+              <span>Average Keys/Page:</span>
+              <span className="font-bold">{indexAnalysis.averageKeysPerPage.toFixed(1)}</span>
+            </div>
+          </div>
+        </div>
+
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Efficiency Metrics</h4>
+          <div className="bg-gray-50 rounded-lg p-4 text-sm space-y-2">
+            <div className="flex justify-between">
+              <span>Fanout (Avg):</span>
+              <span className="font-bold">
+                {indexAnalysis.internalPages > 0 
+                  ? (indexAnalysis.totalPages - 1) / indexAnalysis.internalPages
+                  : 'N/A'
+                }
+              </span>
+            </div>
+            <div className="flex justify-between">
+              <span>Branching Factor:</span>
+              <span className="font-bold">
+                {treeStructure && treeStructure.length > 1
+                  ? (treeStructure[treeStructure.length - 2].count / treeStructure[treeStructure.length - 1].count).toFixed(2)
+                  : 'N/A'
+                }
+              </span>
+            </div>
+            <div className="flex justify-between">
+              <span>Lookup Cost:</span>
+              <span className="font-bold">{indexAnalysis.treeHeight} I/Os</span>
+            </div>
+            <div className="flex justify-between">
+              <span>Index Bloat:</span>
+              <span className="font-bold text-red-600">
+                {Math.max(0, 100 - indexAnalysis.averageUtilization).toFixed(1)}%
+              </span>
+            </div>
+          </div>
+        </div>
+      </div>
+
+      <div className="mb-6">
+        <h4 className="text-md font-medium text-gray-900 mb-3">Tree Structure Visualization</h4>
+        <div className="bg-gray-50 rounded-lg p-4">
+          <div className="space-y-4">
+            {treeStructure?.map((level, index) => (
+              <div key={level.level} className="flex items-center space-x-4">
+                <div className="text-sm font-medium text-gray-700 w-20">
+                  Level {level.level}:
+                </div>
+                <div className="flex-1">
+                  <div className="flex space-x-2">
+                    {level.pages.map((page, pageIndex) => (
+                      <div
+                        key={page.header.pageNumber}
+                        className={`px-3 py-2 rounded text-xs font-mono cursor-pointer hover:opacity-80 ${
+                          page.node.isLeaf 
+                            ? 'bg-green-100 text-green-800 border border-green-200' 
+                            : 'bg-blue-100 text-blue-800 border border-blue-200'
+                        }`}
+                        title={`Page ${page.header.pageNumber}: ${page.node.keys.length} keys, ${page.utilization.toFixed(1)}% full`}
+                      >
+                        {page.header.pageNumber}
+                        <div className="text-xs opacity-75">
+                          {page.node.keys.length} keys
+                        </div>
+                      </div>
+                    ))}
+                  </div>
+                </div>
+                <div className="text-sm text-gray-600 w-16 text-right">
+                  {level.count} pages
+                </div>
+              </div>
+            ))}
+          </div>
+        </div>
+      </div>
+
+      <div className="mb-6">
+        <h4 className="text-md font-medium text-gray-900 mb-3">Index Pages Details</h4>
+        <div className="bg-white border border-gray-200 rounded-lg overflow-hidden">
+          <table className="min-w-full divide-y divide-gray-200">
+            <thead className="bg-gray-50">
+              <tr>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Page</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Type</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Level</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Keys</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Pointers</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Utilization</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Key Range</th>
+              </tr>
+            </thead>
+            <tbody className="bg-white divide-y divide-gray-200">
+              {snapshot.indexPages.map((page) => (
+                <tr key={page.header.pageNumber} className="hover:bg-gray-50">
+                  <td className="px-4 py-2 text-sm font-medium">{page.header.pageNumber}</td>
+                  <td className="px-4 py-2 text-sm">
+                    <span className={`inline-flex px-2 py-1 text-xs rounded-full ${
+                      page.node.isLeaf 
+                        ? 'bg-green-100 text-green-800' 
+                        : 'bg-blue-100 text-blue-800'
+                    }`}>
+                      {page.node.isLeaf ? 'LEAF' : 'INTERNAL'}
+                    </span>
+                  </td>
+                  <td className="px-4 py-2 text-sm font-mono">{page.node.level}</td>
+                  <td className="px-4 py-2 text-sm font-mono">{page.node.keys.length}</td>
+                  <td className="px-4 py-2 text-sm font-mono">{page.node.childPointers.length}</td>
+                  <td className="px-4 py-2 text-sm">
+                    <div className="flex items-center">
+                      <div className="flex-1 bg-gray-200 rounded-full h-2 mr-2">
+                        <div 
+                          className={`h-2 rounded-full ${
+                            page.utilization > 80 ? 'bg-green-500' :
+                            page.utilization > 60 ? 'bg-yellow-500' : 'bg-red-500'
+                          }`}
+                          style={{ width: `${page.utilization}%` }}
+                        ></div>
+                      </div>
+                      <span className="text-xs font-mono">{page.utilization.toFixed(1)}%</span>
+                    </div>
+                  </td>
+                  <td className="px-4 py-2 text-sm font-mono text-xs">
+                    {page.keyRanges.length > 0 ? (
+                      <div>
+                        <div>Min: {page.keyRanges[0]?.min || 'N/A'}</div>
+                        <div>Max: {page.keyRanges[page.keyRanges.length - 1]?.max || 'N/A'}</div>
+                      </div>
+                    ) : (
+                      'N/A'
+                    )}
+                  </td>
+                </tr>
+              ))}
+            </tbody>
+          </table>
+        </div>
+      </div>
+
+      <div>
+        <h4 className="text-md font-medium text-gray-900 mb-3">Key Distribution Analysis</h4>
+        <div className="bg-gray-50 rounded-lg p-4">
+          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
+            <div>
+              <div className="font-medium text-gray-900">Keys per Page Distribution</div>
+              <div className="mt-2">
+                {getKeyDistribution(snapshot.indexPages).map((bucket, index) => (
+                  <div key={index} className="flex justify-between py-1">
+                    <span className="text-gray-600">{bucket.range}:</span>
+                    <span className="font-mono">{bucket.count} pages</span>
+                  </div>
+                ))}
+              </div>
+            </div>
+            
+            <div>
+              <div className="font-medium text-gray-900">Utilization Distribution</div>
+              <div className="mt-2">
+                {getUtilizationDistribution(snapshot.indexPages).map((bucket, index) => (
+                  <div key={index} className="flex justify-between py-1">
+                    <span className="text-gray-600">{bucket.range}:</span>
+                    <span className="font-mono">{bucket.count} pages</span>
+                  </div>
+                ))}
+              </div>
+            </div>
+            
+            <div>
+              <div className="font-medium text-gray-900">Page Balance</div>
+              <div className="mt-2 space-y-1">
+                <div className="flex justify-between">
+                  <span className="text-gray-600">Well Balanced:</span>
+                  <span className="font-mono text-green-600">
+                    {getWellBalancedPages(snapshot.indexPages)}%
+                  </span>
+                </div>
+                <div className="flex justify-between">
+                  <span className="text-gray-600">Needs Rebuild:</span>
+                  <span className="font-mono text-red-600">
+                    {getPagesNeedingRebuild(snapshot.indexPages)}%
+                  </span>
+                </div>
+              </div>
+            </div>
+          </div>
+        </div>
+      </div>
+    </div>
+  )
+}
+
+function getKeyDistribution(pages: IndexPage[]) {
+  const distribution = [
+    { range: '0-10 keys', count: 0 },
+    { range: '11-50 keys', count: 0 },
+    { range: '51-100 keys', count: 0 },
+    { range: '101-200 keys', count: 0 },
+    { range: '200+ keys', count: 0 }
+  ]
+
+  pages.forEach(page => {
+    const keyCount = page.node.keys.length
+    if (keyCount <= 10) distribution[0].count++
+    else if (keyCount <= 50) distribution[1].count++
+    else if (keyCount <= 100) distribution[2].count++
+    else if (keyCount <= 200) distribution[3].count++
+    else distribution[4].count++
+  })
+
+  return distribution
+}
+
+function getUtilizationDistribution(pages: IndexPage[]) {
+  const distribution = [
+    { range: '0-25%', count: 0 },
+    { range: '26-50%', count: 0 },
+    { range: '51-75%', count: 0 },
+    { range: '76-90%', count: 0 },
+    { range: '91-100%', count: 0 }
+  ]
+
+  pages.forEach(page => {
+    const util = page.utilization
+    if (util <= 25) distribution[0].count++
+    else if (util <= 50) distribution[1].count++
+    else if (util <= 75) distribution[2].count++
+    else if (util <= 90) distribution[3].count++
+    else distribution[4].count++
+  })
+
+  return distribution
+}
+
+function getWellBalancedPages(pages: IndexPage[]) {
+  if (pages.length === 0) return 0
+  
+  const keyCounts = pages.map(p => p.node.keys.length)
+  const avgKeys = keyCounts.reduce((sum, count) => sum + count, 0) / keyCounts.length
+  const threshold = avgKeys * 0.3
+  
+  const wellBalanced = keyCounts.filter(count => Math.abs(count - avgKeys) <= threshold).length
+  return Math.round((wellBalanced / pages.length) * 100)
+}
+
+function getPagesNeedingRebuild(pages: IndexPage[]) {
+  if (pages.length === 0) return 0
+  
+  const needingRebuild = pages.filter(page => page.utilization < 50 || page.utilization > 95).length
+  return Math.round((needingRebuild / pages.length) * 100)
+}
--- repository_before/repository_after/src/components/MetricsPanel.tsx	2026-01-28 12:47:12
+++ repository_after/src/components/MetricsPanel.tsx	2026-01-28 09:38:11
@@ -0,0 +1,283 @@
+'use client'
+
+import { useMemo } from 'react'
+import { useStorageStore } from '@/store/storageStore'
+import { StorageSnapshot } from '@/types/storage'
+
+export default function MetricsPanel() {
+  const { currentSnapshot } = useStorageStore()
+
+  if (!currentSnapshot) {
+    return (
+      <div className="bg-white rounded-lg shadow-md p-6">
+        <h3 className="text-lg font-medium text-gray-900 mb-4">Storage Metrics</h3>
+        <div className="text-center text-gray-500">
+          <div className="text-sm">No data available</div>
+        </div>
+      </div>
+    )
+  }
+
+  const metrics = currentSnapshot.metrics
+  const efficiencyGrade = calculateEfficiencyGrade(metrics)
+  const recommendations = generateRecommendations(metrics)
+
+  return (
+    <div className="bg-white rounded-lg shadow-md p-6">
+      <h3 className="text-lg font-medium text-gray-900 mb-4">Storage Metrics</h3>
+      
+      <div className="mb-6">
+        <div className="flex items-center justify-between mb-2">
+          <span className="text-sm font-medium text-gray-700">Overall Efficiency</span>
+          <span className={`px-2 py-1 text-xs rounded-full ${efficiencyGrade.color}`}>
+            {efficiencyGrade.grade}
+          </span>
+        </div>
+        <div className="w-full bg-gray-200 rounded-full h-2">
+          <div 
+            className={`h-2 rounded-full ${efficiencyGrade.bgColor}`}
+            style={{ width: `${efficiencyGrade.score}%` }}
+          ></div>
+        </div>
+      </div>
+
+      <div className="space-y-4">
+        <div className="border-b border-gray-200 pb-4">
+          <h4 className="text-sm font-medium text-gray-900 mb-3">Storage Utilization</h4>
+          <div className="space-y-2">
+            <MetricRow
+              label="Total Pages"
+              value={metrics.totalPages}
+              format="number"
+            />
+            <MetricRow
+              label="Used Pages"
+              value={metrics.usedPages}
+              format="number"
+            />
+            <MetricRow
+              label="Page Density"
+              value={metrics.pageDensity}
+              format="percentage"
+            />
+            <MetricRow
+              label="Average Fill Factor"
+              value={metrics.averageFillFactor}
+              format="percentage"
+            />
+          </div>
+        </div>
+
+        <div className="border-b border-gray-200 pb-4">
+          <h4 className="text-sm font-medium text-gray-900 mb-3">Fragmentation Analysis</h4>
+          <div className="space-y-2">
+            <MetricRow
+              label="Fragmentation Ratio"
+              value={metrics.fragmentationRatio}
+              format="percentage"
+              threshold={{ good: 10, warning: 25 }}
+            />
+            <MetricRow
+              label="Dead Tuple Ratio"
+              value={metrics.deadTupleRatio}
+              format="percentage"
+              threshold={{ good: 5, warning: 15 }}
+            />
+            <MetricRow
+              label="Free Space"
+              value={metrics.freeBytes}
+              format="bytes"
+            />
+          </div>
+        </div>
+
+        <div className="border-b border-gray-200 pb-4">
+          <h4 className="text-sm font-medium text-gray-900 mb-3">Bloat Estimation</h4>
+          <div className="space-y-2">
+            <MetricRow
+              label="Table Bloat"
+              value={metrics.bloatEstimate}
+              format="percentage"
+              threshold={{ good: 10, warning: 20 }}
+            />
+            <MetricRow
+              label="Index Bloat"
+              value={metrics.indexBloatEstimate}
+              format="percentage"
+              threshold={{ good: 15, warning: 30 }}
+            />
+            <MetricRow
+              label="Wasted Space"
+              value={metrics.usedBytes * (metrics.bloatEstimate / 100)}
+              format="bytes"
+            />
+          </div>
+        </div>
+
+        <div className="pb-4">
+          <h4 className="text-sm font-medium text-gray-900 mb-3">Storage Size</h4>
+          <div className="space-y-2">
+            <MetricRow
+              label="Total Size"
+              value={metrics.totalBytes}
+              format="bytes"
+            />
+            <MetricRow
+              label="Used Size"
+              value={metrics.usedBytes}
+              format="bytes"
+            />
+            <MetricRow
+              label="Available Size"
+              value={metrics.freeBytes}
+              format="bytes"
+            />
+          </div>
+        </div>
+      </div>
+
+      {recommendations.length > 0 && (
+        <div className="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
+          <h4 className="text-sm font-medium text-blue-900 mb-2">Recommendations</h4>
+          <ul className="text-sm text-blue-700 space-y-1">
+            {recommendations.map((rec, index) => (
+              <li key={index} className="flex items-start">
+                <span className="mr-2">•</span>
+                <span>{rec}</span>
+              </li>
+            ))}
+          </ul>
+        </div>
+      )}
+    </div>
+  )
+}
+
+interface MetricRowProps {
+  label: string
+  value: number
+  format: 'number' | 'percentage' | 'bytes'
+  threshold?: { good: number; warning: number }
+}
+
+function MetricRow({ label, value, format, threshold }: MetricRowProps) {
+  const formattedValue = useMemo(() => {
+    switch (format) {
+      case 'number':
+        return value.toLocaleString()
+      case 'percentage':
+        return `${value.toFixed(1)}%`
+      case 'bytes':
+        if (value >= 1024 * 1024 * 1024) {
+          return `${(value / (1024 * 1024 * 1024)).toFixed(2)} GB`
+        } else if (value >= 1024 * 1024) {
+          return `${(value / (1024 * 1024)).toFixed(2)} MB`
+        } else if (value >= 1024) {
+          return `${(value / 1024).toFixed(2)} KB`
+        } else {
+          return `${value} bytes`
+        }
+      default:
+        return value.toString()
+    }
+  }, [value, format])
+
+  const statusColor = useMemo(() => {
+    if (!threshold) return 'text-gray-600'
+    
+    if (format === 'percentage') {
+      if (value <= threshold.good) return 'text-green-600'
+      if (value <= threshold.warning) return 'text-yellow-600'
+      return 'text-red-600'
+    }
+    
+    return 'text-gray-600'
+  }, [value, format, threshold])
+
+  return (
+    <div className="flex justify-between items-center">
+      <span className="text-sm text-gray-600">{label}:</span>
+      <span className={`text-sm font-medium ${statusColor}`}>
+        {formattedValue}
+      </span>
+    </div>
+  )
+}
+
+function calculateEfficiencyGrade(metrics: any) {
+  let score = 100
+  
+  score -= Math.min(metrics.fragmentationRatio * 2, 30)
+  score -= Math.min(metrics.deadTupleRatio * 3, 25)
+  score -= Math.min(metrics.bloatEstimate * 1.5, 20)
+  score -= Math.min((100 - metrics.averageFillFactor) * 0.5, 15)
+  
+  score = Math.max(0, Math.min(100, score))
+  
+  let grade, color, bgColor
+  if (score >= 90) {
+    grade = 'A+'
+    color = 'bg-green-100 text-green-800'
+    bgColor = 'bg-green-500'
+  } else if (score >= 80) {
+    grade = 'A'
+    color = 'bg-green-100 text-green-800'
+    bgColor = 'bg-green-500'
+  } else if (score >= 70) {
+    grade = 'B'
+    color = 'bg-blue-100 text-blue-800'
+    bgColor = 'bg-blue-500'
+  } else if (score >= 60) {
+    grade = 'C'
+    color = 'bg-yellow-100 text-yellow-800'
+    bgColor = 'bg-yellow-500'
+  } else if (score >= 50) {
+    grade = 'D'
+    color = 'bg-orange-100 text-orange-800'
+    bgColor = 'bg-orange-500'
+  } else {
+    grade = 'F'
+    color = 'bg-red-100 text-red-800'
+    bgColor = 'bg-red-500'
+  }
+  
+  return { grade, color, bgColor, score }
+}
+
+function generateRecommendations(metrics: any): string[] {
+  const recommendations: string[] = []
+  
+  if (metrics.fragmentationRatio > 25) {
+    recommendations.push('High fragmentation detected. Consider running VACUUM FULL or table rewrite.')
+  } else if (metrics.fragmentationRatio > 10) {
+    recommendations.push('Moderate fragmentation. Regular VACUUM operations recommended.')
+  }
+  
+  if (metrics.deadTupleRatio > 15) {
+    recommendations.push('High dead tuple ratio. Schedule more frequent VACUUM operations.')
+  } else if (metrics.deadTupleRatio > 5) {
+    recommendations.push('Monitor dead tuple ratio. Consider autovacuum tuning.')
+  }
+  
+  if (metrics.bloatEstimate > 20) {
+    recommendations.push('Significant table bloat detected. Consider table rewrite or reorganization.')
+  } else if (metrics.bloatEstimate > 10) {
+    recommendations.push('Moderate table bloat. Monitor and plan maintenance window.')
+  }
+  
+  if (metrics.indexBloatEstimate > 30) {
+    recommendations.push('High index bloat. Rebuild indexes to improve performance.')
+  } else if (metrics.indexBloatEstimate > 15) {
+    recommendations.push('Monitor index bloat. Schedule index rebuild during maintenance.')
+  }
+  
+  if (metrics.averageFillFactor < 70) {
+    recommendations.push('Low page fill factor. Review fill factor settings and data patterns.')
+  }
+  
+  if (recommendations.length === 0) {
+    recommendations.push('Storage metrics look healthy. Continue monitoring.')
+  }
+  
+  return recommendations
+}
--- repository_before/repository_after/src/components/PageLayoutView.tsx	2026-01-28 12:47:12
+++ repository_after/src/components/PageLayoutView.tsx	2026-01-28 09:37:38
@@ -0,0 +1,258 @@
+'use client'
+
+import { useMemo } from 'react'
+import { HeapPage } from '@/types/storage'
+
+interface PageLayoutViewProps {
+  page: HeapPage | null
+}
+
+export default function PageLayoutView({ page }: PageLayoutViewProps) {
+  const pageVisualization = useMemo(() => {
+    if (!page) return null
+
+    const pageSize = 8192
+    const headerSize = 24
+    const linePointerSize = 4
+    
+    const segments = []
+    
+    segments.push({
+      type: 'header',
+      offset: 0,
+      length: headerSize,
+      label: 'Page Header',
+      color: 'bg-blue-500'
+    })
+    
+    page.linePointers.forEach((lp, index) => {
+      if (lp.offset > 0) {
+        segments.push({
+          type: 'line-pointer',
+          offset: headerSize + (index * linePointerSize),
+          length: linePointerSize,
+          label: `LP ${index}`,
+          color: 'bg-green-500'
+        })
+        
+        segments.push({
+          type: 'tuple',
+          offset: lp.offset,
+          length: lp.length,
+          label: `Tuple ${index}`,
+          color: page.tuples[index]?.isDead ? 'bg-red-400' : 'bg-purple-500'
+        })
+      }
+    })
+    
+    if (page.freeSpace.length > 0) {
+      segments.push({
+        type: 'free-space',
+        offset: page.freeSpace.offset,
+        length: page.freeSpace.length,
+        label: `Free Space (${page.freeSpace.length} bytes)`,
+        color: 'bg-gray-300'
+      })
+    }
+    
+    segments.sort((a, b) => a.offset - b.offset)
+    
+    return segments
+  }, [page])
+
+  if (!page) {
+    return (
+      <div className="p-6 text-center text-gray-500">
+        <div className="text-lg font-medium">No page selected</div>
+        <div className="text-sm">Select a page from the overview to view its layout</div>
+      </div>
+    )
+  }
+
+  return (
+    <div className="p-6">
+      <div className="mb-6">
+        <h3 className="text-lg font-medium text-gray-900 mb-2">
+          Page {page.header.pageNumber} Layout
+        </h3>
+        <div className="text-sm text-gray-600">
+          Type: {page.header.pageType.toUpperCase()} | 
+          Fill Factor: {page.fillFactor.toFixed(1)}% | 
+          Dead Tuples: {(page.deadTupleRatio * 100).toFixed(1)}%
+        </div>
+      </div>
+
+      <div className="mb-6">
+        <div className="text-sm font-medium text-gray-700 mb-2">Page Map (8KB)</div>
+        <div className="relative bg-gray-100 rounded-lg p-4" style={{ minHeight: '120px' }}>
+          {pageVisualization?.map((segment, index) => {
+            const left = (segment.offset / 8192) * 100
+            const width = (segment.length / 8192) * 100
+            
+            return (
+              <div
+                key={index}
+                className={`absolute h-8 ${segment.color} text-xs text-white flex items-center justify-center rounded cursor-pointer hover:opacity-80`}
+                style={{
+                  left: `${left}%`,
+                  width: `${width}%`,
+                  minWidth: width < 1 ? '2px' : 'auto'
+                }}
+                title={`${segment.label}: ${segment.length} bytes at offset ${segment.offset}`}
+              >
+                {width > 5 && segment.label}
+              </div>
+            )
+          })}
+        </div>
+      </div>
+
+      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Page Header</h4>
+          <div className="bg-gray-50 rounded-lg p-4 text-sm font-mono">
+            <div className="grid grid-cols-2 gap-2">
+              <div>Page Number:</div>
+              <div className="font-bold">{page.header.pageNumber}</div>
+              <div>Page Type:</div>
+              <div className="font-bold">{page.header.pageType.toUpperCase()}</div>
+              <div>LSN:</div>
+              <div className="font-bold">{page.header.lsn}</div>
+              <div>Checksum:</div>
+              <div className="font-bold">{page.header.checksum}</div>
+              <div>Lower:</div>
+              <div className="font-bold">{page.header.lower}</div>
+              <div>Upper:</div>
+              <div className="font-bold">{page.header.upper}</div>
+              <div>Special:</div>
+              <div className="font-bold">{page.header.special}</div>
+              <div>Flags:</div>
+              <div className="font-bold">0x{page.header.flags.toString(16)}</div>
+            </div>
+          </div>
+        </div>
+
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Storage Statistics</h4>
+          <div className="bg-gray-50 rounded-lg p-4 text-sm">
+            <div className="space-y-2">
+              <div className="flex justify-between">
+                <span>Total Tuples:</span>
+                <span className="font-bold">{page.tuples.length}</span>
+              </div>
+              <div className="flex justify-between">
+                <span>Live Tuples:</span>
+                <span className="font-bold text-green-600">
+                  {page.tuples.filter(t => t.isVisible).length}
+                </span>
+              </div>
+              <div className="flex justify-between">
+                <span>Dead Tuples:</span>
+                <span className="font-bold text-red-600">
+                  {page.tuples.filter(t => t.isDead).length}
+                </span>
+              </div>
+              <div className="flex justify-between">
+                <span>Free Space:</span>
+                <span className="font-bold">{page.freeSpace.length} bytes</span>
+              </div>
+              <div className="flex justify-between">
+                <span>Used Space:</span>
+                <span className="font-bold">{8192 - page.freeSpace.length} bytes</span>
+              </div>
+              <div className="flex justify-between">
+                <span>Fragmentation:</span>
+                <span className="font-bold">
+                  {page.deadTupleRatio > 0.3 ? (
+                    <span className="text-red-600">High</span>
+                  ) : page.deadTupleRatio > 0.1 ? (
+                    <span className="text-yellow-600">Medium</span>
+                  ) : (
+                    <span className="text-green-600">Low</span>
+                  )}
+                </span>
+              </div>
+            </div>
+          </div>
+        </div>
+      </div>
+
+      <div className="mt-6">
+        <h4 className="text-md font-medium text-gray-900 mb-3">Line Pointers & Tuples</h4>
+        <div className="bg-white border border-gray-200 rounded-lg overflow-hidden">
+          <table className="min-w-full divide-y divide-gray-200">
+            <thead className="bg-gray-50">
+              <tr>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Index</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Offset</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Length</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Status</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Xmin</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Xmax</th>
+                <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">Data Size</th>
+              </tr>
+            </thead>
+            <tbody className="bg-white divide-y divide-gray-200">
+              {page.linePointers.map((lp, index) => {
+                const tuple = page.tuples[index]
+                return (
+                  <tr key={index} className="hover:bg-gray-50">
+                    <td className="px-4 py-2 text-sm font-medium">{index}</td>
+                    <td className="px-4 py-2 text-sm font-mono">{lp.offset}</td>
+                    <td className="px-4 py-2 text-sm font-mono">{lp.length}</td>
+                    <td className="px-4 py-2 text-sm">
+                      {tuple ? (
+                        <span className={`inline-flex px-2 py-1 text-xs rounded-full ${
+                          tuple.isVisible 
+                            ? 'bg-green-100 text-green-800' 
+                            : 'bg-red-100 text-red-800'
+                        }`}>
+                          {tuple.isVisible ? 'LIVE' : 'DEAD'}
+                        </span>
+                      ) : (
+                        <span className="text-gray-400">EMPTY</span>
+                      )}
+                    </td>
+                    <td className="px-4 py-2 text-sm font-mono">
+                      {tuple ? tuple.header.tXmin : '-'}
+                    </td>
+                    <td className="px-4 py-2 text-sm font-mono">
+                      {tuple ? tuple.header.tXmax : '-'}
+                    </td>
+                    <td className="px-4 py-2 text-sm font-mono">
+                      {tuple ? tuple.data.byteLength : '-'}
+                    </td>
+                  </tr>
+                )
+              })}
+            </tbody>
+          </table>
+        </div>
+      </div>
+
+      {page.freeSpace.length > 0 && (
+        <div className="mt-6">
+          <h4 className="text-md font-medium text-gray-900 mb-3">Free Space Analysis</h4>
+          <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
+            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
+              <div>
+                <div className="font-medium text-blue-900">Free Space Location</div>
+                <div className="text-blue-700">Offset: {page.freeSpace.offset}</div>
+              </div>
+              <div>
+                <div className="font-medium text-blue-900">Available Bytes</div>
+                <div className="text-blue-700">{page.freeSpace.length} bytes</div>
+              </div>
+              <div>
+                <div className="font-medium text-blue-900">Usable For</div>
+                <div className="text-blue-700">
+                  {Math.floor(page.freeSpace.length / 100)} average tuples
+                </div>
+              </div>
+            </div>
+          </div>
+        </div>
+      )}
+    </div>
+  )
+}
--- repository_before/repository_after/src/components/StorageVisualization.tsx	2026-01-28 12:47:12
+++ repository_after/src/components/StorageVisualization.tsx	2026-01-28 09:56:31
@@ -0,0 +1,271 @@
+'use client'
+
+import { useState, useEffect, useMemo } from 'react'
+import { useStorageStore } from '@/store/storageStore'
+import PageLayoutView from './PageLayoutView'
+import TupleInspector from './TupleInspector'
+import IndexVisualization from './IndexVisualization'
+import FragmentationHeatmap from './FragmentationHeatmap'
+import BinaryInspector from './BinaryInspector'
+import { StorageSnapshot } from '@/types/storage'
+
+type ViewMode = 'overview' | 'page-layout' | 'tuple-inspector' | 'index-visualization' | 'fragmentation' | 'binary-inspector'
+
+export default function StorageVisualization() {
+  const { currentSnapshot, selectedPage, selectedTuple, setSelectedPage, setSelectedTuple } = useStorageStore()
+  const [viewMode, setViewMode] = useState<ViewMode>('overview')
+  const [searchTerm, setSearchTerm] = useState('')
+
+  const filteredPages = useMemo(() => {
+    if (!currentSnapshot || !searchTerm) return currentSnapshot?.heapPages || []
+    
+    return currentSnapshot.heapPages.filter(page => 
+      page.header.pageNumber.toString().includes(searchTerm) ||
+      page.tuples.some(tuple => 
+        Object.keys(tuple.values).some(key => 
+          tuple.values[key]?.toString().toLowerCase().includes(searchTerm.toLowerCase())
+        )
+      )
+    )
+  }, [currentSnapshot, searchTerm])
+
+  const selectedPageData = useMemo(() => {
+    if (!currentSnapshot || selectedPage === null) return null
+    return currentSnapshot.heapPages.find(p => p.header.pageNumber === selectedPage) || null
+  }, [currentSnapshot, selectedPage])
+
+  const selectedTupleData = useMemo(() => {
+    if (!selectedPageData || selectedTuple === null) return null
+    return selectedPageData.tuples[selectedTuple] || null
+  }, [selectedPageData, selectedTuple])
+
+  useEffect(() => {
+    if (currentSnapshot && currentSnapshot.heapPages.length > 0 && selectedPage === null) {
+      setSelectedPage(currentSnapshot.heapPages[0].header.pageNumber)
+    }
+  }, [currentSnapshot, selectedPage, setSelectedPage])
+
+  if (!currentSnapshot) {
+    return (
+      <div className="bg-white rounded-lg shadow-md p-8">
+        <div className="text-center text-gray-500">
+          <svg className="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
+            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
+          </svg>
+          <h3 className="mt-2 text-sm font-medium text-gray-900">No storage snapshot loaded</h3>
+          <p className="mt-1 text-sm text-gray-500">Import a database dump to visualize storage internals</p>
+        </div>
+      </div>
+    )
+  }
+
+  const renderView = () => {
+    switch (viewMode) {
+      case 'overview':
+        return <OverviewView snapshot={currentSnapshot} onPageSelect={setSelectedPage} />
+      case 'page-layout':
+        return <PageLayoutView page={selectedPageData} />
+      case 'tuple-inspector':
+        return <TupleInspector tuple={selectedTupleData} page={selectedPageData} />
+      case 'index-visualization':
+        return <IndexVisualization snapshot={currentSnapshot} />
+      case 'fragmentation':
+        return <FragmentationHeatmap snapshot={currentSnapshot} />
+      case 'binary-inspector':
+        return <BinaryInspector snapshot={currentSnapshot} selectedPage={selectedPageData || undefined} selectedTuple={selectedTupleData || undefined} />
+      default:
+        return <OverviewView snapshot={currentSnapshot} onPageSelect={setSelectedPage} />
+    }
+  }
+
+  return (
+    <div className="space-y-6">
+      <div className="bg-white rounded-lg shadow-md p-6">
+        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between space-y-4 sm:space-y-0">
+          <div>
+            <h2 className="text-2xl font-semibold text-gray-900">
+              {currentSnapshot.databaseName}.{currentSnapshot.tableName}
+            </h2>
+            <p className="text-sm text-gray-500">
+              Loaded {new Date(currentSnapshot.timestamp).toLocaleString()}
+            </p>
+          </div>
+          
+          <div className="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
+            <input
+              type="text"
+              placeholder="Search pages or tuples..."
+              value={searchTerm}
+              onChange={(e) => setSearchTerm(e.target.value)}
+              className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
+            />
+            
+            <select
+              value={viewMode}
+              onChange={(e) => setViewMode(e.target.value as ViewMode)}
+              className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
+            >
+              <option value="overview">Overview</option>
+              <option value="page-layout">Page Layout</option>
+              <option value="tuple-inspector">Tuple Inspector</option>
+              <option value="index-visualization">Index Visualization</option>
+              <option value="fragmentation">Fragmentation Heatmap</option>
+              <option value="binary-inspector">Binary Inspector</option>
+            </select>
+          </div>
+        </div>
+        
+        <div className="mt-4 grid grid-cols-2 sm:grid-cols-4 gap-4">
+          <div className="text-center">
+            <div className="text-2xl font-bold text-blue-600">{currentSnapshot.metrics.totalPages}</div>
+            <div className="text-sm text-gray-500">Total Pages</div>
+          </div>
+          <div className="text-center">
+            <div className="text-2xl font-bold text-green-600">{currentSnapshot.heapPages.length}</div>
+            <div className="text-sm text-gray-500">Heap Pages</div>
+          </div>
+          <div className="text-center">
+            <div className="text-2xl font-bold text-purple-600">{currentSnapshot.indexPages.length}</div>
+            <div className="text-sm text-gray-500">Index Pages</div>
+          </div>
+          <div className="text-center">
+            <div className="text-2xl font-bold text-red-600">{currentSnapshot.corruptedPages.length}</div>
+            <div className="text-sm text-gray-500">Corrupted</div>
+          </div>
+        </div>
+      </div>
+
+      <div className="bg-white rounded-lg shadow-md">
+        {renderView()}
+      </div>
+    </div>
+  )
+}
+
+interface OverviewViewProps {
+  snapshot: StorageSnapshot
+  onPageSelect: (pageNumber: number) => void
+}
+
+function OverviewView({ snapshot, onPageSelect }: OverviewViewProps) {
+  const [selectedPageType, setSelectedPageType] = useState<'all' | 'heap' | 'index'>('all')
+
+  const filteredPages = selectedPageType === 'all' 
+    ? [...snapshot.heapPages, ...snapshot.indexPages]
+    : selectedPageType === 'heap' 
+    ? snapshot.heapPages
+    : snapshot.indexPages
+
+  return (
+    <div className="p-6">
+      <div className="mb-6">
+        <h3 className="text-lg font-medium text-gray-900 mb-4">Storage Overview</h3>
+        
+        <div className="flex space-x-4 mb-4">
+          <button
+            onClick={() => setSelectedPageType('all')}
+            className={`px-4 py-2 rounded-md ${
+              selectedPageType === 'all' 
+                ? 'bg-blue-600 text-white' 
+                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
+            }`}
+          >
+            All Pages ({snapshot.metrics.totalPages})
+          </button>
+          <button
+            onClick={() => setSelectedPageType('heap')}
+            className={`px-4 py-2 rounded-md ${
+              selectedPageType === 'heap' 
+                ? 'bg-blue-600 text-white' 
+                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
+            }`}
+          >
+            Heap ({snapshot.heapPages.length})
+          </button>
+          <button
+            onClick={() => setSelectedPageType('index')}
+            className={`px-4 py-2 rounded-md ${
+              selectedPageType === 'index' 
+                ? 'bg-blue-600 text-white' 
+                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
+            }`}
+          >
+            Index ({snapshot.indexPages.length})
+          </button>
+        </div>
+      </div>
+
+      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-h-96 overflow-y-auto">
+        {filteredPages.map((page) => {
+          const isHeap = 'tuples' in page
+          const fillFactor = isHeap ? page.fillFactor : page.utilization
+          const status = isHeap 
+            ? (page as any).deadTupleRatio > 0.5 ? 'warning' : 'healthy'
+            : 'healthy'
+
+          return (
+            <div
+              key={page.header.pageNumber}
+              onClick={() => onPageSelect(page.header.pageNumber)}
+              className="border border-gray-200 rounded-lg p-4 cursor-pointer hover:border-blue-400 hover:shadow-md transition-all"
+            >
+              <div className="flex justify-between items-start mb-2">
+                <div>
+                  <div className="font-medium text-gray-900">
+                    Page {page.header.pageNumber}
+                  </div>
+                  <div className="text-sm text-gray-500">
+                    {page.header.pageType.toUpperCase()}
+                  </div>
+                </div>
+                <div className={`px-2 py-1 text-xs rounded-full ${
+                  status === 'healthy' ? 'bg-green-100 text-green-800' : 'bg-yellow-100 text-yellow-800'
+                }`}>
+                  {status}
+                </div>
+              </div>
+              
+              <div className="space-y-1">
+                <div className="flex justify-between text-sm">
+                  <span className="text-gray-600">Fill Factor:</span>
+                  <span className="font-medium">{fillFactor.toFixed(1)}%</span>
+                </div>
+                
+                {isHeap && (
+                  <>
+                    <div className="flex justify-between text-sm">
+                      <span className="text-gray-600">Tuples:</span>
+                      <span className="font-medium">{(page as any).tuples.length}</span>
+                    </div>
+                    <div className="flex justify-between text-sm">
+                      <span className="text-gray-600">Dead:</span>
+                      <span className="font-medium text-red-600">
+                        {((page as any).deadTupleRatio * 100).toFixed(1)}%
+                      </span>
+                    </div>
+                  </>
+                )}
+                
+                {!isHeap && (
+                  <div className="flex justify-between text-sm">
+                    <span className="text-gray-600">Keys:</span>
+                    <span className="font-medium">{(page as any).node.keys.length}</span>
+                  </div>
+                )}
+              </div>
+            </div>
+          )
+        })}
+      </div>
+
+      {snapshot.corruptedPages.length > 0 && (
+        <div className="mt-6 p-4 bg-red-50 border border-red-200 rounded-lg">
+          <h4 className="font-medium text-red-900 mb-2">Corrupted Pages</h4>
+          <div className="text-sm text-red-700">
+            {snapshot.corruptedPages.join(', ')}
+          </div>
+        </div>
+      )}
+    </div>
+  )
+}
--- repository_before/repository_after/src/components/TupleInspector.tsx	2026-01-28 12:47:12
+++ repository_after/src/components/TupleInspector.tsx	2026-01-28 09:59:57
@@ -0,0 +1,306 @@
+'use client'
+
+import { useMemo } from 'react'
+import { Tuple, HeapPage } from '@/types/storage'
+
+interface TupleInspectorProps {
+  tuple: Tuple | null
+  page: HeapPage | null
+}
+
+export default function TupleInspector({ tuple, page }: TupleInspectorProps) {
+  const headerAnalysis = useMemo(() => {
+    if (!tuple) return null
+    
+    return {
+      hasNulls: (tuple.header.tInfomask & 0x0001) !== 0,
+      hasVarlena: (tuple.header.tInfomask & 0x0002) !== 0,
+      isAlternate: (tuple.header.tInfomask & 0x0004) !== 0,
+      isExpanded: (tuple.header.tInfomask & 0x0008) !== 0,
+      isCompressed: (tuple.header.tInfomask & 0x0010) !== 0,
+      isLocked: (tuple.header.tInfomask & 0x0020) !== 0,
+      isUpdated: (tuple.header.tInfomask & 0x0040) !== 0,
+      numAttributes: tuple.header.tInfomask2 & 0x07FF,
+      transactionLevel: (tuple.header.tInfomask2 >> 11) & 0x03
+    }
+  }, [tuple])
+
+  const visibilityInfo = useMemo(() => {
+    if (!tuple) return null
+    
+    return {
+      isVisible: tuple.isVisible,
+      isDead: tuple.isDead,
+      xmin: tuple.header.tXmin,
+      xmax: tuple.header.tXmax,
+      cid: tuple.header.tCid,
+      status: tuple.isVisible ? 'VISIBLE' : 'DEAD',
+      lifecycle: getTupleLifecycle(tuple)
+    }
+  }, [tuple])
+
+  if (!tuple || !page) {
+    return (
+      <div className="p-6 text-center text-gray-500">
+        <div className="text-lg font-medium">No tuple selected</div>
+        <div className="text-sm">Select a tuple from the page layout to inspect</div>
+      </div>
+    )
+  }
+
+  return (
+    <div className="p-6">
+      <div className="mb-6">
+        <h3 className="text-lg font-medium text-gray-900 mb-2">
+          Tuple Inspector
+        </h3>
+        <div className="text-sm text-gray-600">
+          Page {page.header.pageNumber} | Offset {tuple.linePointer.offset} | 
+          Size {tuple.data.byteLength} bytes
+        </div>
+      </div>
+
+      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Tuple Header</h4>
+          <div className="bg-gray-50 rounded-lg p-4 text-sm font-mono space-y-2">
+            <div className="grid grid-cols-2 gap-2">
+              <div>Xmin:</div>
+              <div className="font-bold">{tuple.header.tXmin}</div>
+              <div>Xmax:</div>
+              <div className="font-bold">{tuple.header.tXmax}</div>
+              <div>Command ID:</div>
+              <div className="font-bold">{tuple.header.tCid}</div>
+              <div>Infomask:</div>
+              <div className="font-bold">0x{tuple.header.tInfomask.toString(16)}</div>
+              <div>Infomask2:</div>
+              <div className="font-bold">0x{tuple.header.tInfomask2.toString(16)}</div>
+              <div>Header Size:</div>
+              <div className="font-bold">{tuple.header.tHoff} bytes</div>
+              <div>Data Size:</div>
+              <div className="font-bold">{tuple.data.byteLength} bytes</div>
+            </div>
+          </div>
+        </div>
+
+        <div>
+          <h4 className="text-md font-medium text-gray-900 mb-3">Visibility Information</h4>
+          <div className="bg-gray-50 rounded-lg p-4 text-sm">
+            <div className="space-y-2">
+              <div className="flex justify-between">
+                <span>Status:</span>
+                <span className={`font-bold ${
+                  visibilityInfo?.isVisible 
+                    ? 'text-green-600' 
+                    : 'text-red-600'
+                }`}>
+                  {visibilityInfo?.status}
+                </span>
+              </div>
+              <div className="flex justify-between">
+                <span>Created by TX:</span>
+                <span className="font-mono">{visibilityInfo?.xmin}</span>
+              </div>
+              <div className="flex justify-between">
+                <span>Deleted by TX:</span>
+                <span className="font-mono">
+                  {visibilityInfo?.xmax === 0 ? 'N/A' : visibilityInfo?.xmax}
+                </span>
+              </div>
+              <div className="flex justify-between">
+                <span>Command ID:</span>
+                <span className="font-mono">{visibilityInfo?.cid}</span>
+              </div>
+              <div className="flex justify-between">
+                <span>Lifecycle:</span>
+                <span className="font-medium">{visibilityInfo?.lifecycle}</span>
+              </div>
+            </div>
+          </div>
+        </div>
+      </div>
+
+      <div className="mt-6">
+        <h4 className="text-md font-medium text-gray-900 mb-3">Header Flags</h4>
+        <div className="bg-gray-50 rounded-lg p-4">
+          <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
+            <FlagBadge 
+              label="Has NULLs" 
+              active={headerAnalysis?.hasNulls || false}
+            />
+            <FlagBadge 
+              label="Varlena" 
+              active={headerAnalysis?.hasVarlena || false}
+            />
+            <FlagBadge 
+              label="Alternate" 
+              active={headerAnalysis?.isAlternate || false}
+            />
+            <FlagBadge 
+              label="Expanded" 
+              active={headerAnalysis?.isExpanded || false}
+            />
+            <FlagBadge 
+              label="Compressed" 
+              active={headerAnalysis?.isCompressed || false}
+            />
+            <FlagBadge 
+              label="Locked" 
+              active={headerAnalysis?.isLocked || false}
+            />
+            <FlagBadge 
+              label="Updated" 
+              active={headerAnalysis?.isUpdated || false}
+            />
+            <div className="text-gray-600">
+              <div className="font-medium">Attributes</div>
+              <div>{headerAnalysis?.numAttributes}</div>
+            </div>
+          </div>
+        </div>
+      </div>
+
+      <div className="mt-6">
+        <h4 className="text-md font-medium text-gray-900 mb-3">NULL Bitmap</h4>
+        <div className="bg-gray-50 rounded-lg p-4">
+          {tuple.nullBitmap.length > 0 ? (
+            <div className="space-y-2">
+              <div className="text-sm text-gray-600 mb-2">
+                NULL bitmap shows which attributes are NULL:
+              </div>
+              <div className="flex flex-wrap gap-2">
+                {tuple.nullBitmap.map((isNull, index) => (
+                  <div
+                    key={index}
+                    className={`px-3 py-1 rounded-full text-xs font-mono ${
+                      isNull 
+                        ? 'bg-red-100 text-red-800' 
+                        : 'bg-green-100 text-green-800'
+                    }`}
+                  >
+                    Attr {index}: {isNull ? 'NULL' : 'NOT NULL'}
+                  </div>
+                ))}
+              </div>
+            </div>
+          ) : (
+            <div className="text-sm text-gray-500">No NULL bitmap (all attributes NOT NULL)</div>
+          )}
+        </div>
+      </div>
+
+      <div className="mt-6">
+        <h4 className="text-md font-medium text-gray-900 mb-3">Tuple Data</h4>
+        <div className="bg-gray-50 rounded-lg p-4">
+          <div className="space-y-3">
+            <div className="text-sm text-gray-600">
+              Raw tuple data ({tuple.data.byteLength} bytes):
+            </div>
+            
+            <div className="bg-white border border-gray-200 rounded p-3 font-mono text-xs overflow-x-auto">
+              <div className="max-h-32 overflow-y-auto">
+                {formatHexDump(new Uint8Array(tuple.data).buffer)}
+              </div>
+            </div>
+
+            {Object.keys(tuple.values).length > 0 && (
+              <div>
+                <div className="text-sm text-gray-600 mb-2">Decoded Values:</div>
+                <div className="bg-white border border-gray-200 rounded divide-y divide-gray-200">
+                  {Object.keys(tuple.values).map((key: string) => (
+                    <div key={key} className="px-3 py-2 flex justify-between items-center">
+                      <span className="text-sm font-medium text-gray-900">{key}:</span>
+                      <span className="text-sm font-mono text-gray-700">
+                        {tuple.values[key] === null ? (
+                          <span className="text-red-600">NULL</span>
+                        ) : (
+                          String(tuple.values[key])
+                        )}
+                      </span>
+                    </div>
+                  ))}
+                </div>
+              </div>
+            )}
+          </div>
+        </div>
+      </div>
+
+      <div className="mt-6">
+        <h4 className="text-md font-medium text-gray-900 mb-3">Line Pointer</h4>
+        <div className="bg-gray-50 rounded-lg p-4">
+          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
+            <div>
+              <div className="text-gray-600">Offset:</div>
+              <div className="font-mono font-bold">{tuple.linePointer.offset}</div>
+            </div>
+            <div>
+              <div className="text-gray-600">Length:</div>
+              <div className="font-mono font-bold">{tuple.linePointer.length}</div>
+            </div>
+            <div>
+              <div className="text-gray-600">Flags:</div>
+              <div className="font-mono font-bold">0x{tuple.linePointer.flags.toString(16)}</div>
+            </div>
+            <div>
+              <div className="text-gray-600">Total Size:</div>
+              <div className="font-mono font-bold">
+                {tuple.linePointer.length + tuple.header.tHoff} bytes
+              </div>
+            </div>
+          </div>
+        </div>
+      </div>
+    </div>
+  )
+}
+
+interface FlagBadgeProps {
+  label: string
+  active: boolean
+}
+
+function FlagBadge({ label, active }: FlagBadgeProps) {
+  return (
+    <div className={`px-3 py-1 rounded-full text-xs font-medium ${
+      active 
+        ? 'bg-blue-100 text-blue-800 border border-blue-200' 
+        : 'bg-gray-100 text-gray-500 border border-gray-200'
+    }`}>
+      {label}
+    </div>
+  )
+}
+
+function getTupleLifecycle(tuple: Tuple): string {
+  if (tuple.isVisible && tuple.header.tXmax === 0) {
+    return 'LIVE - Visible and not deleted'
+  } else if (!tuple.isVisible && tuple.header.tXmax > 0) {
+    return 'DEAD - Deleted by transaction'
+  } else if (!tuple.isVisible && tuple.header.tXmax === 0) {
+    return 'INVISIBLE - Not visible to current transaction'
+  } else {
+    return 'UNKNOWN - Ambiguous state'
+  }
+}
+
+function formatHexDump(data: ArrayBuffer): string {
+  const bytes = new Uint8Array(data)
+  const lines = []
+  
+  for (let i = 0; i < bytes.length; i += 16) {
+    const chunk = bytes.slice(i, i + 16)
+    const hex = Array.from(chunk)
+      .map(b => ('0' + b.toString(16)).slice(-2))
+      .join(' ')
+    const ascii = Array.from(chunk)
+      .map(b => (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.')
+      .join('')
+    
+    lines.push(
+      ('0000' + i.toString(16)).slice(-4) + '  ' + hex.padEnd(47) + ' |' + ascii + '|'
+    )
+  }
+  
+  return lines.join('\n')
+}
--- repository_before/repository_after/src/store/storageStore.ts	2026-01-28 12:47:12
+++ repository_after/src/store/storageStore.ts	2026-01-28 10:00:20
@@ -0,0 +1,113 @@
+import { create } from 'zustand'
+import { persist, createJSONStorage } from 'zustand/middleware'
+import { StorageSnapshot, InspectionLog, ComparisonResult, PageHeatmap } from '@/types/storage'
+
+interface StorageState {
+  snapshots: StorageSnapshot[]
+  currentSnapshot: StorageSnapshot | null
+  selectedPage: number | null
+  selectedTuple: number | null
+  inspectionLogs: InspectionLog[]
+  heatmaps: PageHeatmap[]
+  comparisons: ComparisonResult[]
+  isLoading: boolean
+  error: string | null
+  
+  // Actions
+  addSnapshot: (snapshot: StorageSnapshot) => void
+  removeSnapshot: (id: string) => void
+  setCurrentSnapshot: (id: string) => void
+  setSelectedPage: (pageNumber: number | null) => void
+  setSelectedTuple: (tupleNumber: number | null) => void
+  addInspectionLog: (log: InspectionLog) => void
+  addHeatmap: (heatmap: PageHeatmap) => void
+  addComparison: (comparison: ComparisonResult) => void
+  setLoading: (loading: boolean) => void
+  setError: (error: string | null) => void
+  clearError: () => void
+  clearAll: () => void
+}
+
+export const useStorageStore = create<StorageState>()(
+  persist(
+    (set, get) => ({
+      snapshots: [],
+      currentSnapshot: null,
+      selectedPage: null,
+      selectedTuple: null,
+      inspectionLogs: [],
+      heatmaps: [],
+      comparisons: [],
+      isLoading: false,
+      error: null,
+
+      addSnapshot: (snapshot) => set((state) => ({
+        snapshots: [...state.snapshots, snapshot],
+        currentSnapshot: state.currentSnapshot || snapshot,
+        error: null
+      })),
+
+      removeSnapshot: (id) => set((state) => {
+        const newSnapshots = state.snapshots.filter(s => s.id !== id)
+        const newCurrent = state.currentSnapshot?.id === id 
+          ? (newSnapshots.length > 0 ? newSnapshots[0] : null)
+          : state.currentSnapshot
+        
+        return {
+          snapshots: newSnapshots,
+          currentSnapshot: newCurrent
+        }
+      }),
+
+      setCurrentSnapshot: (id) => set((state) => ({
+        currentSnapshot: state.snapshots.find(s => s.id === id) || null,
+        selectedPage: null,
+        selectedTuple: null
+      })),
+
+      setSelectedPage: (pageNumber) => set({ selectedPage: pageNumber, selectedTuple: null }),
+
+      setSelectedTuple: (tupleNumber) => set({ selectedTuple: tupleNumber }),
+
+      addInspectionLog: (log) => set((state) => ({
+        inspectionLogs: [...state.inspectionLogs, log]
+      })),
+
+      addHeatmap: (heatmap) => set((state) => ({
+        heatmaps: [...state.heatmaps, heatmap]
+      })),
+
+      addComparison: (comparison) => set((state) => ({
+        comparisons: [...state.comparisons, comparison]
+      })),
+
+      setLoading: (loading) => set({ isLoading: loading }),
+
+      setError: (error) => set({ error, isLoading: false }),
+
+      clearError: () => set({ error: null }),
+
+      clearAll: () => set({
+        snapshots: [],
+        currentSnapshot: null,
+        selectedPage: null,
+        selectedTuple: null,
+        inspectionLogs: [],
+        heatmaps: [],
+        comparisons: [],
+        isLoading: false,
+        error: null
+      })
+    }),
+    {
+      name: 'db-storage-explorer-storage',
+      storage: createJSONStorage(() => localStorage),
+      partialize: (state) => ({
+        snapshots: state.snapshots,
+        inspectionLogs: state.inspectionLogs,
+        heatmaps: state.heatmaps,
+        comparisons: state.comparisons
+      })
+    }
+  )
+)
--- repository_before/repository_after/src/types/storage.ts	2026-01-28 12:47:12
+++ repository_after/src/types/storage.ts	2026-01-28 09:44:51
@@ -0,0 +1,174 @@
+export interface PageHeader {
+  pageType: 'heap' | 'index' | 'btree' | 'overflow'
+  pageNumber: number
+  lsn: number
+  checksum: number
+  lower: number
+  upper: number
+  special: number
+  flags: number
+  pruneXid: number
+}
+
+export interface TupleHeader {
+  tXmin: number
+  tXmax: number
+  tCid: number
+  tInfomask2: number
+  tInfomask: number
+  tHoff: number
+  tBits: number[]
+}
+
+export interface LinePointer {
+  offset: number
+  length: number
+  flags: number
+}
+
+export interface Tuple {
+  id: string
+  header: TupleHeader
+  linePointer: LinePointer
+  data: Uint8Array
+  isVisible: boolean
+  isDead: boolean
+  values: Record<string, any>
+  nullBitmap: boolean[]
+  offset?: number
+  length?: number
+}
+
+export interface HeapPage {
+  header: PageHeader
+  linePointers: LinePointer[]
+  tuples: Tuple[]
+  freeSpace: {
+    offset: number
+    length: number
+  }
+  fillFactor: number
+  deadTupleRatio: number
+}
+
+export interface IndexNode {
+  keys: string[]
+  childPointers: number[]
+  isLeaf: boolean
+  level: number
+  leftSibling?: number
+  rightSibling?: number
+}
+
+export interface IndexPage {
+  header: PageHeader
+  node: IndexNode
+  keyRanges: Array<{ min: string; max: string }>
+  utilization: number
+}
+
+export interface FreeSpaceMap {
+  pages: Array<{
+    pageNumber: number
+    freeBytes: number
+    isFull: boolean
+    hasDeadTuples: boolean
+  }>
+  totalFreeSpace: number
+  fragmentationIndex: number
+}
+
+export interface StorageMetrics {
+  totalPages: number
+  usedPages: number
+  freePages: number
+  totalBytes: number
+  usedBytes: number
+  freeBytes: number
+  fragmentationRatio: number
+  bloatEstimate: number
+  indexBloatEstimate: number
+  averageFillFactor: number
+  deadTupleRatio: number
+  pageDensity: number
+}
+
+export interface HeatmapData {
+  pageNumber: number
+  density: number
+  fragmentation: number
+}
+
+export interface StorageSnapshot {
+  id: string
+  name: string
+  timestamp: number
+  databaseName: string
+  tableName: string
+  heapPages: HeapPage[]
+  indexPages: IndexPage[]
+  freeSpaceMap: FreeSpaceMap
+  metrics: StorageMetrics
+  heatmapData?: HeatmapData[]
+  corruptedPages: number[]
+  parsingErrors: string[]
+}
+
+export interface PageHeatmap {
+  pageNumber: number
+  accessFrequency: number
+  modificationDensity: number
+  storageChurn: number
+  lastAccessed: number
+  lastModified: number
+}
+
+export interface InspectionLog {
+  id: string
+  timestamp: number
+  action: string
+  snapshotId: string
+  details: Record<string, any>
+  errors?: string[]
+}
+
+export interface BinaryInspection {
+  offset: number
+  bytes: number[]
+  hexString: string
+  asciiString: string
+  interpretation: string
+  fieldStructure?: {
+    name: string
+    type: string
+    size: number
+    value: any
+  }
+}
+
+export interface StorageOperation {
+  type: 'insert' | 'update' | 'delete' | 'vacuum' | 'compact'
+  targetPage: number
+  targetTuple?: number
+  beforeState: StorageSnapshot
+  afterState: StorageSnapshot
+  impact: {
+    pagesAffected: number[]
+    bytesFreed: number
+    bytesAllocated: number
+    fragmentationChange: number
+  }
+}
+
+export interface ComparisonResult {
+  snapshot1: string
+  snapshot2: string
+  pageChanges: Array<{
+    pageNumber: number
+    changeType: 'modified' | 'added' | 'removed'
+    details: string
+  }>
+  metricChanges: Partial<StorageMetrics>
+  fragmentationTrend: 'increasing' | 'decreasing' | 'stable'
+  recommendations: string[]
+}
--- repository_before/repository_after/src/utils/storageParser.ts	2026-01-28 12:47:12
+++ repository_after/src/utils/storageParser.ts	2026-01-28 10:08:11
@@ -0,0 +1,571 @@
+import { 
+  StorageSnapshot, 
+  HeapPage, 
+  IndexPage, 
+  PageHeader, 
+  TupleHeader, 
+  LinePointer, 
+  Tuple, 
+  FreeSpaceMap, 
+  StorageMetrics,
+  BinaryInspection 
+} from '@/types/storage'
+
+export class StorageParser {
+  private static readonly PAGE_SIZE = 8192
+  private static readonly PAGE_HEADER_SIZE = 24
+  private static readonly TUPLE_HEADER_SIZE = 23
+  private static readonly LINE_POINTER_SIZE = 4
+
+  static async parseFile(file: File): Promise<StorageSnapshot> {
+    const buffer = await file.arrayBuffer()
+    const dataView = new DataView(buffer)
+    
+    try {
+      const snapshot = this.detectFormatAndParse(buffer, dataView, file.name)
+      return snapshot
+    } catch (error) {
+      throw new Error(`Failed to parse file: ${error instanceof Error ? error.message : 'Unknown error'}`)
+    }
+  }
+
+  private static detectFormatAndParse(buffer: ArrayBuffer, dataView: DataView, filename: string): StorageSnapshot {
+    const firstBytes = new Uint8Array(buffer.slice(0, 16))
+    const hexString = Array.from(firstBytes).map(byte => ('0' + byte.toString(16)).slice(-2)).join('')
+    
+    if (this.isPostgreSQLDumpFormat(dataView)) {
+      return this.parsePostgreSQLDump(buffer, dataView, filename)
+    } else if (this.isJSONFormat(buffer)) {
+      return this.parseJSONDump(buffer, filename)
+    } else if (this.isBinaryPageFormat(dataView)) {
+      return this.parseBinaryPages(buffer, dataView, filename)
+    } else {
+      throw new Error('Unsupported database dump format')
+    }
+  }
+
+  private static isPostgreSQLDumpFormat(dataView: DataView): boolean {
+    if (dataView.byteLength < 24) return false
+    
+    const lsn = dataView.getUint32(4, true)
+    const checksum = dataView.getUint32(8, true)
+    
+    return lsn !== 0 && checksum !== 0
+  }
+
+  private static isJSONFormat(buffer: ArrayBuffer): boolean {
+    const text = new TextDecoder().decode(buffer.slice(0, 100))
+    return text.trim().startsWith('{') || text.trim().startsWith('[')
+  }
+
+  private static isBinaryPageFormat(dataView: DataView): boolean {
+    if (dataView.byteLength < 24) return false
+    
+    const lower = dataView.getUint16(16, true)
+    const upper = dataView.getUint16(18, true)
+    
+    return lower > 0 && upper > 0 && lower < this.PAGE_SIZE && upper < this.PAGE_SIZE
+  }
+
+  private static parsePostgreSQLDump(buffer: ArrayBuffer, dataView: DataView, filename: string): StorageSnapshot {
+    const pages: HeapPage[] = []
+    const indexPages: IndexPage[] = []
+    const corruptedPages: number[] = []
+    const parsingErrors: string[] = []
+    
+    const totalPages = Math.floor(buffer.byteLength / this.PAGE_SIZE)
+    
+    for (let pageNum = 0; pageNum < totalPages; pageNum++) {
+      const pageOffset = pageNum * this.PAGE_SIZE
+      const pageBuffer = buffer.slice(pageOffset, pageOffset + this.PAGE_SIZE)
+      const pageDataView = new DataView(pageBuffer)
+      
+      try {
+        const pageHeader = this.parsePageHeader(pageDataView, pageNum)
+        
+        if (pageHeader.pageType === 'heap') {
+          const heapPage = this.parseHeapPage(pageBuffer, pageDataView, pageHeader)
+          pages.push(heapPage)
+        } else if (pageHeader.pageType === 'index' || pageHeader.pageType === 'btree') {
+          const indexPage = this.parseIndexPage(pageBuffer, pageDataView, pageHeader)
+          indexPages.push(indexPage)
+        }
+      } catch (error) {
+        corruptedPages.push(pageNum)
+        parsingErrors.push(`Page ${pageNum}: ${error instanceof Error ? error.message : 'Unknown error'}`)
+      }
+    }
+    
+    const freeSpaceMap = this.buildFreeSpaceMap(pages)
+    const metrics = this.calculateMetrics(pages, indexPages, totalPages)
+    
+    return {
+      id: this.generateId(),
+      name: filename,
+      timestamp: Date.now(),
+      databaseName: this.extractDatabaseName(filename),
+      tableName: this.extractTableName(filename),
+      heapPages: pages,
+      indexPages,
+      freeSpaceMap,
+      metrics,
+      corruptedPages,
+      parsingErrors
+    }
+  }
+
+  private static parseJSONDump(buffer: ArrayBuffer, filename: string): StorageSnapshot {
+    try {
+      const jsonText = new TextDecoder().decode(buffer)
+      const data = JSON.parse(jsonText)
+      
+      return this.convertJSONToSnapshot(data, filename)
+    } catch (error) {
+      throw new Error(`Invalid JSON format: ${error instanceof Error ? error.message : 'Unknown error'}`)
+    }
+  }
+
+  private static parseBinaryPages(buffer: ArrayBuffer, dataView: DataView, filename: string): StorageSnapshot {
+    return this.parsePostgreSQLDump(buffer, dataView, filename)
+  }
+
+  private static parsePageHeader(dataView: DataView, pageNumber: number): PageHeader {
+    if (dataView.byteLength < this.PAGE_HEADER_SIZE) {
+      throw new Error('Page too small for header')
+    }
+    
+    const lsn = dataView.getUint32(4, true)
+    const checksum = dataView.getUint32(8, true)
+    const lower = dataView.getUint16(16, true)
+    const upper = dataView.getUint16(18, true)
+    const special = dataView.getUint32(20, true)
+    const flags = dataView.getUint16(14, true)
+    const pruneXid = dataView.getUint32(12, true)
+    
+    let pageType: PageHeader['pageType'] = 'heap'
+    if (flags & 0x0001) pageType = 'index'
+    if (flags & 0x0002) pageType = 'btree'
+    if (flags & 0x0004) pageType = 'overflow'
+    
+    return {
+      pageType,
+      pageNumber,
+      lsn,
+      checksum,
+      lower,
+      upper,
+      special,
+      flags,
+      pruneXid
+    }
+  }
+
+  private static parseHeapPage(buffer: ArrayBuffer, dataView: DataView, header: PageHeader): HeapPage {
+    const linePointers: LinePointer[] = []
+    const tuples: Tuple[] = []
+    
+    const numLinePointers = Math.floor((header.lower - this.PAGE_HEADER_SIZE) / this.LINE_POINTER_SIZE)
+    
+    for (let i = 0; i < numLinePointers; i++) {
+      const offset = this.PAGE_HEADER_SIZE + (i * this.LINE_POINTER_SIZE)
+      const lpOffset = dataView.getUint16(offset, true)
+      const lpFlags = dataView.getUint16(offset + 2, true)
+      
+      if (lpOffset > 0) {
+        const linePointer: LinePointer = {
+          offset: lpOffset,
+          length: 0,
+          flags: lpFlags
+        }
+        
+        if (i < numLinePointers - 1) {
+          const nextOffset = dataView.getUint16(offset + this.LINE_POINTER_SIZE, true)
+          linePointer.length = nextOffset - lpOffset
+        } else {
+          linePointer.length = header.upper - lpOffset
+        }
+        
+        linePointers.push(linePointer)
+        
+        try {
+          const tuple = this.parseTuple(buffer, dataView, linePointer, header)
+          tuples.push(tuple)
+        } catch (error) {
+          console.warn(`Failed to parse tuple at offset ${lpOffset}:`, error)
+        }
+      }
+    }
+    
+    const freeSpace = {
+      offset: header.upper,
+      length: header.lower - header.upper
+    }
+    
+    const fillFactor = ((this.PAGE_SIZE - freeSpace.length) / this.PAGE_SIZE) * 100
+    const deadTuples = tuples.filter(t => t.isDead).length
+    const deadTupleRatio = tuples.length > 0 ? deadTuples / tuples.length : 0
+    
+    return {
+      header,
+      linePointers,
+      tuples,
+      freeSpace,
+      fillFactor,
+      deadTupleRatio
+    }
+  }
+
+  private static parseTuple(buffer: ArrayBuffer, dataView: DataView, linePointer: LinePointer, pageHeader: PageHeader): Tuple {
+    const tupleOffset = linePointer.offset
+    const tupleBuffer = buffer.slice(tupleOffset, tupleOffset + linePointer.length)
+    const tupleDataView = new DataView(tupleBuffer)
+    
+    if (tupleBuffer.byteLength < this.TUPLE_HEADER_SIZE) {
+      throw new Error('Tuple too small for header')
+    }
+    
+    const tXmin = tupleDataView.getUint32(0, true)
+    const tXmax = tupleDataView.getUint32(4, true)
+    const tCid = tupleDataView.getUint32(8, true)
+    const tInfomask2 = tupleDataView.getUint16(12, true)
+    const tInfomask = tupleDataView.getUint16(14, true)
+    const tHoff = tupleDataView.getUint8(16)
+    
+    const hasNulls = (tInfomask & 0x0001) !== 0
+    const numAttrs = tInfomask2 & 0x07FF
+    const nullBitmapSize = hasNulls ? Math.ceil((numAttrs + 1) / 8) : 0
+    
+    const nullBitmap: boolean[] = []
+    if (hasNulls && nullBitmapSize > 0) {
+      for (let i = 0; i < numAttrs; i++) {
+        const byteIndex = Math.floor(i / 8)
+        const bitIndex = i % 8
+        const bitmapByte = tupleDataView.getUint8(this.TUPLE_HEADER_SIZE + byteIndex)
+        nullBitmap.push((bitmapByte & (1 << (7 - bitIndex))) !== 0)
+      }
+    }
+    
+    const isVisible = tXmax === 0
+    const isDead = !isVisible
+    
+    const dataStart = tupleOffset + tHoff
+    const dataLength = linePointer.length - tHoff
+    const data = buffer.slice(dataStart, dataStart + dataLength)
+    
+    const values = this.extractTupleValues(data, tupleDataView, tHoff, numAttrs, nullBitmap)
+    
+    return {
+      id: `tuple-${pageHeader.pageNumber}-${linePointer.offset}`,
+      header: {
+        tXmin,
+        tXmax,
+        tCid,
+        tInfomask2,
+        tInfomask,
+        tHoff,
+        tBits: nullBitmap.map(b => b ? 1 : 0)
+      },
+      linePointer,
+      data: new Uint8Array(data),
+      isVisible,
+      isDead,
+      values,
+      nullBitmap
+    }
+  }
+
+  private static parseIndexPage(buffer: ArrayBuffer, dataView: DataView, header: PageHeader): IndexPage {
+    const specialOffset = header.special
+    const isLeaf = (header.flags & 0x0010) !== 0
+    
+    const keys: string[] = []
+    const childPointers: number[] = []
+    
+    let offset = this.PAGE_HEADER_SIZE
+    while (offset < specialOffset) {
+      const keySize = dataView.getUint16(offset, true)
+      offset += 2
+      
+      if (keySize > 0) {
+        const keyData = buffer.slice(offset, offset + keySize)
+        keys.push(new TextDecoder().decode(keyData))
+        offset += keySize
+      }
+      
+      if (!isLeaf) {
+        const childPtr = dataView.getUint32(offset, true)
+        childPointers.push(childPtr)
+        offset += 4
+      }
+    }
+    
+    const level = (header.flags >> 5) & 0x0F
+    const utilization = ((specialOffset - this.PAGE_HEADER_SIZE) / (this.PAGE_SIZE - this.PAGE_HEADER_SIZE)) * 100
+    
+    const keyRanges = this.calculateKeyRanges(keys)
+    
+    return {
+      header,
+      node: {
+        keys,
+        childPointers,
+        isLeaf,
+        level,
+        leftSibling: 0,
+        rightSibling: 0
+      },
+      keyRanges,
+      utilization
+    }
+  }
+
+  private static buildFreeSpaceMap(pages: HeapPage[]): FreeSpaceMap {
+    const pagesMap = pages.map(page => ({
+      pageNumber: page.header.pageNumber,
+      freeBytes: page.freeSpace.length,
+      isFull: page.freeSpace.length < 100,
+      hasDeadTuples: page.deadTupleRatio > 0
+    }))
+    
+    const totalFreeSpace = pagesMap.reduce((sum, p) => sum + p.freeBytes, 0)
+    const fragmentationIndex = this.calculateFragmentationIndex(pages)
+    
+    return {
+      pages: pagesMap,
+      totalFreeSpace,
+      fragmentationIndex
+    }
+  }
+
+  private static calculateMetrics(pages: HeapPage[], indexPages: IndexPage[], totalPages: number): StorageMetrics {
+    const usedPages = pages.length + indexPages.length
+    const freePages = totalPages - usedPages
+    const totalBytes = totalPages * this.PAGE_SIZE
+    const usedBytes = usedPages * this.PAGE_SIZE
+    const freeBytes = freePages * this.PAGE_SIZE
+    
+    const totalTuples = pages.reduce((sum, p) => sum + p.tuples.length, 0)
+    const deadTuples = pages.reduce((sum, p) => sum + p.tuples.filter(t => t.isDead).length, 0)
+    const deadTupleRatio = totalTuples > 0 ? deadTuples / totalTuples : 0
+    
+    const averageFillFactor = pages.length > 0 
+      ? pages.reduce((sum, p) => sum + p.fillFactor, 0) / pages.length 
+      : 0
+    
+    const fragmentationRatio = this.calculateFragmentationRatio(pages)
+    const bloatEstimate = this.calculateBloatEstimate(pages)
+    const indexBloatEstimate = this.calculateIndexBloatEstimate(indexPages)
+    const pageDensity = usedPages / totalPages
+    
+    return {
+      totalPages,
+      usedPages,
+      freePages,
+      totalBytes,
+      usedBytes,
+      freeBytes,
+      fragmentationRatio,
+      bloatEstimate,
+      indexBloatEstimate,
+      averageFillFactor,
+      deadTupleRatio,
+      pageDensity
+    }
+  }
+
+  private static calculateFragmentationIndex(pages: HeapPage[]): number {
+    if (pages.length === 0) return 0
+    
+    const freeSpaceVariance = this.calculateVariance(pages.map(p => p.freeSpace.length))
+    const maxFreeSpace = Math.max(...pages.map(p => p.freeSpace.length))
+    
+    return (freeSpaceVariance / (maxFreeSpace * maxFreeSpace)) * 100
+  }
+
+  private static calculateFragmentationRatio(pages: HeapPage[]): number {
+    if (pages.length === 0) return 0
+    
+    const totalFreeSpace = pages.reduce((sum, p) => sum + p.freeSpace.length, 0)
+    const totalSpace = pages.length * this.PAGE_SIZE
+    
+    return (totalFreeSpace / totalSpace) * 100
+  }
+
+  private static calculateBloatEstimate(pages: HeapPage[]): number {
+    if (pages.length === 0) return 0
+    
+    const deadTupleSpace = pages.reduce((sum, p) => {
+      const deadTuples = p.tuples.filter(t => t.isDead)
+      return sum + deadTuples.reduce((tupleSum, t) => tupleSum + t.data.byteLength, 0)
+    }, 0)
+    
+    const totalTupleSpace = pages.reduce((sum, p) => {
+      return sum + p.tuples.reduce((tupleSum, t) => tupleSum + t.data.byteLength, 0)
+    }, 0)
+    
+    return totalTupleSpace > 0 ? (deadTupleSpace / totalTupleSpace) * 100 : 0
+  }
+
+  private static calculateIndexBloatEstimate(indexPages: IndexPage[]): number {
+    if (indexPages.length === 0) return 0
+    
+    const averageUtilization = indexPages.reduce((sum, p) => sum + p.utilization, 0) / indexPages.length
+    return Math.max(0, 100 - averageUtilization)
+  }
+
+  private static calculateVariance(values: number[]): number {
+    if (values.length === 0) return 0
+    
+    const mean = values.reduce((sum, val) => sum + val, 0) / values.length
+    const squaredDiffs = values.map(val => Math.pow(val - mean, 2))
+    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / values.length
+  }
+
+  private static calculateKeyRanges(keys: string[]): Array<{ min: string; max: string }> {
+    if (keys.length === 0) return []
+    
+    const ranges: Array<{ min: string; max: string }> = []
+    for (let i = 0; i < keys.length - 1; i++) {
+      ranges.push({
+        min: keys[i],
+        max: keys[i + 1]
+      })
+    }
+    
+    return ranges
+  }
+
+  private static extractTupleValues(data: ArrayBuffer, dataView: DataView, offset: number, numAttrs: number, nullBitmap: boolean[]): Record<string, any> {
+    const values: Record<string, any> = {}
+    let currentOffset = 0
+    
+    for (let i = 0; i < numAttrs; i++) {
+      if (nullBitmap[i]) {
+        values[`attr_${i}`] = null
+        continue
+      }
+      
+      if (currentOffset >= data.byteLength) break
+      
+      const valueSize = Math.min(4, data.byteLength - currentOffset)
+      const valueBytes = new Uint8Array(data, currentOffset, valueSize)
+      
+      if (valueSize === 4) {
+        values[`attr_${i}`] = dataView.getUint32(offset + currentOffset, true)
+      } else if (valueSize === 2) {
+        values[`attr_${i}`] = dataView.getUint16(offset + currentOffset, true)
+      } else if (valueSize === 1) {
+        values[`attr_${i}`] = dataView.getUint8(offset + currentOffset)
+      } else {
+        values[`attr_${i}`] = new TextDecoder().decode(valueBytes)
+      }
+      
+      currentOffset += valueSize
+    }
+    
+    return values
+  }
+
+  private static convertJSONToSnapshot(data: any, filename: string): StorageSnapshot {
+    const heapPages: HeapPage[] = (data.heapPages || []).map((pageData: any) => ({
+      header: pageData.header,
+      linePointers: pageData.linePointers || [],
+      tuples: pageData.tuples || [],
+      freeSpace: pageData.freeSpace || { offset: 0, length: 0 },
+      fillFactor: pageData.fillFactor || 0,
+      deadTupleRatio: pageData.deadTupleRatio || 0
+    }))
+    
+    const indexPages: IndexPage[] = (data.indexPages || []).map((pageData: any) => ({
+      header: pageData.header,
+      node: pageData.node,
+      keyRanges: pageData.keyRanges || [],
+      utilization: pageData.utilization || 0
+    }))
+    
+    const freeSpaceMap = this.buildFreeSpaceMap(heapPages)
+    const metrics = this.calculateMetrics(heapPages, indexPages, data.totalPages || heapPages.length + indexPages.length)
+    
+    return {
+      id: this.generateId(),
+      name: filename,
+      timestamp: Date.now(),
+      databaseName: data.databaseName || 'unknown',
+      tableName: data.tableName || 'unknown',
+      heapPages,
+      indexPages,
+      freeSpaceMap,
+      metrics,
+      corruptedPages: data.corruptedPages || [],
+      parsingErrors: data.parsingErrors || []
+    }
+  }
+
+  private static extractDatabaseName(filename: string): string {
+    const match = filename.match(/(.+?)_/)
+    return match ? match[1] : 'unknown'
+  }
+
+  private static extractTableName(filename: string): string {
+    const match = filename.match(/_(.+?)(?:\..+)?$/)
+    return match ? match[1] : 'unknown'
+  }
+
+  private static generateId(): string {
+    return Math.random().toString(36).substr(2, 9)
+  }
+
+  static inspectBinary(snapshot: StorageSnapshot, pageNumber: number, offset: number, length: number): BinaryInspection[] {
+    const inspections: BinaryInspection[] = []
+    const page = snapshot.heapPages.find(p => p.header.pageNumber === pageNumber)
+    
+    if (!page) {
+      throw new Error(`Page ${pageNumber} not found`)
+    }
+    
+    const pageBuffer = new ArrayBuffer(this.PAGE_SIZE)
+    const dataView = new DataView(pageBuffer)
+    
+    for (let i = 0; i < length; i++) {
+      const currentOffset = offset + i
+      if (currentOffset >= this.PAGE_SIZE) break
+      
+      const byte = dataView.getUint8(currentOffset)
+      const bytes = [byte]
+      const hexString = ('0' + byte.toString(16)).slice(-2)
+      const asciiString = (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.'
+      
+      let interpretation = 'Data byte'
+      if (currentOffset < this.PAGE_HEADER_SIZE) {
+        interpretation = this.interpretHeaderByte(currentOffset, byte)
+      }
+      
+      inspections.push({
+        offset: currentOffset,
+        bytes,
+        hexString,
+        asciiString,
+        interpretation
+      })
+    }
+    
+    return inspections
+  }
+
+  private static interpretHeaderByte(offset: number, byte: number): string {
+    switch (offset) {
+      case 0: case 1: case 2: case 3:
+        return `Page Number: ${byte}`
+      case 4: case 5: case 6: case 7:
+        return `LSN byte ${offset - 4}`
+      case 8: case 9: case 10: case 11:
+        return `Checksum byte ${offset - 8}`
+      case 16: case 17:
+        return `Lower offset byte ${offset - 16}`
+      case 18: case 19:
+        return `Upper offset byte ${offset - 18}`
+      default:
+        return 'Header metadata'
+    }
+  }
+}
--- repository_before/repository_after/tailwind.config.js	2026-01-28 12:47:12
+++ repository_after/tailwind.config.js	2026-01-28 09:32:37
@@ -0,0 +1,27 @@
+/** @type {import('tailwindcss').Config} */
+module.exports = {
+  content: [
+    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
+    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
+    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
+  ],
+  theme: {
+    extend: {
+      colors: {
+        primary: {
+          50: '#eff6ff',
+          100: '#dbeafe',
+          200: '#bfdbfe',
+          300: '#93c5fd',
+          400: '#60a5fa',
+          500: '#3b82f6',
+          600: '#2563eb',
+          700: '#1d4ed8',
+          800: '#1e40af',
+          900: '#1e3a8a',
+        },
+      },
+    },
+  },
+  plugins: [],
+}
--- repository_before/repository_after/tsconfig.json	2026-01-28 12:47:12
+++ repository_after/tsconfig.json	2026-01-28 09:52:15
@@ -0,0 +1,28 @@
+{
+  "compilerOptions": {
+    "target": "es2020",
+    "lib": ["dom", "dom.iterable", "es2020"],
+    "allowJs": true,
+    "skipLibCheck": true,
+    "strict": true,
+    "forceConsistentCasingInFileNames": true,
+    "noEmit": true,
+    "esModuleInterop": true,
+    "module": "esnext",
+    "moduleResolution": "bundler",
+    "resolveJsonModule": true,
+    "isolatedModules": true,
+    "jsx": "preserve",
+    "incremental": true,
+    "plugins": [
+      {
+        "name": "next"
+      }
+    ],
+    "paths": {
+      "@/*": ["./src/*"]
+    }
+  },
+  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
+  "exclude": ["node_modules"]
+}
