diff --git a/repository_after/process_customer_order.sql b/repository_after/process_customer_order.sql
new file mode 100644
index 0000000..a3f8145
--- /dev/null
+++ b/repository_after/process_customer_order.sql
@@ -0,0 +1,331 @@
+-- PostgreSQL function for processing customer orders in an e-commerce system
+-- Implements transactional order processing with validation, inventory management, and audit logging
+
+-- Custom type for function return value
+DROP TYPE IF EXISTS order_result CASCADE;
+CREATE TYPE order_result AS (
+    success BOOLEAN,
+    order_id INTEGER,
+    error_code VARCHAR(50),
+    message TEXT
+);
+
+-- SQLite-style error codes mapping
+-- SQLITE_OK (0) -> SUCCESS
+-- SQLITE_NOTFOUND (12) -> NOT_FOUND
+-- SQLITE_CONSTRAINT (19) -> CONSTRAINT_VIOLATION
+-- SQLITE_MISMATCH (20) -> INVALID_INPUT
+-- SQLITE_BUSY (5) -> INSUFFICIENT_INVENTORY
+
+CREATE OR REPLACE FUNCTION process_customer_order(
+    p_customer_id INTEGER,
+    p_product_id INTEGER,
+    p_order_quantity INTEGER,
+    p_order_timestamp TIMESTAMP WITH TIME ZONE,
+    p_request_id UUID
+)
+RETURNS order_result
+LANGUAGE plpgsql
+AS $$
+DECLARE
+    v_result order_result;
+    v_customer_exists BOOLEAN;
+    v_customer_active BOOLEAN;
+    v_product_exists BOOLEAN;
+    v_product_available BOOLEAN;
+    v_current_inventory INTEGER;
+    v_unit_price NUMERIC(12, 2);
+    v_total_price NUMERIC(12, 2);
+    v_new_order_id INTEGER;
+    v_duplicate_exists BOOLEAN;
+BEGIN
+    -- Initialize result
+    v_result.success := FALSE;
+    v_result.order_id := NULL;
+    v_result.error_code := NULL;
+    v_result.message := NULL;
+
+    -- Defensive check: Validate input parameters are not null
+    IF p_customer_id IS NULL THEN
+        v_result.error_code := 'SQLITE_MISMATCH';
+        v_result.message := 'Invalid input: customer_id cannot be null';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'null_customer_id'));
+        
+        RETURN v_result;
+    END IF;
+
+    IF p_product_id IS NULL THEN
+        v_result.error_code := 'SQLITE_MISMATCH';
+        v_result.message := 'Invalid input: product_id cannot be null';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'null_product_id'));
+        
+        RETURN v_result;
+    END IF;
+
+    IF p_order_quantity IS NULL THEN
+        v_result.error_code := 'SQLITE_MISMATCH';
+        v_result.message := 'Invalid input: order_quantity cannot be null';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'null_order_quantity'));
+        
+        RETURN v_result;
+    END IF;
+
+    IF p_order_timestamp IS NULL THEN
+        v_result.error_code := 'SQLITE_MISMATCH';
+        v_result.message := 'Invalid input: order_timestamp cannot be null';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'null_order_timestamp'));
+        
+        RETURN v_result;
+    END IF;
+
+    IF p_request_id IS NULL THEN
+        v_result.error_code := 'SQLITE_MISMATCH';
+        v_result.message := 'Invalid input: request_id cannot be null';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'null_request_id'));
+        
+        RETURN v_result;
+    END IF;
+
+    -- Defensive check: Validate order quantity is positive
+    IF p_order_quantity <= 0 THEN
+        v_result.error_code := 'SQLITE_MISMATCH';
+        v_result.message := 'Invalid input: order_quantity must be greater than zero';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'invalid_quantity', 'provided_quantity', p_order_quantity));
+        
+        RETURN v_result;
+    END IF;
+
+    -- Check for duplicate request_id to prevent duplicate order processing
+    SELECT EXISTS(SELECT 1 FROM orders WHERE request_id = p_request_id) INTO v_duplicate_exists;
+    
+    IF v_duplicate_exists THEN
+        v_result.error_code := 'SQLITE_CONSTRAINT';
+        v_result.message := 'Duplicate request: order with this request_id already exists';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'duplicate_request_id'));
+        
+        RETURN v_result;
+    END IF;
+
+    -- Verify customer exists
+    SELECT EXISTS(SELECT 1 FROM customers WHERE customer_id = p_customer_id) INTO v_customer_exists;
+    
+    IF NOT v_customer_exists THEN
+        v_result.error_code := 'SQLITE_NOTFOUND';
+        v_result.message := 'Customer not found: no customer exists with the provided customer_id';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'customer_not_found'));
+        
+        RETURN v_result;
+    END IF;
+
+    -- Verify customer is active
+    SELECT is_active INTO v_customer_active FROM customers WHERE customer_id = p_customer_id;
+    
+    IF NOT v_customer_active THEN
+        v_result.error_code := 'SQLITE_CONSTRAINT';
+        v_result.message := 'Customer inactive: the customer account is not active';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'customer_inactive'));
+        
+        RETURN v_result;
+    END IF;
+
+    -- Verify product exists
+    SELECT EXISTS(SELECT 1 FROM products WHERE product_id = p_product_id) INTO v_product_exists;
+    
+    IF NOT v_product_exists THEN
+        v_result.error_code := 'SQLITE_NOTFOUND';
+        v_result.message := 'Product not found: no product exists with the provided product_id';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'product_not_found'));
+        
+        RETURN v_result;
+    END IF;
+
+    -- Verify product is available for sale
+    SELECT is_available, unit_price INTO v_product_available, v_unit_price 
+    FROM products WHERE product_id = p_product_id;
+    
+    IF NOT v_product_available THEN
+        v_result.error_code := 'SQLITE_CONSTRAINT';
+        v_result.message := 'Product unavailable: the product is not available for sale';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'product_unavailable'));
+        
+        RETURN v_result;
+    END IF;
+
+    -- Check inventory availability with row-level locking for concurrency control
+    SELECT quantity INTO v_current_inventory 
+    FROM inventory 
+    WHERE product_id = p_product_id
+    FOR UPDATE;
+    
+    IF v_current_inventory IS NULL THEN
+        v_result.error_code := 'SQLITE_NOTFOUND';
+        v_result.message := 'Inventory not found: no inventory record exists for the product';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'inventory_not_found'));
+        
+        RETURN v_result;
+    END IF;
+
+    IF v_current_inventory < p_order_quantity THEN
+        v_result.error_code := 'SQLITE_BUSY';
+        v_result.message := 'Insufficient inventory: not enough stock available for the requested quantity';
+        
+        INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+        VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                jsonb_build_object('reason', 'insufficient_inventory', 'available', v_current_inventory, 'requested', p_order_quantity));
+        
+        RETURN v_result;
+    END IF;
+
+    -- Calculate total order price
+    v_total_price := v_unit_price * p_order_quantity;
+
+    -- Begin transactional operations (implicit in function)
+    BEGIN
+        -- Insert new order with PENDING status
+        INSERT INTO orders (
+            customer_id,
+            product_id,
+            quantity,
+            unit_price,
+            total_price,
+            status,
+            request_id,
+            order_timestamp
+        ) VALUES (
+            p_customer_id,
+            p_product_id,
+            p_order_quantity,
+            v_unit_price,
+            v_total_price,
+            'PENDING',
+            p_request_id,
+            p_order_timestamp
+        ) RETURNING order_id INTO v_new_order_id;
+
+        -- Update inventory to deduct ordered quantity
+        UPDATE inventory
+        SET quantity = quantity - p_order_quantity,
+            last_updated = CURRENT_TIMESTAMP
+        WHERE product_id = p_product_id;
+
+        -- Insert audit log entry for successful order
+        INSERT INTO order_audit_log (
+            order_id,
+            request_id,
+            customer_id,
+            product_id,
+            action,
+            status,
+            error_code,
+            message,
+            details
+        ) VALUES (
+            v_new_order_id,
+            p_request_id,
+            p_customer_id,
+            p_product_id,
+            'PROCESS_ORDER',
+            'SUCCESS',
+            'SQLITE_OK',
+            'Order processed successfully',
+            jsonb_build_object(
+                'order_id', v_new_order_id,
+                'quantity', p_order_quantity,
+                'unit_price', v_unit_price,
+                'total_price', v_total_price,
+                'inventory_before', v_current_inventory,
+                'inventory_after', v_current_inventory - p_order_quantity
+            )
+        );
+
+        -- Set success result
+        v_result.success := TRUE;
+        v_result.order_id := v_new_order_id;
+        v_result.error_code := 'SQLITE_OK';
+        v_result.message := 'Order processed successfully';
+
+        RETURN v_result;
+
+    EXCEPTION
+        WHEN unique_violation THEN
+            v_result.error_code := 'SQLITE_CONSTRAINT';
+            v_result.message := 'Constraint violation: duplicate entry detected';
+            
+            INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+            VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                    jsonb_build_object('reason', 'unique_violation', 'sqlstate', SQLSTATE));
+            
+            RETURN v_result;
+
+        WHEN check_violation THEN
+            v_result.error_code := 'SQLITE_CONSTRAINT';
+            v_result.message := 'Constraint violation: check constraint failed';
+            
+            INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+            VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                    jsonb_build_object('reason', 'check_violation', 'sqlstate', SQLSTATE));
+            
+            RETURN v_result;
+
+        WHEN foreign_key_violation THEN
+            v_result.error_code := 'SQLITE_CONSTRAINT';
+            v_result.message := 'Constraint violation: foreign key constraint failed';
+            
+            INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+            VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                    jsonb_build_object('reason', 'foreign_key_violation', 'sqlstate', SQLSTATE));
+            
+            RETURN v_result;
+
+        WHEN OTHERS THEN
+            v_result.error_code := 'SQLITE_ERROR';
+            v_result.message := 'Unexpected error: ' || SQLERRM;
+            
+            INSERT INTO order_audit_log (request_id, customer_id, product_id, action, status, error_code, message, details)
+            VALUES (p_request_id, p_customer_id, p_product_id, 'PROCESS_ORDER', 'FAILED', v_result.error_code, v_result.message,
+                    jsonb_build_object('reason', 'unexpected_error', 'sqlstate', SQLSTATE, 'sqlerrm', SQLERRM));
+            
+            RETURN v_result;
+    END;
+
+END;
+$$;
+
+-- Grant execute permission (adjust role as needed)
+-- GRANT EXECUTE ON FUNCTION process_customer_order TO your_app_role;
diff --git a/repository_after/schema.sql b/repository_after/schema.sql
new file mode 100644
index 0000000..ba54c8a
--- /dev/null
+++ b/repository_after/schema.sql
@@ -0,0 +1,68 @@
+-- Schema for e-commerce order processing system
+-- Tables required by the process_customer_order function
+
+-- Customers table
+CREATE TABLE IF NOT EXISTS customers (
+    customer_id SERIAL PRIMARY KEY,
+    name VARCHAR(255) NOT NULL,
+    email VARCHAR(255) UNIQUE NOT NULL,
+    is_active BOOLEAN NOT NULL DEFAULT TRUE,
+    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
+);
+
+-- Products table
+CREATE TABLE IF NOT EXISTS products (
+    product_id SERIAL PRIMARY KEY,
+    name VARCHAR(255) NOT NULL,
+    description TEXT,
+    unit_price NUMERIC(12, 2) NOT NULL CHECK (unit_price >= 0),
+    is_available BOOLEAN NOT NULL DEFAULT TRUE,
+    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
+);
+
+-- Inventory table
+CREATE TABLE IF NOT EXISTS inventory (
+    inventory_id SERIAL PRIMARY KEY,
+    product_id INTEGER NOT NULL REFERENCES products(product_id),
+    quantity INTEGER NOT NULL DEFAULT 0 CHECK (quantity >= 0),
+    last_updated TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
+    UNIQUE(product_id)
+);
+
+-- Orders table
+CREATE TABLE IF NOT EXISTS orders (
+    order_id SERIAL PRIMARY KEY,
+    customer_id INTEGER NOT NULL REFERENCES customers(customer_id),
+    product_id INTEGER NOT NULL REFERENCES products(product_id),
+    quantity INTEGER NOT NULL CHECK (quantity > 0),
+    unit_price NUMERIC(12, 2) NOT NULL,
+    total_price NUMERIC(12, 2) NOT NULL,
+    status VARCHAR(50) NOT NULL DEFAULT 'PENDING',
+    request_id UUID NOT NULL UNIQUE,
+    order_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
+    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
+);
+
+-- Order audit log table
+CREATE TABLE IF NOT EXISTS order_audit_log (
+    log_id SERIAL PRIMARY KEY,
+    order_id INTEGER REFERENCES orders(order_id),
+    request_id UUID NOT NULL,
+    customer_id INTEGER,
+    product_id INTEGER,
+    action VARCHAR(100) NOT NULL,
+    status VARCHAR(50) NOT NULL,
+    error_code VARCHAR(50),
+    message TEXT,
+    details JSONB,
+    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
+);
+
+-- Indexes for performance
+CREATE INDEX IF NOT EXISTS idx_orders_customer_id ON orders(customer_id);
+CREATE INDEX IF NOT EXISTS idx_orders_product_id ON orders(product_id);
+CREATE INDEX IF NOT EXISTS idx_orders_request_id ON orders(request_id);
+CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
+CREATE INDEX IF NOT EXISTS idx_inventory_product_id ON inventory(product_id);
+CREATE INDEX IF NOT EXISTS idx_audit_log_request_id ON order_audit_log(request_id);
+CREATE INDEX IF NOT EXISTS idx_audit_log_order_id ON order_audit_log(order_id);
