diff --git a/repository_after/index.html b/repository_after/index.html
new file mode 100644
index 0000000..60b3ec0
--- /dev/null
+++ b/repository_after/index.html
@@ -0,0 +1,243 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>RLE Telemetry Pipeline</title>
+    <style>
+        body {
+            font-family: Arial, sans-serif;
+            max-width: 800px;
+            margin: 0 auto;
+            padding: 20px;
+        }
+        .status {
+            margin: 10px 0;
+            padding: 10px;
+            border-radius: 4px;
+        }
+        .success { background-color: #d4edda; color: #155724; }
+        .error { background-color: #f8d7da; color: #721c24; }
+        .info { background-color: #d1ecf1; color: #0c5460; }
+        button {
+            background-color: #007bff;
+            color: white;
+            border: none;
+            padding: 10px 20px;
+            border-radius: 4px;
+            cursor: pointer;
+            margin: 5px;
+        }
+        button:hover { background-color: #0056b3; }
+        button:disabled { background-color: #6c757d; cursor: not-allowed; }
+        .matrix-info {
+            background-color: #f8f9fa;
+            padding: 10px;
+            border-radius: 4px;
+            margin: 10px 0;
+        }
+    </style>
+</head>
+<body>
+    <h1>Custom RLE Compressed Telemetry Pipeline</h1>
+    
+    <div class="matrix-info">
+        <h3>Matrix Information</h3>
+        <p>Size: 100x100 (10,000 elements)</p>
+        <p>Value Range: 0-255 (unsigned 8-bit integers)</p>
+        <p>Compression: Custom Run-Length Encoding (RLE)</p>
+    </div>
+
+    <button id="generateBtn" onclick="generateAndSend()">Generate Matrix and Send</button>
+    <button id="testBtn" onclick="testCompression()">Test RLE Algorithm</button>
+    
+    <div id="status"></div>
+
+    <script>
+        function compressRLE(data) {
+            if (data.length === 0) return new Uint8Array();
+            
+            // Validate input: ensure all values are 0-255
+            for (let i = 0; i < data.length; i++) {
+                if (data[i] < 0 || data[i] > 255) {
+                    throw new Error(`Invalid sensor value at position ${i}: ${data[i]} (must be 0-255)`);
+                }
+            }
+            
+            const compressed = [];
+            let current = data[0];
+            let count = 1;
+            
+            for (let i = 1; i < data.length; i++) {
+                if (data[i] === current && count < 255) {
+                    count++;
+                } else {
+                    // Validate count before adding
+                    if (count > 255) {
+                        throw new Error(`RLE count exceeds 255: ${count}`);
+                    }
+                    compressed.push(count, current);
+                    current = data[i];
+                    count = 1;
+                }
+            }
+            
+            // Add the last run with validation
+            if (count > 255) {
+                throw new Error(`RLE count exceeds 255: ${count}`);
+            }
+            compressed.push(count, current);
+            
+            return new Uint8Array(compressed);
+        }
+
+        function decompressRLE(compressedData) {
+            if (compressedData.length % 2 !== 0) {
+                throw new Error("Invalid RLE stream: odd number of bytes");
+            }
+            
+            const decompressed = [];
+            
+            for (let i = 0; i < compressedData.length; i += 2) {
+                const count = compressedData[i];
+                const value = compressedData[i + 1];
+                
+                // Validation: count must be 1-255, value must be 0-255
+                if (count > 255) {
+                    throw new Error(`RLE count exceeds 255: ${count}`);
+                }
+                if (value > 255) {
+                    throw new Error(`RLE value exceeds 255: ${value}`);
+                }
+                
+                if (count === 0) {
+                    continue;
+                }
+                
+                for (let j = 0; j < count; j++) {
+                    decompressed.push(value);
+                }
+            }
+            
+            return decompressed;
+        }
+
+        function generateMatrix() {
+            const size = 100 * 100;
+            const matrix = new Uint8Array(size);
+            for (let i = 0; i < size; i++) {
+                matrix[i] = Math.floor(Math.random() * 256);
+            }
+            return matrix;
+        }
+
+        async function sendCompressedData(compressedData) {
+            try {
+                const blob = new Blob([compressedData], { type: 'application/octet-stream' });
+                
+                const response = await fetch('/process', {
+                    method: 'POST',
+                    headers: {
+                        'Content-Type': 'application/octet-stream'
+                    },
+                    body: blob
+                });
+
+                if (!response.ok) {
+                    throw new Error(`HTTP error! status: ${response.status}`);
+                }
+
+                const result = await response.json();
+                return result;
+            } catch (error) {
+                console.error('Error sending data:', error);
+                throw error;
+            }
+        }
+
+        function updateStatus(message, type = 'info') {
+            const statusDiv = document.getElementById('status');
+            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
+        }
+
+        async function generateAndSend() {
+            const generateBtn = document.getElementById('generateBtn');
+            generateBtn.disabled = true;
+            
+            try {
+                updateStatus('Generating 100x100 matrix...', 'info');
+                
+                const matrix = generateMatrix();
+                updateStatus(`Matrix generated. Original size: ${matrix.length} bytes`, 'info');
+                
+                const compressed = compressRLE(matrix);
+                const compressionRatio = ((matrix.length - compressed.length) / matrix.length * 100).toFixed(2);
+                updateStatus(`RLE compression complete. Compressed size: ${compressed.length} bytes (${compressionRatio}% reduction)`, 'info');
+                
+                updateStatus('Sending compressed data to server...', 'info');
+                const result = await sendCompressedData(compressed);
+                
+                updateStatus(`Success! Server calculated average: ${result.average}`, 'success');
+            } catch (error) {
+                updateStatus(`Error: ${error.message}`, 'error');
+            } finally {
+                generateBtn.disabled = false;
+            }
+        }
+
+        // Test RLE compression/decompression
+        async function testCompression() {
+            const testBtn = document.getElementById('testBtn');
+            testBtn.disabled = true;
+            
+            try {
+                updateStatus('Testing RLE algorithm...', 'info');
+                
+                // Create test data with known patterns including edge cases
+                const testData = new Uint8Array([
+                    5, 5, 5, 5, 5, 5,  // 6 repetitions of 5
+                    10,                // 1 repetition of 10
+                    20, 20, 20,       // 3 repetitions of 20
+                    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, // 10 repetitions of 255
+                    0                  // 1 repetition of 0
+                ]);
+                
+                const compressed = compressRLE(testData);
+                const decompressed = decompressRLE(compressed);
+                
+                // Verify roundtrip
+                let roundtripSuccess = true;
+                if (testData.length !== decompressed.length) {
+                    roundtripSuccess = false;
+                } else {
+                    for (let i = 0; i < testData.length; i++) {
+                        if (testData[i] !== decompressed[i]) {
+                            roundtripSuccess = false;
+                            break;
+                        }
+                    }
+                }
+                
+                if (!roundtripSuccess) {
+                    throw new Error('RLE roundtrip test failed');
+                }
+                
+                updateStatus(`Test data: [${testData.join(', ')}]`, 'info');
+                updateStatus(`Compressed: [${compressed.join(', ')}]`, 'info');
+                updateStatus(`Decompressed: [${decompressed.join(', ')}]`, 'info');
+                updateStatus('RLE algorithm test completed successfully!', 'success');
+                
+                // Test server-side RLE
+                const response = await fetch('/test-rle');
+                const serverResult = await response.json();
+                updateStatus(`Server test - Average: ${serverResult.average}, Compression: ${serverResult.compression_ratio}%`, 'success');
+                
+            } catch (error) {
+                updateStatus(`Test error: ${error.message}`, 'error');
+            } finally {
+                testBtn.disabled = false;
+            }
+        }
+    </script>
+</body>
+</html>
diff --git a/repository_after/server.py b/repository_after/server.py
new file mode 100644
index 0000000..3d13230
--- /dev/null
+++ b/repository_after/server.py
@@ -0,0 +1,181 @@
+from aiohttp import web
+import asyncio
+import json
+import os
+
+class RLECompressor:
+    @staticmethod
+    def compress_rle(data):
+        """
+        Compress data using custom RLE algorithm.
+        Format: [Count, Value] where Count is 1-255, Value is 0-255
+        """
+        if len(data) == 0:
+            return bytes()
+        
+        # Validate input data
+        for i, val in enumerate(data):
+            if not isinstance(val, int):
+                raise TypeError(f"Value at position {i} is not an integer: {val}")
+            if val < 0 or val > 255:
+                raise ValueError(f"Value at position {i} out of range (0-255): {val}")
+        
+        compressed = []
+        current = data[0]
+        count = 1
+        
+        for i in range(1, len(data)):
+            if data[i] == current and count < 255:
+                count += 1
+            else:
+                compressed.extend([count, current])
+                current = data[i]
+                count = 1
+        
+        # Add the last run
+        compressed.extend([count, current])
+        
+        return bytes(compressed)
+
+class RLEDecompressor:
+    @staticmethod
+    def decompress_rle(compressed_data):
+        if len(compressed_data) % 2 != 0:
+            raise ValueError("Invalid RLE stream: odd number of bytes")
+        
+        decompressed = []
+        i = 0
+        
+        while i < len(compressed_data):
+            count = compressed_data[i]
+            value = compressed_data[i + 1]
+            
+            # Explicit validation: count must be 1-255 (value already validated by bytes type)
+            if count > 255:
+                raise ValueError(f"RLE count exceeds 255: {count}")
+            
+            if count == 0:
+                # DESIGN DECISION: Zero-count pairs are ignored for robustness.
+                # While technically invalid per strict RLE spec (count should be 1-255),
+                # silently ignoring them prevents crashes from corrupted telemetry
+                # and provides graceful degradation. This is documented in tests.
+                i += 2
+                continue
+            
+            decompressed.extend([value] * count)
+            i += 2
+        
+        return decompressed
+
+class TelemetryProcessor:
+    def __init__(self):
+        self.decompressor = RLEDecompressor()
+        self.compressor = RLECompressor()
+    
+    def generate_test_matrix(self, size=10000):
+        """Generate test matrix of random integers 0-255"""
+        import random
+        return [random.randint(0, 255) for _ in range(size)]
+    
+    async def process_telemetry(self, compressed_data):
+        try:
+            # Validate input is bytes
+            if not isinstance(compressed_data, bytes):
+                raise ValueError("Input must be bytes")
+            
+            decompressed_data = self.decompressor.decompress_rle(compressed_data)
+            
+            if len(decompressed_data) != 10000:
+                raise ValueError(f"Expected 10,000 elements, got {len(decompressed_data)}")
+            
+            # Additional validation: ensure all values are 0-255
+            for i, val in enumerate(decompressed_data):
+                if val < 0 or val > 255:
+                    raise ValueError(f"Invalid sensor value at position {i}: {val} (must be 0-255)")
+            
+            average = sum(decompressed_data) / len(decompressed_data)
+            
+            return {"average": average}
+        except web.HTTPException:
+            raise
+        except Exception as e:
+            raise web.HTTPBadRequest(text=str(e))
+
+async def handle_test_rle(request):
+    """Test endpoint to verify RLE compression/decompression roundtrip"""
+    try:
+        processor = TelemetryProcessor()
+        
+        # Generate test matrix
+        original_data = processor.generate_test_matrix(10000)
+        
+        # Compress it
+        compressed_data = processor.compressor.compress_rle(original_data)
+        
+        # Decompress it
+        decompressed_data = processor.decompressor.decompress_rle(compressed_data)
+        
+        # Verify roundtrip
+        if original_data != decompressed_data:
+            raise web.HTTPInternalServerError(text="RLE roundtrip failed")
+        
+        # Calculate average
+        average = sum(decompressed_data) / len(decompressed_data)
+        
+        return web.json_response({
+            "average": average,
+            "original_size": len(original_data),
+            "compressed_size": len(compressed_data),
+            "compression_ratio": round((1 - len(compressed_data) / len(original_data)) * 100, 2)
+        })
+    
+    except Exception as e:
+        raise web.HTTPInternalServerError(text=str(e))
+
+async def handle_process(request):
+    try:
+        content = await request.read()
+        
+        if not content:
+            raise web.HTTPBadRequest(text="Empty request body")
+        
+        processor = TelemetryProcessor()
+        result = await processor.process_telemetry(content)
+        
+        return web.json_response(result)
+    
+    except web.HTTPBadRequest:
+        raise
+    except Exception as e:
+        raise web.HTTPInternalServerError(text=f"Internal server error: {str(e)}")
+
+async def handle_index(request):
+    html_path = os.path.join(os.path.dirname(__file__), 'index.html')
+    with open(html_path, 'r') as f:
+        return web.Response(text=f.read(), content_type='text/html')
+
+def create_app():
+    app = web.Application()
+    app.router.add_get('/', handle_index)
+    app.router.add_post('/process', handle_process)
+    app.router.add_get('/test-rle', handle_test_rle)
+    return app
+
+async def main():
+    app = create_app()
+    runner = web.AppRunner(app)
+    await runner.setup()
+    
+    site = web.TCPSite(runner, '0.0.0.0', 8080)
+    await site.start()
+    
+    print("Server running on http://0.0.0.0:8080")
+    try:
+        await asyncio.Future()
+    except KeyboardInterrupt:
+        pass
+    finally:
+        await runner.cleanup()
+
+if __name__ == '__main__':
+    asyncio.run(main())
