diff --git a/repository_after/max_non_decreasing_array_length.py b/repository_after/max_non_decreasing_array_length.py
new file mode 100644
index 0000000..6d44a04
--- /dev/null
+++ b/repository_after/max_non_decreasing_array_length.py
@@ -0,0 +1,58 @@
+from typing import List
+from bisect import bisect_right
+
+def maxNonDecreasingLength(nums: List[int]) -> int:
+    """
+    Return the maximum length of a non-decreasing array achievable by merging
+    contiguous subarrays (replace them with their sum).
+
+    Approach (brief):
+    - Build prefix sums to get any subarray sum in O(1).
+    - Scan left-to-right maintaining a list of candidate previous split points.
+    - For each position i pick the best previous split that allows a valid
+      next value, update the DP length, then add a new candidate.
+
+    Complexity:
+    - Time: O(n log n) because of binary searches on the candidate list.
+    - Space: O(n).
+    """
+
+    n = len(nums)
+    if n == 0:
+        return 0
+
+    # Prefix sums: P[i] = sum(nums[0..i-1])
+    P = [0] * (n + 1)
+    for i in range(n):
+        P[i+1] = P[i] + nums[i]
+
+    # dp[i] = max length for prefix of length i
+    dp = [0] * (n + 1)
+
+    # candidates: list of (metric, index), kept increasing by metric
+    # Start with a virtual index 0 and metric 0
+    candidates = [(0, 0)]
+
+    for i in range(1, n + 1):
+        curr_prefix_sum = P[i]
+
+        # Find rightmost candidate with metric <= curr_prefix_sum
+        search_idx = bisect_right(candidates, (curr_prefix_sum, float('inf'))) - 1
+        best_metric, best_prev_index = candidates[search_idx]
+
+        # Use that candidate to extend the sequence by one segment
+        dp[i] = dp[best_prev_index] + 1
+
+        # Value of the segment we just created (sum from best_prev_index to i-1)
+        current_segment_val = curr_prefix_sum - P[best_prev_index]
+
+        # Metric for i used by future positions
+        next_metric = curr_prefix_sum + current_segment_val
+
+        # Keep candidates strictly increasing by metric: remove worse ones
+        while candidates and candidates[-1][0] >= next_metric:
+            candidates.pop()
+
+        candidates.append((next_metric, i))
+
+    return dp[n]
