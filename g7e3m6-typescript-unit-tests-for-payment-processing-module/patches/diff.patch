diff --git a/repository_after/src/payment-service.test.ts b/repository_after/src/payment-service.test.ts
new file mode 100644
index 000000000..71860984a
--- /dev/null
+++ b/repository_after/src/payment-service.test.ts
@@ -0,0 +1,293 @@
+import Stripe from 'stripe';
+import { PaymentService, ChargeRequest } from '../../repository_before/src/payment-service';
+import { PayPalClient } from '../../repository_before/src/paypal-client';
+
+jest.mock('stripe', () => {
+  const paymentIntents = {
+    create: jest.fn(),
+    retrieve: jest.fn(),
+  };
+
+  return jest.fn().mockImplementation(() => ({
+    paymentIntents,
+    webhooks: {
+      constructEvent: jest.fn(),
+    },
+  }));
+});
+
+// Req 2,6: Mock PayPal API via PayPalClient
+jest.mock('../../repository_before/src/paypal-client');
+
+const MockedStripe = Stripe as unknown as jest.Mock<typeof Stripe, any[]>;
+const MockedPayPalClient = PayPalClient as jest.MockedClass<typeof PayPalClient>;
+
+// Req 24: Tests are designed to run quickly under normal Jest execution.
+// Req 25: Tests avoid randomness and external timing, making the suite deterministic and non-flaky.
+
+describe('PaymentService', () => {
+  const stripeKey = 'sk_test';
+  const paypalConfig = { clientId: 'id', secret: 'secret' };
+
+  const baseRequest: ChargeRequest = {
+    amount: 100,
+    currency: 'USD',
+    customerId: 'cus_123',
+    paymentMethodId: 'pm_123',
+    idempotencyKey: 'key-1',
+    metadata: { orderId: 'order-1' },
+  };
+
+  let paymentService: PaymentService;
+  let stripeInstance: any;
+  let paypalInstance: jest.Mocked<PayPalClient>;
+
+  beforeEach(() => {
+    MockedStripe.mockClear();
+
+    stripeInstance = {
+      paymentIntents: {
+        create: jest.fn(),
+        retrieve: jest.fn(),
+      },
+    };
+
+    MockedStripe.mockImplementation(() => stripeInstance as any);
+
+    paypalInstance = {
+      getAccessToken: jest.fn(),
+      createOrder: jest.fn(),
+      captureOrder: jest.fn(),
+    } as any;
+
+    MockedPayPalClient.mockImplementation(() => paypalInstance);
+
+    paymentService = new PaymentService(stripeKey, paypalConfig);
+  });
+
+  // Req 3,23: Success scenario for charge
+  it('should create a successful Stripe charge when request is valid', async () => {
+    stripeInstance.paymentIntents.create.mockResolvedValue({
+      id: 'pi_123',
+      status: 'succeeded',
+    });
+
+    const result = await paymentService.charge(baseRequest);
+
+    expect(stripeInstance.paymentIntents.create).toHaveBeenCalledWith(
+      {
+        amount: 10000,
+        currency: 'usd',
+        customer: baseRequest.customerId,
+        payment_method: baseRequest.paymentMethodId,
+        confirm: true,
+        metadata: baseRequest.metadata,
+      },
+      {
+        idempotencyKey: baseRequest.idempotencyKey,
+      }
+    );
+    expect(result).toEqual({
+      id: 'pi_123',
+      status: 'succeeded',
+      amount: baseRequest.amount,
+      currency: baseRequest.currency,
+      gateway: 'stripe',
+    });
+  });
+
+  // Req 4: Amount validation errors (<=0)
+  it('should throw error when amount is less than or equal to zero', async () => {
+    await expect(
+      paymentService.charge({
+        ...baseRequest,
+        amount: 0,
+      })
+    ).rejects.toThrow('Amount must be greater than zero');
+  });
+
+  // Req 4: Amount validation errors (exceeds maximum)
+  it('should throw error when amount exceeds maximum allowed', async () => {
+    await expect(
+      paymentService.charge({
+        ...baseRequest,
+        amount: 1000000,
+      })
+    ).rejects.toThrow('Amount exceeds maximum allowed');
+  });
+
+  // Req 7: Idempotency key behavior for duplicate charge prevention
+  it('should throw error when duplicate idempotency key is used', async () => {
+    stripeInstance.paymentIntents.create.mockResolvedValue({
+      id: 'pi_123',
+      status: 'succeeded',
+    });
+
+    await paymentService.charge(baseRequest);
+
+    await expect(paymentService.charge(baseRequest)).rejects.toThrow('Duplicate transaction detected');
+  });
+
+  // Req 8: Pass idempotency key to Stripe API
+  it('should pass idempotency key to Stripe paymentIntents.create', async () => {
+    stripeInstance.paymentIntents.create.mockResolvedValue({
+      id: 'pi_123',
+      status: 'pending',
+    });
+
+    await paymentService.charge(baseRequest);
+
+    expect(stripeInstance.paymentIntents.create).toHaveBeenCalledWith(
+      expect.any(Object),
+      expect.objectContaining({ idempotencyKey: baseRequest.idempotencyKey })
+    );
+  });
+
+  // Req 5: StripeCardError handling (declined card)
+  it('should return failed result when StripeCardError occurs', async () => {
+    const cardError = {
+      type: 'StripeCardError',
+      code: 'card_declined',
+      message: 'Your card was declined.',
+    };
+
+    stripeInstance.paymentIntents.create.mockRejectedValue(cardError);
+
+    const result = await paymentService.charge(baseRequest);
+
+    expect(result).toEqual({
+      id: '',
+      status: 'failed',
+      amount: baseRequest.amount,
+      currency: baseRequest.currency,
+      gateway: 'stripe',
+      errorCode: 'card_declined',
+      errorMessage: 'Your card was declined.',
+    });
+  });
+
+  // Req 5: StripeInvalidRequestError handling (propagate error)
+  it('should throw non-card Stripe errors such as invalid request', async () => {
+    const invalidError = {
+      type: 'StripeInvalidRequestError',
+      message: 'Invalid parameters',
+    };
+
+    stripeInstance.paymentIntents.create.mockRejectedValue(invalidError);
+
+    await expect(paymentService.charge(baseRequest)).rejects.toEqual(invalidError);
+  });
+
+  // Req 4: Missing required fields — Stripe rejects invalid/incomplete params; error is propagated
+  it('should propagate Stripe error when request has invalid or missing required fields', async () => {
+    const missingFieldsError = {
+      type: 'StripeInvalidRequestError',
+      message: 'No such customer: \'invalid_customer\'',
+    };
+
+    stripeInstance.paymentIntents.create.mockRejectedValue(missingFieldsError);
+
+    await expect(
+      paymentService.charge({
+        ...baseRequest,
+        customerId: 'invalid_customer',
+      })
+    ).rejects.toEqual(missingFieldsError);
+
+    expect(stripeInstance.paymentIntents.create).toHaveBeenCalledWith(
+      expect.objectContaining({ customer: 'invalid_customer' }),
+      expect.any(Object)
+    );
+  });
+
+  // Req 5: Network timeout during charge (generic error)
+  it('should throw when network timeout occurs during charge', async () => {
+    const timeoutError = new Error('Request timed out');
+    stripeInstance.paymentIntents.create.mockRejectedValue(timeoutError);
+
+    await expect(paymentService.charge(baseRequest)).rejects.toThrow('Request timed out');
+  });
+
+  // Req 23: Currency conversion with rounding
+  it('should convert currency with correct rounding', () => {
+    const amount = paymentService.convertCurrency(10, 'USD', 'EUR', 0.8456);
+    expect(amount).toBeCloseTo(8.46, 2);
+  });
+
+  // Req 3,6: Successful PayPal charge via PaymentService
+  it('should create a successful PayPal charge when request is valid', async () => {
+    paypalInstance.createOrder.mockResolvedValue({
+      id: 'order_123',
+      status: 'CREATED',
+    } as any);
+
+    paypalInstance.captureOrder.mockResolvedValue({
+      id: 'capture_123',
+      status: 'COMPLETED',
+    } as any);
+
+    const result = await paymentService.chargeWithPayPal(baseRequest);
+
+    expect(paypalInstance.createOrder).toHaveBeenCalledWith({
+      amount: '100.00',
+      currency: 'USD',
+      reference: baseRequest.idempotencyKey,
+    });
+
+    expect(paypalInstance.captureOrder).toHaveBeenCalledWith('order_123');
+
+    expect(result).toEqual({
+      id: 'capture_123',
+      status: 'succeeded',
+      amount: baseRequest.amount,
+      currency: baseRequest.currency,
+      gateway: 'paypal',
+    });
+  });
+
+  // Req 4: Amount validation for PayPal charge
+  it('should throw error when PayPal charge amount is not greater than zero', async () => {
+    await expect(
+      paymentService.chargeWithPayPal({
+        ...baseRequest,
+        amount: 0,
+      })
+    ).rejects.toThrow('Amount must be greater than zero');
+  });
+
+  // Req 6: PayPal error handling (createOrder failure)
+  it('should return failed result when PayPal createOrder fails', async () => {
+    paypalInstance.createOrder.mockRejectedValue({
+      code: 'ORDER_ERROR',
+      message: 'Order creation failed',
+    });
+
+    const result = await paymentService.chargeWithPayPal(baseRequest);
+
+    expect(result.status).toBe('failed');
+    expect(result.gateway).toBe('paypal');
+    expect(result.errorCode).toBe('ORDER_ERROR');
+    expect(result.errorMessage).toBe('Order creation failed');
+  });
+
+  // Req 6: PayPal error handling (captureOrder failure)
+  it('should return failed result when PayPal captureOrder fails', async () => {
+    paypalInstance.createOrder.mockResolvedValue({
+      id: 'order_123',
+      status: 'CREATED',
+    } as any);
+
+    paypalInstance.captureOrder.mockRejectedValue({
+      code: 'CAPTURE_ERROR',
+      message: 'Capture failed',
+    });
+
+    const result = await paymentService.chargeWithPayPal(baseRequest);
+
+    expect(result.status).toBe('failed');
+    expect(result.gateway).toBe('paypal');
+    expect(result.errorCode).toBe('CAPTURE_ERROR');
+    expect(result.errorMessage).toBe('Capture failed');
+  });
+});
+
diff --git a/repository_before/src/payment-service.ts b/repository_before/src/payment-service.ts
deleted file mode 100644
index ea075454d..000000000
--- a/repository_before/src/payment-service.ts
+++ /dev/null
@@ -1,129 +0,0 @@
-import Stripe from 'stripe';
-import { PayPalClient } from './paypal-client';
-
-export interface ChargeRequest {
-  amount: number;
-  currency: string;
-  customerId: string;
-  paymentMethodId: string;
-  idempotencyKey?: string;
-  metadata?: Record<string, string>;
-}
-
-export interface ChargeResult {
-  id: string;
-  status: 'succeeded' | 'pending' | 'failed';
-  amount: number;
-  currency: string;
-  gateway: 'stripe' | 'paypal';
-  errorCode?: string;
-  errorMessage?: string;
-}
-
-export class PaymentService {
-  private stripe: Stripe;
-  private paypal: PayPalClient;
-  private processedKeys: Set<string> = new Set();
-
-  constructor(stripeKey: string, paypalConfig: { clientId: string; secret: string }) {
-    this.stripe = new Stripe(stripeKey, { apiVersion: '2023-10-16' });
-    this.paypal = new PayPalClient(paypalConfig);
-  }
-
-  async charge(request: ChargeRequest): Promise<ChargeResult> {
-    if (request.amount <= 0) {
-      throw new Error('Amount must be greater than zero');
-    }
-
-    if (request.amount > 999999.99) {
-      throw new Error('Amount exceeds maximum allowed');
-    }
-
-    if (request.idempotencyKey && this.processedKeys.has(request.idempotencyKey)) {
-      throw new Error('Duplicate transaction detected');
-    }
-
-    const amountInCents = Math.round(request.amount * 100);
-
-    try {
-      const paymentIntent = await this.stripe.paymentIntents.create(
-        {
-          amount: amountInCents,
-          currency: request.currency.toLowerCase(),
-          customer: request.customerId,
-          payment_method: request.paymentMethodId,
-          confirm: true,
-          metadata: request.metadata,
-        },
-        {
-          idempotencyKey: request.idempotencyKey,
-        }
-      );
-
-      if (request.idempotencyKey) {
-        this.processedKeys.add(request.idempotencyKey);
-      }
-
-      return {
-        id: paymentIntent.id,
-        status: paymentIntent.status === 'succeeded' ? 'succeeded' : 'pending',
-        amount: request.amount,
-        currency: request.currency,
-        gateway: 'stripe',
-      };
-    } catch (error: any) {
-      if (error.type === 'StripeCardError') {
-        return {
-          id: '',
-          status: 'failed',
-          amount: request.amount,
-          currency: request.currency,
-          gateway: 'stripe',
-          errorCode: error.code,
-          errorMessage: error.message,
-        };
-      }
-      throw error;
-    }
-  }
-
-  async chargeWithPayPal(request: ChargeRequest): Promise<ChargeResult> {
-    if (request.amount <= 0) {
-      throw new Error('Amount must be greater than zero');
-    }
-
-    try {
-      const order = await this.paypal.createOrder({
-        amount: request.amount.toFixed(2),
-        currency: request.currency,
-        reference: request.idempotencyKey,
-      });
-
-      const capture = await this.paypal.captureOrder(order.id);
-
-      return {
-        id: capture.id,
-        status: capture.status === 'COMPLETED' ? 'succeeded' : 'pending',
-        amount: request.amount,
-        currency: request.currency,
-        gateway: 'paypal',
-      };
-    } catch (error: any) {
-      return {
-        id: '',
-        status: 'failed',
-        amount: request.amount,
-        currency: request.currency,
-        gateway: 'paypal',
-        errorCode: error.code,
-        errorMessage: error.message,
-      };
-    }
-  }
-
-  convertCurrency(amount: number, fromCurrency: string, toCurrency: string, rate: number): number {
-    const converted = amount * rate;
-    return Math.round(converted * 100) / 100;
-  }
-}
-
diff --git a/repository_after/src/paypal-client.test.ts b/repository_after/src/paypal-client.test.ts
new file mode 100644
index 000000000..6ded98678
--- /dev/null
+++ b/repository_after/src/paypal-client.test.ts
@@ -0,0 +1,153 @@
+import { PayPalClient } from '../../repository_before/src/paypal-client';
+
+declare const global: any;
+
+describe('PayPalClient', () => {
+  const config = { clientId: 'client', secret: 'secret' };
+  let paypalClient: PayPalClient;
+
+  beforeEach(() => {
+    paypalClient = new PayPalClient(config);
+    global.fetch = jest.fn();
+  });
+
+  // Req 19: Restore Date.now after tests that mock it so timestamp-dependent tests do not leak
+  afterEach(() => {
+    jest.restoreAllMocks();
+  });
+
+  const mockFetchResponse = (ok: boolean, jsonData: any) => {
+    (global.fetch as jest.Mock).mockResolvedValue({
+      ok,
+      json: jest.fn().mockResolvedValue(jsonData),
+    });
+  };
+
+  // Req 3,6: Successful token acquisition
+  it('should obtain access token successfully when credentials are valid', async () => {
+    jest.spyOn(Date, 'now').mockReturnValue(1000);
+
+    mockFetchResponse(true, { access_token: 'token_123', expires_in: 3600 });
+
+    const token = await paypalClient.getAccessToken();
+
+    expect(global.fetch).toHaveBeenCalledWith(
+      'https://api-m.sandbox.paypal.com/v1/oauth2/token',
+      expect.objectContaining({
+        method: 'POST',
+        headers: expect.objectContaining({
+          Authorization: expect.stringContaining('Basic '),
+        }),
+        body: 'grant_type=client_credentials',
+      })
+    );
+
+    expect(token).toBe('token_123');
+  });
+
+  // Req 3,6,23: Subsequent calls to getAccessToken should reuse cached token without new HTTP request
+  it('should reuse cached access token when it is still valid', async () => {
+    jest.spyOn(Date, 'now').mockReturnValue(1000);
+
+    mockFetchResponse(true, { access_token: 'token_123', expires_in: 3600 });
+
+    const firstToken = await paypalClient.getAccessToken();
+    const fetchCallCountAfterFirst = (global.fetch as jest.Mock).mock.calls.length;
+
+    const secondToken = await paypalClient.getAccessToken();
+    const fetchCallCountAfterSecond = (global.fetch as jest.Mock).mock.calls.length;
+
+    expect(firstToken).toBe('token_123');
+    expect(secondToken).toBe('token_123');
+    expect(fetchCallCountAfterSecond).toBe(fetchCallCountAfterFirst);
+  });
+
+  // Req 6: Authentication failure (invalid credentials)
+  it('should throw when token request fails due to invalid credentials', async () => {
+    mockFetchResponse(false, { message: 'Invalid client credentials' });
+
+    await expect(paypalClient.getAccessToken()).rejects.toThrow('Failed to get PayPal access token');
+  });
+
+  // Req 3,6: Successful order creation
+  it('should create PayPal order when request is valid', async () => {
+    mockFetchResponse(true, { access_token: 'token_123', expires_in: 3600 });
+
+    (global.fetch as jest.Mock).mockResolvedValueOnce({
+      ok: true,
+      json: jest.fn().mockResolvedValue({ access_token: 'token_123', expires_in: 3600 }),
+    });
+
+    (global.fetch as jest.Mock).mockResolvedValueOnce({
+      ok: true,
+      json: jest.fn().mockResolvedValue({ id: 'order_123', status: 'CREATED' }),
+    });
+
+    const order = await paypalClient.createOrder({
+      amount: '10.00',
+      currency: 'USD',
+      reference: 'order_ref',
+    });
+
+    expect(order).toEqual({ id: 'order_123', status: 'CREATED' });
+  });
+
+  // Req 6: Order creation failure
+  it('should throw when createOrder response is not ok', async () => {
+    (global.fetch as jest.Mock).mockResolvedValueOnce({
+      ok: true,
+      json: jest.fn().mockResolvedValue({ access_token: 'token_123', expires_in: 3600 }),
+    });
+
+    (global.fetch as jest.Mock).mockResolvedValueOnce({
+      ok: false,
+      json: jest.fn().mockResolvedValue({ message: 'Order error' }),
+    });
+
+    await expect(
+      paypalClient.createOrder({
+        amount: '10.00',
+        currency: 'USD',
+      })
+    ).rejects.toThrow('Order error');
+  });
+
+  // Req 3,6: Successful capture
+  it('should capture PayPal order successfully', async () => {
+    (global.fetch as jest.Mock).mockResolvedValueOnce({
+      ok: true,
+      json: jest.fn().mockResolvedValue({ access_token: 'token_123', expires_in: 3600 }),
+    });
+
+    (global.fetch as jest.Mock).mockResolvedValueOnce({
+      ok: true,
+      json: jest.fn().mockResolvedValue({ id: 'cap_123', status: 'COMPLETED' }),
+    });
+
+    const capture = await paypalClient.captureOrder('order_123');
+    expect(capture).toEqual({ id: 'cap_123', status: 'COMPLETED' });
+  });
+
+  // Req 6: Capture failure
+  it('should throw when captureOrder response is not ok', async () => {
+    (global.fetch as jest.Mock).mockResolvedValueOnce({
+      ok: true,
+      json: jest.fn().mockResolvedValue({ access_token: 'token_123', expires_in: 3600 }),
+    });
+
+    (global.fetch as jest.Mock).mockResolvedValueOnce({
+      ok: false,
+      json: jest.fn().mockResolvedValue({ message: 'Capture error' }),
+    });
+
+    await expect(paypalClient.captureOrder('order_123')).rejects.toThrow('Capture error');
+  });
+
+  // Req 6: Network error — fetch rejects (e.g. connection failure)
+  it('should throw when getAccessToken fails due to network error', async () => {
+    (global.fetch as jest.Mock).mockRejectedValue(new Error('Network request failed'));
+
+    await expect(paypalClient.getAccessToken()).rejects.toThrow('Network request failed');
+  });
+});
+
diff --git a/repository_before/src/paypal-client.ts b/repository_before/src/paypal-client.ts
deleted file mode 100644
index 58aa0e60c..000000000
--- a/repository_before/src/paypal-client.ts
+++ /dev/null
@@ -1,108 +0,0 @@
-export interface PayPalOrderRequest {
-  amount: string;
-  currency: string;
-  reference?: string;
-}
-
-export interface PayPalOrder {
-  id: string;
-  status: string;
-}
-
-export interface PayPalCapture {
-  id: string;
-  status: 'COMPLETED' | 'PENDING' | 'FAILED';
-}
-
-export class PayPalClient {
-  private clientId: string;
-  private secret: string;
-  private accessToken: string | null = null;
-  private tokenExpiry: number = 0;
-
-  constructor(config: { clientId: string; secret: string }) {
-    this.clientId = config.clientId;
-    this.secret = config.secret;
-  }
-
-  async getAccessToken(): Promise<string> {
-    if (this.accessToken && Date.now() < this.tokenExpiry) {
-      return this.accessToken;
-    }
-
-    const credentials = Buffer.from(`${this.clientId}:${this.secret}`).toString('base64');
-
-    const response = await fetch('https://api-m.sandbox.paypal.com/v1/oauth2/token', {
-      method: 'POST',
-      headers: {
-        'Authorization': `Basic ${credentials}`,
-        'Content-Type': 'application/x-www-form-urlencoded',
-      },
-      body: 'grant_type=client_credentials',
-    });
-
-    if (!response.ok) {
-      throw new Error('Failed to get PayPal access token');
-    }
-
-    const data = await response.json();
-    this.accessToken = data.access_token;
-    this.tokenExpiry = Date.now() + (data.expires_in * 1000) - 60000;
-
-    return this.accessToken;
-  }
-
-  async createOrder(request: PayPalOrderRequest): Promise<PayPalOrder> {
-    const token = await this.getAccessToken();
-
-    const response = await fetch('https://api-m.sandbox.paypal.com/v2/checkout/orders', {
-      method: 'POST',
-      headers: {
-        'Authorization': `Bearer ${token}`,
-        'Content-Type': 'application/json',
-      },
-      body: JSON.stringify({
-        intent: 'CAPTURE',
-        purchase_units: [
-          {
-            amount: {
-              currency_code: request.currency,
-              value: request.amount,
-            },
-            reference_id: request.reference,
-          },
-        ],
-      }),
-    });
-
-    if (!response.ok) {
-      const error = await response.json();
-      throw new Error(error.message || 'Failed to create PayPal order');
-    }
-
-    return response.json();
-  }
-
-  async captureOrder(orderId: string): Promise<PayPalCapture> {
-    const token = await this.getAccessToken();
-
-    const response = await fetch(
-      `https://api-m.sandbox.paypal.com/v2/checkout/orders/${orderId}/capture`,
-      {
-        method: 'POST',
-        headers: {
-          'Authorization': `Bearer ${token}`,
-          'Content-Type': 'application/json',
-        },
-      }
-    );
-
-    if (!response.ok) {
-      const error = await response.json();
-      throw new Error(error.message || 'Failed to capture PayPal order');
-    }
-
-    return response.json();
-  }
-}
-
diff --git a/repository_after/src/refund-service.test.ts b/repository_after/src/refund-service.test.ts
new file mode 100644
index 000000000..260876ad0
--- /dev/null
+++ b/repository_after/src/refund-service.test.ts
@@ -0,0 +1,229 @@
+import Stripe from 'stripe';
+import { RefundService, RefundRequest } from '../../repository_before/src/refund-service';
+
+// Req 1,9,10,11: Mock Stripe refunds.create and refunds.retrieve
+jest.mock('stripe', () => {
+  const refunds = {
+    create: jest.fn(),
+    retrieve: jest.fn(),
+  };
+
+  return jest.fn().mockImplementation(() => ({
+    refunds,
+  }));
+});
+
+const MockedStripe = Stripe as unknown as jest.Mock<typeof Stripe, any[]>;
+
+describe('RefundService', () => {
+  const stripeKey = 'sk_test';
+  let refundService: RefundService;
+  let stripeInstance: any;
+
+  // Refund with different currency than original: not implemented (RefundService uses charge.currency only).
+  const baseCharge = {
+    id: 'ch_123',
+    amount: 100,
+    currency: 'usd',
+    status: 'succeeded' as const,
+    refundedAmount: 0,
+  };
+
+  beforeEach(() => {
+    stripeInstance = {
+      refunds: {
+        create: jest.fn(),
+        retrieve: jest.fn(),
+      },
+    };
+
+    MockedStripe.mockImplementation(() => stripeInstance as any);
+    refundService = new RefundService(stripeKey);
+    refundService.registerCharge({ ...baseCharge });
+  });
+
+  // Req 3,9: Partial refund scenario with remaining balance
+  it('should process a partial refund and update remaining balance when charge is succeeded', async () => {
+    const request: RefundRequest = {
+      chargeId: baseCharge.id,
+      amount: 40,
+      reason: 'requested_by_customer',
+    };
+
+    stripeInstance.refunds.create.mockResolvedValue({
+      id: 're_123',
+      status: 'succeeded',
+    });
+
+    const result = await refundService.refund(request);
+
+    expect(stripeInstance.refunds.create).toHaveBeenCalledWith({
+      payment_intent: baseCharge.id,
+      amount: 4000,
+      reason: 'requested_by_customer',
+    });
+
+    expect(result).toEqual({
+      id: 're_123',
+      status: 'succeeded',
+      amount: 40,
+      currency: 'usd',
+      chargeId: baseCharge.id,
+    });
+
+    // Second partial refund to verify remaining balance
+    stripeInstance.refunds.create.mockResolvedValue({
+      id: 're_124',
+      status: 'succeeded',
+    });
+
+    const secondResult = await refundService.refund({
+      chargeId: baseCharge.id,
+      amount: 60,
+    });
+
+    expect(secondResult.amount).toBe(60);
+  });
+
+  // Req 3,10: Full refund scenario
+  it('should process a full refund when amount is not specified', async () => {
+    stripeInstance.refunds.create.mockResolvedValue({
+      id: 're_full',
+      status: 'succeeded',
+    });
+
+    const result = await refundService.refund({
+      chargeId: baseCharge.id,
+    });
+
+    expect(result.amount).toBe(100);
+    expect(result.status).toBe('succeeded');
+  });
+
+  // Req 11: Refund exceeding available amount should fail
+  it('should throw error when refund amount exceeds available amount', async () => {
+    const request: RefundRequest = {
+      chargeId: baseCharge.id,
+      amount: 150,
+    };
+
+    await expect(refundService.refund(request)).rejects.toThrow(
+      'Refund amount exceeds available amount. Available: 100'
+    );
+  });
+
+  // Req 11: Refund of already fully refunded charge should fail
+  it('should throw error when attempting to refund already fully refunded charge', async () => {
+    stripeInstance.refunds.create.mockResolvedValue({
+      id: 're_1',
+      status: 'succeeded',
+    });
+
+    await refundService.refund({ chargeId: baseCharge.id });
+
+    await expect(
+      refundService.refund({
+        chargeId: baseCharge.id,
+        amount: 1,
+      })
+    ).rejects.toThrow('Refund amount exceeds available amount. Available: 0');
+  });
+
+  // Req 9,11: Refund amount must be greater than zero
+  // Note: implementation treats 0 as "full refund", so we assert on negative values.
+  it('should throw error when refund amount is negative', async () => {
+    await expect(
+      refundService.refund({
+        chargeId: baseCharge.id,
+        amount: -10,
+      })
+    ).rejects.toThrow('Refund amount must be greater than zero');
+  });
+
+  // Req 9,10,11: Cannot refund non-succeeded or missing charges
+  it('should throw error when charge is not found', async () => {
+    await expect(
+      refundService.refund({
+        chargeId: 'unknown',
+      })
+    ).rejects.toThrow('Charge not found');
+  });
+
+  it('should throw error when charge is not succeeded', async () => {
+    const pendingCharge = {
+      ...baseCharge,
+      id: 'ch_pending',
+      status: 'pending' as const,
+    };
+    refundService.registerCharge(pendingCharge as any);
+
+    await expect(
+      refundService.refund({
+        chargeId: 'ch_pending',
+      })
+    ).rejects.toThrow('Cannot refund a charge that has not succeeded');
+  });
+
+  // Req 9,10,11: Stripe refund failure handling
+  it('should return failed result when Stripe refund creation fails', async () => {
+    stripeInstance.refunds.create.mockRejectedValue(new Error('Stripe refund error'));
+
+    const result = await refundService.refund({
+      chargeId: baseCharge.id,
+      amount: 10,
+    });
+
+    expect(result.status).toBe('failed');
+    expect(result.errorMessage).toBe('Stripe refund error');
+  });
+
+  // Req 3: getRefundStatus success and failure
+  it('should return refund status when refund exists', async () => {
+    stripeInstance.refunds.retrieve.mockResolvedValue({
+      id: 're_status',
+      status: 'succeeded',
+      amount: 5000,
+      currency: 'usd',
+      payment_intent: 'ch_status',
+    });
+
+    const result = await refundService.getRefundStatus('re_status');
+
+    expect(result).toEqual({
+      id: 're_status',
+      status: 'succeeded',
+      amount: 50,
+      currency: 'usd',
+      chargeId: 'ch_status',
+    });
+  });
+
+  it('should return null when refund retrieval fails', async () => {
+    stripeInstance.refunds.retrieve.mockRejectedValue(new Error('not found'));
+
+    const result = await refundService.getRefundStatus('unknown');
+    expect(result).toBeNull();
+  });
+
+  // Branch coverage: getRefundStatus when Stripe returns status 'pending'
+  it('should return refund status pending when Stripe refund status is pending', async () => {
+    stripeInstance.refunds.retrieve.mockResolvedValue({
+      id: 're_pending',
+      status: 'pending',
+      amount: 2500,
+      currency: 'usd',
+      payment_intent: 'ch_pending',
+    });
+
+    const result = await refundService.getRefundStatus('re_pending');
+
+    expect(result).toEqual({
+      id: 're_pending',
+      status: 'pending',
+      amount: 25,
+      currency: 'usd',
+      chargeId: 'ch_pending',
+    });
+  });
+});
+
diff --git a/repository_before/src/refund-service.ts b/repository_before/src/refund-service.ts
deleted file mode 100644
index bae493d48..000000000
--- a/repository_before/src/refund-service.ts
+++ /dev/null
@@ -1,105 +0,0 @@
-import Stripe from 'stripe';
-
-export interface RefundRequest {
-  chargeId: string;
-  amount?: number;
-  reason?: 'duplicate' | 'fraudulent' | 'requested_by_customer';
-}
-
-export interface RefundResult {
-  id: string;
-  status: 'succeeded' | 'pending' | 'failed';
-  amount: number;
-  currency: string;
-  chargeId: string;
-  errorMessage?: string;
-}
-
-interface ChargeRecord {
-  id: string;
-  amount: number;
-  currency: string;
-  status: 'succeeded' | 'pending' | 'failed';
-  refundedAmount: number;
-}
-
-export class RefundService {
-  private stripe: Stripe;
-  private chargeRecords: Map<string, ChargeRecord> = new Map();
-
-  constructor(stripeKey: string) {
-    this.stripe = new Stripe(stripeKey, { apiVersion: '2023-10-16' });
-  }
-
-  registerCharge(charge: ChargeRecord): void {
-    this.chargeRecords.set(charge.id, { ...charge, refundedAmount: charge.refundedAmount || 0 });
-  }
-
-  async refund(request: RefundRequest): Promise<RefundResult> {
-    const charge = this.chargeRecords.get(request.chargeId);
-
-    if (!charge) {
-      throw new Error('Charge not found');
-    }
-
-    if (charge.status !== 'succeeded') {
-      throw new Error('Cannot refund a charge that has not succeeded');
-    }
-
-    const refundAmount = request.amount || charge.amount - charge.refundedAmount;
-
-    if (refundAmount <= 0) {
-      throw new Error('Refund amount must be greater than zero');
-    }
-
-    const availableForRefund = charge.amount - charge.refundedAmount;
-
-    if (refundAmount > availableForRefund) {
-      throw new Error(`Refund amount exceeds available amount. Available: ${availableForRefund}`);
-    }
-
-    try {
-      const refund = await this.stripe.refunds.create({
-        payment_intent: request.chargeId,
-        amount: Math.round(refundAmount * 100),
-        reason: request.reason,
-      });
-
-      charge.refundedAmount += refundAmount;
-      this.chargeRecords.set(charge.id, charge);
-
-      return {
-        id: refund.id,
-        status: refund.status === 'succeeded' ? 'succeeded' : 'pending',
-        amount: refundAmount,
-        currency: charge.currency,
-        chargeId: request.chargeId,
-      };
-    } catch (error: any) {
-      return {
-        id: '',
-        status: 'failed',
-        amount: refundAmount,
-        currency: charge.currency,
-        chargeId: request.chargeId,
-        errorMessage: error.message,
-      };
-    }
-  }
-
-  async getRefundStatus(refundId: string): Promise<RefundResult | null> {
-    try {
-      const refund = await this.stripe.refunds.retrieve(refundId);
-      return {
-        id: refund.id,
-        status: refund.status === 'succeeded' ? 'succeeded' : 'pending',
-        amount: refund.amount / 100,
-        currency: refund.currency,
-        chargeId: refund.payment_intent as string,
-      };
-    } catch {
-      return null;
-    }
-  }
-}
-
diff --git a/repository_after/src/subscription-service.test.ts b/repository_after/src/subscription-service.test.ts
new file mode 100644
index 000000000..8ec5ce97c
--- /dev/null
+++ b/repository_after/src/subscription-service.test.ts
@@ -0,0 +1,342 @@
+import Stripe from 'stripe';
+import { SubscriptionService, CreateSubscriptionRequest, PlanChangeRequest } from '../../repository_before/src/subscription-service';
+
+// Req 1,12,13,14,18: Mock Stripe subscriptions, paymentMethods, customers
+jest.mock('stripe', () => {
+  const subscriptions = {
+    create: jest.fn(),
+    retrieve: jest.fn(),
+    update: jest.fn(),
+    cancel: jest.fn(),
+  };
+
+  const paymentMethods = {
+    attach: jest.fn(),
+  };
+
+  const customers = {
+    update: jest.fn(),
+  };
+
+  return jest.fn().mockImplementation(() => ({
+    subscriptions,
+    paymentMethods,
+    customers,
+  }));
+});
+
+const MockedStripe = Stripe as unknown as jest.Mock<typeof Stripe, any[]>;
+
+describe('SubscriptionService', () => {
+  const stripeKey = 'sk_test';
+  let subscriptionService: SubscriptionService;
+  let stripeInstance: any;
+
+  beforeEach(() => {
+    stripeInstance = {
+      subscriptions: {
+        create: jest.fn(),
+        retrieve: jest.fn(),
+        update: jest.fn(),
+        cancel: jest.fn(),
+      },
+      paymentMethods: {
+        attach: jest.fn(),
+      },
+      customers: {
+        update: jest.fn(),
+      },
+    };
+
+    MockedStripe.mockImplementation(() => stripeInstance as any);
+    subscriptionService = new SubscriptionService(stripeKey);
+  });
+
+  const baseCreateRequest: CreateSubscriptionRequest = {
+    customerId: 'cus_123',
+    priceId: 'price_basic',
+    paymentMethodId: 'pm_123',
+  };
+
+  // Req 3,12: Create subscription with valid payment method and trial
+  it('should create subscription with trial period when trialDays provided', async () => {
+    const request: CreateSubscriptionRequest = {
+      ...baseCreateRequest,
+      trialDays: 14,
+    };
+
+    stripeInstance.subscriptions.create.mockResolvedValue({
+      id: 'sub_123',
+      status: 'trialing',
+      current_period_end: 1700000000,
+      cancel_at_period_end: false,
+      items: {
+        data: [
+          {
+            id: 'si_123',
+            price: {
+              id: 'price_basic',
+            },
+          },
+        ],
+      },
+    });
+
+    const result = await subscriptionService.createSubscription(request);
+
+    expect(stripeInstance.paymentMethods.attach).toHaveBeenCalledWith('pm_123', {
+      customer: 'cus_123',
+    });
+
+    expect(stripeInstance.customers.update).toHaveBeenCalledWith('cus_123', {
+      invoice_settings: { default_payment_method: 'pm_123' },
+    });
+
+    expect(stripeInstance.subscriptions.create).toHaveBeenCalledWith(
+      expect.objectContaining({
+        customer: 'cus_123',
+        items: [{ price: 'price_basic' }],
+        trial_period_days: 14,
+      })
+    );
+
+    expect(result.status).toBe('trialing');
+    expect(result.priceId).toBe('price_basic');
+  });
+
+  // Req 3,12: Create subscription without trial
+  it('should create subscription without trial when trialDays not provided', async () => {
+    stripeInstance.subscriptions.create.mockResolvedValue({
+      id: 'sub_no_trial',
+      status: 'active',
+      current_period_end: 1700000000,
+      cancel_at_period_end: false,
+      items: {
+        data: [
+          {
+            id: 'si_123',
+            price: { id: 'price_basic' },
+          },
+        ],
+      },
+    });
+
+    const result = await subscriptionService.createSubscription(baseCreateRequest);
+
+    expect(result.status).toBe('active');
+    expect(result.cancelAtPeriodEnd).toBe(false);
+  });
+
+  // Req 13: Subscription plan change with proration
+  it('should change subscription plan with proration when prorate is true or undefined', async () => {
+    const changeRequest: PlanChangeRequest = {
+      subscriptionId: 'sub_123',
+      newPriceId: 'price_premium',
+      prorate: true,
+    };
+
+    stripeInstance.subscriptions.retrieve.mockResolvedValue({
+      id: 'sub_123',
+      status: 'active',
+      items: {
+        data: [
+          {
+            id: 'si_123',
+            price: { id: 'price_basic' },
+          },
+        ],
+      },
+    });
+
+    stripeInstance.subscriptions.update.mockResolvedValue({
+      id: 'sub_123',
+      status: 'active',
+      current_period_end: 1700000000,
+      cancel_at_period_end: false,
+      items: {
+        data: [
+          {
+            id: 'si_123',
+            price: { id: 'price_premium' },
+          },
+        ],
+      },
+    });
+
+    const result = await subscriptionService.changePlan(changeRequest);
+
+    expect(stripeInstance.subscriptions.update).toHaveBeenCalledWith('sub_123', {
+      items: [
+        {
+          id: 'si_123',
+          price: 'price_premium',
+        },
+      ],
+      proration_behavior: 'create_prorations',
+    });
+
+    expect(result.priceId).toBe('price_premium');
+  });
+
+  // Req 13: Subscription plan change without proration
+  it('should change subscription plan without proration when prorate is false', async () => {
+    const changeRequest: PlanChangeRequest = {
+      subscriptionId: 'sub_123',
+      newPriceId: 'price_premium',
+      prorate: false,
+    };
+
+    stripeInstance.subscriptions.retrieve.mockResolvedValue({
+      id: 'sub_123',
+      status: 'active',
+      items: {
+        data: [
+          {
+            id: 'si_123',
+            price: { id: 'price_basic' },
+          },
+        ],
+      },
+    });
+
+    stripeInstance.subscriptions.update.mockResolvedValue({
+      id: 'sub_123',
+      status: 'active',
+      current_period_end: 1700000000,
+      cancel_at_period_end: false,
+      items: {
+        data: [
+          {
+            id: 'si_123',
+            price: { id: 'price_premium' },
+          },
+        ],
+      },
+    });
+
+    await subscriptionService.changePlan(changeRequest);
+
+    expect(stripeInstance.subscriptions.update).toHaveBeenCalledWith('sub_123', {
+      items: [
+        {
+          id: 'si_123',
+          price: 'price_premium',
+        },
+      ],
+      proration_behavior: 'none',
+    });
+  });
+
+  // Req 13: Cannot change plan of canceled subscription
+  it('should throw when trying to change plan of canceled subscription', async () => {
+    stripeInstance.subscriptions.retrieve.mockResolvedValue({
+      id: 'sub_123',
+      status: 'canceled',
+      items: {
+        data: [
+          {
+            id: 'si_123',
+            price: { id: 'price_basic' },
+          },
+        ],
+      },
+    });
+
+    await expect(
+      subscriptionService.changePlan({
+        subscriptionId: 'sub_123',
+        newPriceId: 'price_premium',
+      })
+    ).rejects.toThrow('Cannot change plan of canceled subscription');
+  });
+
+  // Req 14: Cancel subscription immediately
+  it('should cancel subscription immediately when immediate is true', async () => {
+    stripeInstance.subscriptions.cancel.mockResolvedValue({
+      id: 'sub_123',
+      status: 'canceled',
+      current_period_end: 1700000000,
+      cancel_at_period_end: false,
+      items: {
+        data: [
+          {
+            id: 'si_123',
+            price: { id: 'price_basic' },
+          },
+        ],
+      },
+    });
+
+    const result = await subscriptionService.cancelSubscription('sub_123', true);
+
+    expect(stripeInstance.subscriptions.cancel).toHaveBeenCalledWith('sub_123');
+    expect(result.status).toBe('canceled');
+    expect(result.cancelAtPeriodEnd).toBe(false);
+  });
+
+  // Req 14: Cancel subscription at end of billing period
+  it('should set cancel_at_period_end when immediate is false', async () => {
+    stripeInstance.subscriptions.update.mockResolvedValue({
+      id: 'sub_123',
+      status: 'active',
+      current_period_end: 1700000000,
+      cancel_at_period_end: true,
+      items: {
+        data: [
+          {
+            id: 'si_123',
+            price: { id: 'price_basic' },
+          },
+        ],
+      },
+    });
+
+    const result = await subscriptionService.cancelSubscription('sub_123', false);
+
+    expect(stripeInstance.subscriptions.update).toHaveBeenCalledWith('sub_123', {
+      cancel_at_period_end: true,
+    });
+    expect(result.cancelAtPeriodEnd).toBe(true);
+  });
+
+  // Req 18: Failed payment retry logic and cancellation after max attempts
+  it('should increment retry attempts and allow retry until max is reached', async () => {
+    const subscriptionId = 'sub_retry';
+
+    stripeInstance.subscriptions.update.mockResolvedValue({
+      id: subscriptionId,
+      status: 'active',
+      current_period_end: 1700000000,
+      cancel_at_period_end: true,
+      items: {
+        data: [
+          {
+            id: 'si_123',
+            price: { id: 'price_basic' },
+          },
+        ],
+      },
+    });
+
+    const first = await subscriptionService.handleFailedPayment(subscriptionId);
+    const second = await subscriptionService.handleFailedPayment(subscriptionId);
+    const third = await subscriptionService.handleFailedPayment(subscriptionId);
+
+    expect(first).toEqual({ shouldRetry: true, attemptNumber: 1 });
+    expect(second).toEqual({ shouldRetry: true, attemptNumber: 2 });
+    expect(third).toEqual({ shouldRetry: false, attemptNumber: 3 });
+
+    expect(stripeInstance.subscriptions.update).toHaveBeenCalledWith(subscriptionId, {
+      cancel_at_period_end: true,
+    });
+  });
+
+  // Req 13: Proration calculation helper
+  it('should calculate proration correctly for upgrade or downgrade', () => {
+    const proration = subscriptionService.calculateProration(100, 200, 15, 30);
+    // Current daily = 100/30, new daily = 200/30, days remaining = 15
+    // Unused credit ≈ 50, new charge ≈ 100, diff ≈ 50 -> rounded to 50.00
+    expect(proration).toBeCloseTo(50, 2);
+  });
+});
+
diff --git a/repository_before/src/subscription-service.ts b/repository_before/src/subscription-service.ts
deleted file mode 100644
index 4c249bccb..000000000
--- a/repository_before/src/subscription-service.ts
+++ /dev/null
@@ -1,134 +0,0 @@
-import Stripe from 'stripe';
-
-export interface CreateSubscriptionRequest {
-  customerId: string;
-  priceId: string;
-  paymentMethodId: string;
-  trialDays?: number;
-}
-
-export interface SubscriptionResult {
-  id: string;
-  status: 'active' | 'trialing' | 'past_due' | 'canceled' | 'incomplete';
-  currentPeriodEnd: Date;
-  cancelAtPeriodEnd: boolean;
-  priceId: string;
-}
-
-export interface PlanChangeRequest {
-  subscriptionId: string;
-  newPriceId: string;
-  prorate?: boolean;
-}
-
-export class SubscriptionService {
-  private stripe: Stripe;
-  private readonly maxRetryAttempts = 3;
-  private retryAttempts: Map<string, number> = new Map();
-
-  constructor(stripeKey: string) {
-    this.stripe = new Stripe(stripeKey, { apiVersion: '2023-10-16' });
-  }
-
-  async createSubscription(request: CreateSubscriptionRequest): Promise<SubscriptionResult> {
-    await this.stripe.paymentMethods.attach(request.paymentMethodId, {
-      customer: request.customerId,
-    });
-
-    await this.stripe.customers.update(request.customerId, {
-      invoice_settings: { default_payment_method: request.paymentMethodId },
-    });
-
-    const subscriptionParams: Stripe.SubscriptionCreateParams = {
-      customer: request.customerId,
-      items: [{ price: request.priceId }],
-      payment_behavior: 'default_incomplete',
-      expand: ['latest_invoice.payment_intent'],
-    };
-
-    if (request.trialDays && request.trialDays > 0) {
-      subscriptionParams.trial_period_days = request.trialDays;
-    }
-
-    const subscription = await this.stripe.subscriptions.create(subscriptionParams);
-
-    return this.mapSubscription(subscription);
-  }
-
-  async changePlan(request: PlanChangeRequest): Promise<SubscriptionResult> {
-    const subscription = await this.stripe.subscriptions.retrieve(request.subscriptionId);
-
-    if (subscription.status === 'canceled') {
-      throw new Error('Cannot change plan of canceled subscription');
-    }
-
-    const updatedSubscription = await this.stripe.subscriptions.update(request.subscriptionId, {
-      items: [
-        {
-          id: subscription.items.data[0].id,
-          price: request.newPriceId,
-        },
-      ],
-      proration_behavior: request.prorate !== false ? 'create_prorations' : 'none',
-    });
-
-    return this.mapSubscription(updatedSubscription);
-  }
-
-  async cancelSubscription(subscriptionId: string, immediate: boolean = false): Promise<SubscriptionResult> {
-    let subscription: Stripe.Subscription;
-
-    if (immediate) {
-      subscription = await this.stripe.subscriptions.cancel(subscriptionId);
-    } else {
-      subscription = await this.stripe.subscriptions.update(subscriptionId, {
-        cancel_at_period_end: true,
-      });
-    }
-
-    return this.mapSubscription(subscription);
-  }
-
-  async handleFailedPayment(subscriptionId: string): Promise<{ shouldRetry: boolean; attemptNumber: number }> {
-    const currentAttempts = this.retryAttempts.get(subscriptionId) || 0;
-    const newAttempts = currentAttempts + 1;
-
-    this.retryAttempts.set(subscriptionId, newAttempts);
-
-    if (newAttempts >= this.maxRetryAttempts) {
-      await this.stripe.subscriptions.update(subscriptionId, {
-        cancel_at_period_end: true,
-      });
-      return { shouldRetry: false, attemptNumber: newAttempts };
-    }
-
-    return { shouldRetry: true, attemptNumber: newAttempts };
-  }
-
-  calculateProration(
-    currentPlanAmount: number,
-    newPlanAmount: number,
-    daysRemaining: number,
-    totalDaysInPeriod: number
-  ): number {
-    const dailyCurrentRate = currentPlanAmount / totalDaysInPeriod;
-    const dailyNewRate = newPlanAmount / totalDaysInPeriod;
-
-    const unusedCredit = dailyCurrentRate * daysRemaining;
-    const newCharge = dailyNewRate * daysRemaining;
-
-    const proration = newCharge - unusedCredit;
-    return Math.round(proration * 100) / 100;
-  }
-
-  private mapSubscription(subscription: Stripe.Subscription): SubscriptionResult {
-    return {
-      id: subscription.id,
-      status: subscription.status as SubscriptionResult['status'],
-      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
-      cancelAtPeriodEnd: subscription.cancel_at_period_end,
-      priceId: subscription.items.data[0].price.id,
-    };
-  }
-}
-
diff --git a/repository_after/src/test-utils/jest-setup.ts b/repository_after/src/test-utils/jest-setup.ts
new file mode 100644
index 000000000..c6f3cb2df
--- /dev/null
+++ b/repository_after/src/test-utils/jest-setup.ts
@@ -0,0 +1,22 @@
+// Global Jest setup for deterministic tests and isolated external APIs
+// Req 19: Date-related behavior is explicitly mocked in tests
+// Req 1,2,58: Ensure Stripe SDK and PayPal HTTP calls are always mocked
+
+// Use globalThis to avoid redeclaring Node's global in TypeScript.
+const g: any = globalThis as any;
+
+// Default fetch mock so no real HTTP calls are ever made in tests.
+if (!g.fetch) {
+  g.fetch = jest.fn();
+}
+
+beforeEach(() => {
+  jest.clearAllMocks();
+  jest.restoreAllMocks();
+
+  // Reset fetch between tests to keep isolation; individual tests can override behavior.
+  if (g.fetch) {
+    g.fetch = jest.fn();
+  }
+});
+
diff --git a/repository_after/src/webhook-handler.test.ts b/repository_after/src/webhook-handler.test.ts
new file mode 100644
index 000000000..2eba6f23c
--- /dev/null
+++ b/repository_after/src/webhook-handler.test.ts
@@ -0,0 +1,246 @@
+import Stripe from 'stripe';
+import crypto from 'crypto';
+import { WebhookHandler } from '../../repository_before/src/webhook-handler';
+
+// Req 1,3,15,16,17,19: Mock Stripe webhooks.constructEvent and test webhook behaviors
+jest.mock('stripe', () => {
+  const webhooks = {
+    constructEvent: jest.fn(),
+  };
+
+  return jest.fn().mockImplementation(() => ({
+    webhooks,
+  }));
+});
+
+const MockedStripe = Stripe as unknown as jest.Mock<typeof Stripe, any[]>;
+
+describe('WebhookHandler', () => {
+  const stripeKey = 'sk_test';
+  const webhookSecret = 'whsec_test_secret';
+  let webhookHandler: WebhookHandler;
+  let stripeInstance: any;
+
+  const payloadObject = { id: 'evt_123', object: 'event' };
+  const payloadString = JSON.stringify(payloadObject);
+
+  beforeEach(() => {
+    stripeInstance = {
+      webhooks: {
+        constructEvent: jest.fn(),
+      },
+    };
+
+    MockedStripe.mockImplementation(() => stripeInstance as any);
+    webhookHandler = new WebhookHandler(stripeKey, webhookSecret);
+  });
+
+  // Req 19: Restore Date.now after tests that mock it so timestamp-dependent tests do not leak
+  afterEach(() => {
+    jest.restoreAllMocks();
+  });
+
+  // Req 15: Valid webhook signature verification using Stripe SDK
+  it('should return true when verifySignature receives a valid signature', () => {
+    stripeInstance.webhooks.constructEvent.mockReturnValue({
+      id: 'evt_1',
+      type: 'payment_intent.succeeded',
+    });
+
+    const isValid = webhookHandler.verifySignature(payloadString, 'sig_header');
+    expect(isValid).toBe(true);
+  });
+
+  // Req 15: Invalid/tampered signature rejection using Stripe SDK
+  it('should return false when verifySignature receives an invalid signature', () => {
+    stripeInstance.webhooks.constructEvent.mockImplementation(() => {
+      throw new Error('Invalid signature');
+    });
+
+    const isValid = webhookHandler.verifySignature(payloadString, 'bad_sig');
+    expect(isValid).toBe(false);
+  });
+
+  // Req 15,19: Manual signature verification with valid signature and timestamp
+  it('should return true from verifySignatureManual for a valid non-expired signature', () => {
+    const timestamp = Math.floor(Date.now() / 1000);
+    const signedPayload = `${timestamp}.${payloadString}`;
+    const expectedSignature = crypto
+      .createHmac('sha256', webhookSecret)
+      .update(signedPayload)
+      .digest('hex');
+
+    const signatureHeader = `t=${timestamp},v1=${expectedSignature}`;
+
+    jest.spyOn(Date, 'now').mockReturnValue(timestamp * 1000);
+
+    const isValid = webhookHandler.verifySignatureManual(payloadString, signatureHeader);
+    expect(isValid).toBe(true);
+  });
+
+  // Req 15,19: Manual signature verification with expired timestamp
+  it('should return false from verifySignatureManual when timestamp is expired', () => {
+    const now = Math.floor(Date.now() / 1000);
+    const oldTimestamp = now - 1000;
+    const signedPayload = `${oldTimestamp}.${payloadString}`;
+    const expectedSignature = crypto
+      .createHmac('sha256', webhookSecret)
+      .update(signedPayload)
+      .digest('hex');
+
+    const signatureHeader = `t=${oldTimestamp},v1=${expectedSignature}`;
+
+    jest.spyOn(Date, 'now').mockReturnValue(now * 1000);
+
+    const isValid = webhookHandler.verifySignatureManual(payloadString, signatureHeader);
+    expect(isValid).toBe(false);
+  });
+
+  // Req 15: Manual signature with missing fields
+  it('should return false from verifySignatureManual when signature header is missing fields', () => {
+    const isValid = webhookHandler.verifySignatureManual(payloadString, 'v1=abc');
+    expect(isValid).toBe(false);
+  });
+
+  // Req 16,17: Duplicate webhook event handling and event dispatch to correct handler
+  it('should dispatch event to default handler and not process duplicate events twice', async () => {
+    const event = {
+      id: 'evt_1',
+      type: 'payment_intent.succeeded',
+      data: {
+        object: { id: 'pi_123' },
+      },
+    };
+
+    stripeInstance.webhooks.constructEvent.mockReturnValue(event);
+
+    const first = await webhookHandler.handleWebhook(payloadString, 'valid_sig');
+    const second = await webhookHandler.handleWebhook(payloadString, 'valid_sig');
+
+    expect(first).toEqual({
+      success: true,
+      eventId: 'evt_1',
+      eventType: 'payment_intent.succeeded',
+    });
+
+    expect(second).toEqual({
+      success: true,
+      eventId: 'evt_1',
+      eventType: 'payment_intent.succeeded',
+    });
+  });
+
+  // Req 15,17: Unknown event type handling
+  it('should handle unknown event types gracefully by returning success without error', async () => {
+    const event = {
+      id: 'evt_unknown',
+      type: 'unknown.event',
+      data: {
+        object: { id: 'obj_1' },
+      },
+    };
+
+    stripeInstance.webhooks.constructEvent.mockReturnValue(event);
+
+    const result = await webhookHandler.handleWebhook(payloadString, 'valid_sig');
+
+    expect(result).toEqual({
+      success: true,
+      eventId: 'evt_unknown',
+      eventType: 'unknown.event',
+    });
+  });
+
+  // Req 15: Invalid signature in handleWebhook
+  it('should return invalid signature error when verifySignature fails in handleWebhook', async () => {
+    // verifySignature will return false because constructEvent throws
+    stripeInstance.webhooks.constructEvent.mockImplementation(() => {
+      throw new Error('Invalid signature');
+    });
+
+    const result = await webhookHandler.handleWebhook(payloadString, 'bad_sig');
+    expect(result).toEqual({
+      success: false,
+      eventId: '',
+      eventType: '',
+      error: 'Invalid signature',
+    });
+  });
+
+  // Req 15: Error while constructing event after signature verification
+  it('should return error when constructEvent throws after verifySignature passes', async () => {
+    // First call for verifySignature should succeed
+    stripeInstance.webhooks.constructEvent
+      .mockReturnValueOnce({
+        id: 'evt_error',
+        type: 'payment_intent.succeeded',
+        data: { object: { id: 'pi_123' } },
+      })
+      // Second call inside handleWebhook should throw
+      .mockImplementationOnce(() => {
+        throw new Error('Webhook parse error');
+      });
+
+    const result = await webhookHandler.handleWebhook(payloadString, 'sig_header');
+
+    expect(result).toEqual({
+      success: false,
+      eventId: '',
+      eventType: '',
+      error: 'Webhook parse error',
+    });
+  });
+
+  // Req 17: Event handler execution and error handling
+  it('should call registered handler for event type and handle handler errors', async () => {
+    const handler = jest.fn().mockResolvedValue(undefined);
+    webhookHandler.registerHandler('customer.subscription.updated', handler);
+
+    const event = {
+      id: 'evt_sub_updated',
+      type: 'customer.subscription.updated',
+      data: { object: { id: 'sub_123' } },
+    };
+
+    stripeInstance.webhooks.constructEvent.mockReturnValue(event);
+
+    const successResult = await webhookHandler.handleWebhook(payloadString, 'sig_header');
+    expect(handler).toHaveBeenCalledWith({ id: 'sub_123' });
+    expect(successResult.success).toBe(true);
+
+    const failingHandler = jest.fn().mockRejectedValue(new Error('Handler failed'));
+    webhookHandler.registerHandler('invoice.payment_failed', failingHandler);
+
+    const failingEvent = {
+      id: 'evt_invoice_failed',
+      type: 'invoice.payment_failed',
+      data: { object: { id: 'inv_123' } },
+    };
+
+    stripeInstance.webhooks.constructEvent.mockReturnValue(failingEvent);
+
+    const failResult = await webhookHandler.handleWebhook(payloadString, 'sig_header');
+    expect(failingHandler).toHaveBeenCalledWith({ id: 'inv_123' });
+    expect(failResult.success).toBe(false);
+    expect(failResult.error).toBe('Handler failed');
+  });
+
+  // Req 16: clearProcessedEvents should reset processed event set
+  it('should clear processed events so an event can be processed again', async () => {
+    const event = {
+      id: 'evt_clear',
+      type: 'payment_intent.succeeded',
+      data: { object: { id: 'pi_123' } },
+    };
+
+    stripeInstance.webhooks.constructEvent.mockReturnValue(event);
+
+    await webhookHandler.handleWebhook(payloadString, 'sig_header');
+    webhookHandler.clearProcessedEvents();
+    const result = await webhookHandler.handleWebhook(payloadString, 'sig_header');
+
+    expect(result.success).toBe(true);
+    expect(result.eventId).toBe('evt_clear');
+  });
+});
+
diff --git a/repository_before/src/webhook-handler.ts b/repository_before/src/webhook-handler.ts
deleted file mode 100644
index 4823a850b..000000000
--- a/repository_before/src/webhook-handler.ts
+++ /dev/null
@@ -1,161 +0,0 @@
-import Stripe from 'stripe';
-import crypto from 'crypto';
-
-export interface WebhookEvent {
-  id: string;
-  type: string;
-  data: any;
-  created: number;
-}
-
-export interface WebhookResult {
-  success: boolean;
-  eventId: string;
-  eventType: string;
-  error?: string;
-}
-
-export class WebhookHandler {
-  private stripe: Stripe;
-  private webhookSecret: string;
-  private processedEvents: Set<string> = new Set();
-  private eventHandlers: Map<string, (data: any) => Promise<void>> = new Map();
-
-  constructor(stripeKey: string, webhookSecret: string) {
-    this.stripe = new Stripe(stripeKey, { apiVersion: '2023-10-16' });
-    this.webhookSecret = webhookSecret;
-    this.registerDefaultHandlers();
-  }
-
-  private registerDefaultHandlers(): void {
-    this.eventHandlers.set('payment_intent.succeeded', async (data) => {
-      console.log('Payment succeeded:', data.id);
-    });
-
-    this.eventHandlers.set('payment_intent.payment_failed', async (data) => {
-      console.log('Payment failed:', data.id);
-    });
-
-    this.eventHandlers.set('customer.subscription.updated', async (data) => {
-      console.log('Subscription updated:', data.id);
-    });
-
-    this.eventHandlers.set('customer.subscription.deleted', async (data) => {
-      console.log('Subscription deleted:', data.id);
-    });
-
-    this.eventHandlers.set('invoice.payment_failed', async (data) => {
-      console.log('Invoice payment failed:', data.id);
-    });
-  }
-
-  registerHandler(eventType: string, handler: (data: any) => Promise<void>): void {
-    this.eventHandlers.set(eventType, handler);
-  }
-
-  verifySignature(payload: string | Buffer, signature: string): boolean {
-    try {
-      const event = this.stripe.webhooks.constructEvent(payload, signature, this.webhookSecret);
-      return !!event;
-    } catch {
-      return false;
-    }
-  }
-
-  verifySignatureManual(payload: string, signature: string): boolean {
-    const signatureParts = signature.split(',');
-    let timestamp = '';
-    let v1Signature = '';
-
-    for (const part of signatureParts) {
-      const [key, value] = part.split('=');
-      if (key === 't') timestamp = value;
-      if (key === 'v1') v1Signature = value;
-    }
-
-    if (!timestamp || !v1Signature) {
-      return false;
-    }
-
-    const timestampNum = parseInt(timestamp, 10);
-    const now = Math.floor(Date.now() / 1000);
-    const tolerance = 300;
-
-    if (Math.abs(now - timestampNum) > tolerance) {
-      return false;
-    }
-
-    const signedPayload = `${timestamp}.${payload}`;
-    const expectedSignature = crypto
-      .createHmac('sha256', this.webhookSecret)
-      .update(signedPayload)
-      .digest('hex');
-
-    return crypto.timingSafeEqual(Buffer.from(v1Signature), Buffer.from(expectedSignature));
-  }
-
-  async handleWebhook(payload: string | Buffer, signature: string): Promise<WebhookResult> {
-    if (!this.verifySignature(payload, signature)) {
-      return {
-        success: false,
-        eventId: '',
-        eventType: '',
-        error: 'Invalid signature',
-      };
-    }
-
-    let event: Stripe.Event;
-    try {
-      event = this.stripe.webhooks.constructEvent(payload, signature, this.webhookSecret);
-    } catch (error: any) {
-      return {
-        success: false,
-        eventId: '',
-        eventType: '',
-        error: error.message,
-      };
-    }
-
-    if (this.processedEvents.has(event.id)) {
-      return {
-        success: true,
-        eventId: event.id,
-        eventType: event.type,
-      };
-    }
-
-    const handler = this.eventHandlers.get(event.type);
-
-    if (!handler) {
-      this.processedEvents.add(event.id);
-      return {
-        success: true,
-        eventId: event.id,
-        eventType: event.type,
-      };
-    }
-
-    try {
-      await handler(event.data.object);
-      this.processedEvents.add(event.id);
-
-      return {
-        success: true,
-        eventId: event.id,
-        eventType: event.type,
-      };
-    } catch (error: any) {
-      return {
-        success: false,
-        eventId: event.id,
-        eventType: event.type,
-        error: error.message,
-      };
-    }
-  }
-
-  clearProcessedEvents(): void {
-    this.processedEvents.clear();
-  }
-}
-
