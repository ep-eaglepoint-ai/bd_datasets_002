diff --git repository_after/client/Dockerfile repository_after/client/Dockerfile
new file mode 100644
index 0000000..2800e97
--- /dev/null
+++ repository_after/client/Dockerfile
@@ -0,0 +1,14 @@
+FROM node:20-alpine
+
+WORKDIR /app
+
+COPY package*.json ./
+RUN npm install
+
+COPY . .
+
+ENV API_URL=http://server:3001
+
+EXPOSE 5173
+
+CMD ["npm", "run", "dev", "--", "--host"]
diff --git repository_after/client/index.html repository_after/client/index.html
new file mode 100644
index 0000000..1c6ed50
--- /dev/null
+++ repository_after/client/index.html
@@ -0,0 +1,13 @@
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="UTF-8" />
+    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
+    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+    <title>Meeting Room Booking</title>
+  </head>
+  <body>
+    <div id="root"></div>
+    <script type="module" src="/src/main.jsx"></script>
+  </body>
+</html>
diff --git repository_after/client/package.json repository_after/client/package.json
new file mode 100644
index 0000000..20f1189
--- /dev/null
+++ repository_after/client/package.json
@@ -0,0 +1,23 @@
+{
+  "name": "booking-system-client",
+  "private": true,
+  "version": "1.0.0",
+  "type": "module",
+  "scripts": {
+    "dev": "vite",
+    "build": "vite build",
+    "preview": "vite preview"
+  },
+  "dependencies": {
+    "react": "^18.2.0",
+    "react-dom": "^18.2.0",
+    "react-router-dom": "^6.21.1"
+  },
+  "devDependencies": {
+    "@vitejs/plugin-react": "^4.2.1",
+    "autoprefixer": "^10.4.16",
+    "postcss": "^8.4.32",
+    "tailwindcss": "^3.4.0",
+    "vite": "^5.0.10"
+  }
+}
diff --git repository_after/client/postcss.config.js repository_after/client/postcss.config.js
new file mode 100644
index 0000000..2e7af2b
--- /dev/null
+++ repository_after/client/postcss.config.js
@@ -0,0 +1,6 @@
+export default {
+  plugins: {
+    tailwindcss: {},
+    autoprefixer: {},
+  },
+}
diff --git repository_after/client/src/App.jsx repository_after/client/src/App.jsx
new file mode 100644
index 0000000..2b860c2
--- /dev/null
+++ repository_after/client/src/App.jsx
@@ -0,0 +1,54 @@
+import { Routes, Route, Navigate } from 'react-router-dom';
+import { AuthProvider, useAuth } from './components/AuthContext';
+import Navbar from './components/Navbar';
+import Login from './pages/Login';
+import Register from './pages/Register';
+import Rooms from './pages/Rooms';
+import RoomBookings from './pages/RoomBookings';
+import MyBookings from './pages/MyBookings';
+
+function PrivateRoute({ children }) {
+  const { user, loading } = useAuth();
+  
+  if (loading) {
+    return (
+      <div className="flex justify-center items-center h-64">
+        <div className="text-gray-500">Loading...</div>
+      </div>
+    );
+  }
+  
+  return user ? children : <Navigate to="/login" />;
+}
+
+function AppRoutes() {
+  return (
+    <div className="min-h-screen">
+      <Navbar />
+      <main className="max-w-6xl mx-auto px-4 py-8">
+        <Routes>
+          <Route path="/login" element={<Login />} />
+          <Route path="/register" element={<Register />} />
+          <Route path="/" element={<Rooms />} />
+          <Route path="/rooms/:id" element={<RoomBookings />} />
+          <Route
+            path="/my-bookings"
+            element={
+              <PrivateRoute>
+                <MyBookings />
+              </PrivateRoute>
+            }
+          />
+        </Routes>
+      </main>
+    </div>
+  );
+}
+
+export default function App() {
+  return (
+    <AuthProvider>
+      <AppRoutes />
+    </AuthProvider>
+  );
+}
diff --git repository_after/client/src/api/client.js repository_after/client/src/api/client.js
new file mode 100644
index 0000000..e2f3283
--- /dev/null
+++ repository_after/client/src/api/client.js
@@ -0,0 +1,65 @@
+const API_BASE = '/api';
+
+function getToken() {
+  return localStorage.getItem('token');
+}
+
+async function request(endpoint, options = {}) {
+  const token = getToken();
+  const headers = {
+    'Content-Type': 'application/json',
+    ...options.headers,
+  };
+
+  if (token) {
+    headers['Authorization'] = `Bearer ${token}`;
+  }
+
+  const response = await fetch(`${API_BASE}${endpoint}`, {
+    ...options,
+    headers,
+  });
+
+  const data = await response.json();
+
+  if (!response.ok) {
+    throw new Error(data.error || 'Request failed');
+  }
+
+  return data;
+}
+
+export const api = {
+  // Auth
+  login: (email, password) =>
+    request('/auth/login', {
+      method: 'POST',
+      body: JSON.stringify({ email, password }),
+    }),
+
+  register: (email, password, name) =>
+    request('/auth/register', {
+      method: 'POST',
+      body: JSON.stringify({ email, password, name }),
+    }),
+
+  getMe: () => request('/auth/me'),
+
+  // Rooms
+  getRooms: () => request('/rooms'),
+
+  getRoomBookings: (roomId, date) =>
+    request(`/rooms/${roomId}/bookings?date=${date}`),
+
+  // Bookings
+  createBooking: (roomId, startTime, endTime) =>
+    request('/bookings', {
+      method: 'POST',
+      body: JSON.stringify({ roomId, startTime, endTime }),
+    }),
+
+  getMyBookings: () => request('/bookings/mine'),
+
+  cancelBooking: (id) =>
+    request(`/bookings/${id}`, { method: 'DELETE' }),
+};
diff --git repository_after/client/src/components/AuthContext.jsx repository_after/client/src/components/AuthContext.jsx
new file mode 100644
index 0000000..57b2597
--- /dev/null
+++ repository_after/client/src/components/AuthContext.jsx
@@ -0,0 +1,56 @@
+import { createContext, useContext, useState, useEffect } from 'react';
+import { api } from '../api/client';
+
+const AuthContext = createContext(null);
+
+export function AuthProvider({ children }) {
+  const [user, setUser] = useState(null);
+  const [loading, setLoading] = useState(true);
+
+  useEffect(() => {
+    const token = localStorage.getItem('token');
+    if (token) {
+      api.getMe()
+        .then(data => setUser(data.user))
+        .catch(() => {
+          localStorage.removeItem('token');
+        })
+        .finally(() => setLoading(false));
+    } else {
+      setLoading(false);
+    }
+  }, []);
+
+  const login = async (email, password) => {
+    const data = await api.login(email, password);
+    localStorage.setItem('token', data.token);
+    setUser(data.user);
+    return data;
+  };
+
+  const register = async (email, password, name) => {
+    const data = await api.register(email, password, name);
+    localStorage.setItem('token', data.token);
+    setUser(data.user);
+    return data;
+  };
+
+  const logout = () => {
+    localStorage.removeItem('token');
+    setUser(null);
+  };
+
+  return (
+    <AuthContext.Provider value={{ user, loading, login, register, logout }}>
+      {children}
+    </AuthContext.Provider>
+  );
+}
+
+export function useAuth() {
+  const context = useContext(AuthContext);
+  if (!context) {
+    throw new Error('useAuth must be used within AuthProvider');
+  }
+  return context;
+}
diff --git repository_after/client/src/components/Navbar.jsx repository_after/client/src/components/Navbar.jsx
new file mode 100644
index 0000000..a81f32d
--- /dev/null
+++ repository_after/client/src/components/Navbar.jsx
@@ -0,0 +1,57 @@
+import { Link, useNavigate } from 'react-router-dom';
+import { useAuth } from './AuthContext';
+
+export default function Navbar() {
+  const { user, logout } = useAuth();
+  const navigate = useNavigate();
+
+  const handleLogout = () => {
+    logout();
+    navigate('/login');
+  };
+
+  return (
+    <nav className="bg-blue-600 text-white shadow-lg">
+      <div className="max-w-6xl mx-auto px-4">
+        <div className="flex justify-between items-center h-16">
+          <Link to="/" className="text-xl font-bold">
+            Meeting Rooms
+          </Link>
+
+          <div className="flex items-center gap-4">
+            {user ? (
+              <>
+                <Link to="/" className="hover:text-blue-200">
+                  Rooms
+                </Link>
+                <Link to="/my-bookings" className="hover:text-blue-200">
+                  My Bookings
+                </Link>
+                <span className="text-blue-200">|</span>
+                <span className="text-sm">{user.name}</span>
+                <button
+                  onClick={handleLogout}
+                  className="bg-blue-700 hover:bg-blue-800 px-3 py-1 rounded text-sm"
+                >
+                  Logout
+                </button>
+              </>
+            ) : (
+              <>
+                <Link to="/login" className="hover:text-blue-200">
+                  Login
+                </Link>
+                <Link
+                  to="/register"
+                  className="bg-blue-700 hover:bg-blue-800 px-3 py-1 rounded"
+                >
+                  Register
+                </Link>
+              </>
+            )}
+          </div>
+        </div>
+      </div>
+    </nav>
+  );
+}
diff --git repository_after/client/src/index.css repository_after/client/src/index.css
new file mode 100644
index 0000000..c2f490f
--- /dev/null
+++ repository_after/client/src/index.css
@@ -0,0 +1,7 @@
+@tailwind base;
+@tailwind components;
+@tailwind utilities;
+
+body {
+  @apply bg-gray-50 text-gray-900;
+}
diff --git repository_after/client/src/main.jsx repository_after/client/src/main.jsx
new file mode 100644
index 0000000..6cede93
--- /dev/null
+++ repository_after/client/src/main.jsx
@@ -0,0 +1,13 @@
+import React from 'react';
+import ReactDOM from 'react-dom/client';
+import { BrowserRouter } from 'react-router-dom';
+import App from './App';
+import './index.css';
+
+ReactDOM.createRoot(document.getElementById('root')).render(
+  <React.StrictMode>
+    <BrowserRouter>
+      <App />
+    </BrowserRouter>
+  </React.StrictMode>
+);
diff --git repository_after/client/src/pages/Login.jsx repository_after/client/src/pages/Login.jsx
new file mode 100644
index 0000000..0b9e2d9
--- /dev/null
+++ repository_after/client/src/pages/Login.jsx
@@ -0,0 +1,84 @@
+import { useState } from 'react';
+import { Link, useNavigate } from 'react-router-dom';
+import { useAuth } from '../components/AuthContext';
+
+export default function Login() {
+  const [email, setEmail] = useState('');
+  const [password, setPassword] = useState('');
+  const [error, setError] = useState('');
+  const [loading, setLoading] = useState(false);
+  const { login } = useAuth();
+  const navigate = useNavigate();
+
+  const handleSubmit = async (e) => {
+    e.preventDefault();
+    setError('');
+    setLoading(true);
+
+    try {
+      await login(email, password);
+      navigate('/');
+    } catch (err) {
+      setError(err.message);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  return (
+    <div className="max-w-md mx-auto">
+      <h1 className="text-2xl font-bold mb-6">Login</h1>
+
+      {error && (
+        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
+          {error}
+        </div>
+      )}
+
+      <form onSubmit={handleSubmit} className="space-y-4">
+        <div>
+          <label className="block text-sm font-medium mb-1">Email</label>
+          <input
+            type="email"
+            value={email}
+            onChange={(e) => setEmail(e.target.value)}
+            className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
+            required
+          />
+        </div>
+
+        <div>
+          <label className="block text-sm font-medium mb-1">Password</label>
+          <input
+            type="password"
+            value={password}
+            onChange={(e) => setPassword(e.target.value)}
+            className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
+            required
+          />
+        </div>
+
+        <button
+          type="submit"
+          disabled={loading}
+          className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50"
+        >
+          {loading ? 'Logging in...' : 'Login'}
+        </button>
+      </form>
+
+      <p className="mt-4 text-center text-gray-600">
+        Don't have an account?{' '}
+        <Link to="/register" className="text-blue-600 hover:underline">
+          Register
+        </Link>
+      </p>
+
+      <div className="mt-6 p-4 bg-gray-100 rounded text-sm">
+        <p className="font-medium mb-2">Test accounts:</p>
+        <p>alice@test.com / password123</p>
+        <p>bob@test.com / password123</p>
+      </div>
+    </div>
+  );
+}
diff --git repository_after/client/src/pages/MyBookings.jsx repository_after/client/src/pages/MyBookings.jsx
new file mode 100644
index 0000000..fe4ca45
--- /dev/null
+++ repository_after/client/src/pages/MyBookings.jsx
@@ -0,0 +1,163 @@
+import { useState, useEffect } from 'react';
+import { api } from '../api/client';
+
+function formatDate(dateStr) {
+  return new Date(dateStr).toLocaleDateString('en-US', {
+    weekday: 'short',
+    year: 'numeric',
+    month: 'short',
+    day: 'numeric',
+  });
+}
+
+function formatTime(dateStr) {
+  return new Date(dateStr).toLocaleTimeString('en-US', {
+    hour: 'numeric',
+    minute: '2-digit',
+  });
+}
+
+export default function MyBookings() {
+  const [bookings, setBookings] = useState([]);
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState('');
+  const [cancelling, setCancelling] = useState(null);
+
+  useEffect(() => {
+    loadBookings();
+  }, []);
+
+  const loadBookings = async () => {
+    try {
+      const data = await api.getMyBookings();
+      setBookings(data.bookings);
+    } catch (err) {
+      setError(err.message);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  const handleCancel = async (id) => {
+    if (!confirm('Are you sure you want to cancel this booking?')) {
+      return;
+    }
+
+    setCancelling(id);
+    try {
+      await api.cancelBooking(id);
+      loadBookings();
+    } catch (err) {
+      alert(err.message);
+    } finally {
+      setCancelling(null);
+    }
+  };
+
+  const isPast = (dateStr) => new Date(dateStr) < new Date();
+
+  if (loading) {
+    return <div className="text-center py-8">Loading your bookings...</div>;
+  }
+
+  if (error) {
+    return (
+      <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
+        {error}
+      </div>
+    );
+  }
+
+  const upcomingBookings = bookings.filter(
+    (b) => b.status === 'confirmed' && !isPast(b.start_time)
+  );
+  const pastBookings = bookings.filter(
+    (b) => b.status !== 'confirmed' || isPast(b.start_time)
+  );
+
+  return (
+    <div>
+      <h1 className="text-2xl font-bold mb-6">My Bookings</h1>
+
+      {bookings.length === 0 ? (
+        <div className="bg-gray-100 rounded-lg p-8 text-center">
+          <p className="text-gray-600">You don't have any bookings yet.</p>
+        </div>
+      ) : (
+        <>
+          {/* Upcoming bookings */}
+          {upcomingBookings.length > 0 && (
+            <div className="mb-8">
+              <h2 className="text-lg font-semibold mb-4">Upcoming</h2>
+              <div className="space-y-3">
+                {upcomingBookings.map((booking) => (
+                  <div
+                    key={booking.id}
+                    className="bg-white rounded-lg shadow p-4 flex justify-between items-center"
+                  >
+                    <div>
+                      <h3 className="font-medium">{booking.room_name}</h3>
+                      <p className="text-gray-600 text-sm">
+                        {formatDate(booking.start_time)}
+                      </p>
+                      <p className="text-gray-600 text-sm">
+                        {formatTime(booking.start_time)} -{' '}
+                        {formatTime(booking.end_time)}
+                      </p>
+                    </div>
+                    <button
+                      onClick={() => handleCancel(booking.id)}
+                      disabled={cancelling === booking.id}
+                      className="px-4 py-2 text-red-600 hover:bg-red-50 rounded disabled:opacity-50"
+                    >
+                      {cancelling === booking.id ? 'Cancelling...' : 'Cancel'}
+                    </button>
+                  </div>
+                ))}
+              </div>
+            </div>
+          )}
+
+          {/* Past/cancelled bookings */}
+          {pastBookings.length > 0 && (
+            <div>
+              <h2 className="text-lg font-semibold mb-4 text-gray-500">
+                Past & Cancelled
+              </h2>
+              <div className="space-y-3">
+                {pastBookings.map((booking) => (
+                  <div
+                    key={booking.id}
+                    className="bg-gray-100 rounded-lg p-4 opacity-75"
+                  >
+                    <div className="flex justify-between items-start">
+                      <div>
+                        <h3 className="font-medium">{booking.room_name}</h3>
+                        <p className="text-gray-600 text-sm">
+                          {formatDate(booking.start_time)}
+                        </p>
+                        <p className="text-gray-600 text-sm">
+                          {formatTime(booking.start_time)} -{' '}
+                          {formatTime(booking.end_time)}
+                        </p>
+                      </div>
+                      <span
+                        className={`px-2 py-1 text-xs rounded ${
+                          booking.status === 'cancelled'
+                            ? 'bg-red-100 text-red-700'
+                            : 'bg-gray-200 text-gray-700'
+                        }`}
+                      >
+                        {booking.status === 'cancelled' ? 'Cancelled' : 'Past'}
+                      </span>
+                    </div>
+                  </div>
+                ))}
+              </div>
+            </div>
+          )}
+        </>
+      )}
+    </div>
+  );
+}
diff --git repository_after/client/src/pages/Register.jsx repository_after/client/src/pages/Register.jsx
new file mode 100644
index 0000000..0f428cb
--- /dev/null
+++ repository_after/client/src/pages/Register.jsx
@@ -0,0 +1,92 @@
+import { useState } from 'react';
+import { Link, useNavigate } from 'react-router-dom';
+import { useAuth } from '../components/AuthContext';
+
+export default function Register() {
+  const [name, setName] = useState('');
+  const [email, setEmail] = useState('');
+  const [password, setPassword] = useState('');
+  const [error, setError] = useState('');
+  const [loading, setLoading] = useState(false);
+  const { register } = useAuth();
+  const navigate = useNavigate();
+
+  const handleSubmit = async (e) => {
+    e.preventDefault();
+    setError('');
+    setLoading(true);
+
+    try {
+      await register(email, password, name);
+      navigate('/');
+    } catch (err) {
+      setError(err.message);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  return (
+    <div className="max-w-md mx-auto">
+      <h1 className="text-2xl font-bold mb-6">Create Account</h1>
+
+      {error && (
+        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
+          {error}
+        </div>
+      )}
+
+      <form onSubmit={handleSubmit} className="space-y-4">
+        <div>
+          <label className="block text-sm font-medium mb-1">Name</label>
+          <input
+            type="text"
+            value={name}
+            onChange={(e) => setName(e.target.value)}
+            className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
+            required
+          />
+        </div>
+
+        <div>
+          <label className="block text-sm font-medium mb-1">Email</label>
+          <input
+            type="email"
+            value={email}
+            onChange={(e) => setEmail(e.target.value)}
+            className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
+            required
+          />
+        </div>
+
+        <div>
+          <label className="block text-sm font-medium mb-1">Password</label>
+          <input
+            type="password"
+            value={password}
+            onChange={(e) => setPassword(e.target.value)}
+            className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
+            minLength={6}
+            required
+          />
+          <p className="text-xs text-gray-500 mt-1">Minimum 6 characters</p>
+        </div>
+
+        <button
+          type="submit"
+          disabled={loading}
+          className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50"
+        >
+          {loading ? 'Creating account...' : 'Register'}
+        </button>
+      </form>
+
+      <p className="mt-4 text-center text-gray-600">
+        Already have an account?{' '}
+        <Link to="/login" className="text-blue-600 hover:underline">
+          Login
+        </Link>
+      </p>
+    </div>
+  );
+}
diff --git repository_after/client/src/pages/RoomBookings.jsx repository_after/client/src/pages/RoomBookings.jsx
new file mode 100644
index 0000000..9e7c41c
--- /dev/null
+++ repository_after/client/src/pages/RoomBookings.jsx
@@ -0,0 +1,265 @@
+import { useState, useEffect } from 'react';
+import { useParams, useNavigate } from 'react-router-dom';
+import { api } from '../api/client';
+import { useAuth } from '../components/AuthContext';
+
+const HOURS = Array.from({ length: 10 }, (_, i) => i + 9); // 9 AM to 6 PM
+
+function formatTime(hour) {
+  const suffix = hour >= 12 ? 'PM' : 'AM';
+  const h = hour > 12 ? hour - 12 : hour;
+  return `${h}:00 ${suffix}`;
+}
+
+function formatDateTime(date, hour) {
+  const d = new Date(date);
+  d.setHours(hour, 0, 0, 0);
+  return d.toISOString();
+}
+
+function getBookingForHour(bookings, hour) {
+  for (const booking of bookings) {
+    const start = new Date(booking.start_time);
+    const end = new Date(booking.end_time);
+    if (start.getHours() <= hour && end.getHours() > hour) {
+      return booking;
+    }
+  }
+  return null;
+}
+
+export default function RoomBookings() {
+  const { id } = useParams();
+  const { user } = useAuth();
+  const navigate = useNavigate();
+  
+  const [room, setRoom] = useState(null);
+  const [bookings, setBookings] = useState([]);
+  const [selectedDate, setSelectedDate] = useState(
+    new Date().toISOString().split('T')[0]
+  );
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState('');
+  
+  // Booking form state
+  const [bookingStart, setBookingStart] = useState('');
+  const [bookingEnd, setBookingEnd] = useState('');
+  const [bookingError, setBookingError] = useState('');
+  const [bookingSuccess, setBookingSuccess] = useState('');
+  const [submitting, setSubmitting] = useState(false);
+
+  useEffect(() => {
+    loadBookings();
+  }, [id, selectedDate]);
+
+  const loadBookings = async () => {
+    setLoading(true);
+    setError('');
+    try {
+      const data = await api.getRoomBookings(id, selectedDate);
+      setRoom(data.room);
+      setBookings(data.bookings);
+    } catch (err) {
+      setError(err.message);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  const handleBook = async (e) => {
+    e.preventDefault();
+    if (!user) {
+      navigate('/login');
+      return;
+    }
+
+    setBookingError('');
+    setBookingSuccess('');
+    setSubmitting(true);
+
+    try {
+      const startTime = `${selectedDate}T${bookingStart}:00`;
+      const endTime = `${selectedDate}T${bookingEnd}:00`;
+
+      await api.createBooking(parseInt(id), startTime, endTime);
+      setBookingSuccess('Booking confirmed!');
+      setBookingStart('');
+      setBookingEnd('');
+      loadBookings();
+    } catch (err) {
+      setBookingError(err.message);
+    } finally {
+      setSubmitting(false);
+    }
+  };
+
+  const isPastDate = new Date(selectedDate) < new Date(new Date().toDateString());
+  const isWeekend = () => {
+    const d = new Date(selectedDate);
+    return d.getDay() === 0 || d.getDay() === 6;
+  };
+
+  if (loading && !room) {
+    return <div className="text-center py-8">Loading...</div>;
+  }
+
+  if (error && !room) {
+    return (
+      <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
+        {error}
+      </div>
+    );
+  }
+
+  return (
+    <div>
+      <div className="mb-6">
+        <h1 className="text-2xl font-bold">{room?.name}</h1>
+        <p className="text-gray-600">Capacity: {room?.capacity} people</p>
+      </div>
+
+      {/* Date picker */}
+      <div className="mb-6">
+        <label className="block text-sm font-medium mb-2">Select Date</label>
+        <input
+          type="date"
+          value={selectedDate}
+          onChange={(e) => setSelectedDate(e.target.value)}
+          className="border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
+        />
+        {isWeekend() && (
+          <p className="text-orange-600 text-sm mt-1">
+            Note: Bookings are only available Monday-Friday
+          </p>
+        )}
+      </div>
+
+      <div className="grid gap-6 lg:grid-cols-2">
+        {/* Schedule */}
+        <div className="bg-white rounded-lg shadow p-4">
+          <h2 className="text-lg font-semibold mb-4">Schedule for {selectedDate}</h2>
+          
+          <div className="space-y-2">
+            {HOURS.map((hour) => {
+              const booking = getBookingForHour(bookings, hour);
+              return (
+                <div
+                  key={hour}
+                  className={`flex items-center p-3 rounded ${
+                    booking
+                      ? 'bg-red-50 border border-red-200'
+                      : 'bg-green-50 border border-green-200'
+                  }`}
+                >
+                  <div className="w-24 text-sm font-medium">{formatTime(hour)}</div>
+                  <div className="flex-1">
+                    {booking ? (
+                      <span className="text-red-700">
+                        Booked by {booking.booker_name}
+                      </span>
+                    ) : (
+                      <span className="text-green-700">Available</span>
+                    )}
+                  </div>
+                </div>
+              );
+            })}
+          </div>
+        </div>
+
+        {/* Booking form */}
+        {!isPastDate && !isWeekend() && (
+          <div className="bg-white rounded-lg shadow p-4">
+            <h2 className="text-lg font-semibold mb-4">Book this room</h2>
+
+            {!user && (
+              <p className="text-gray-600 mb-4">
+                Please{' '}
+                <button
+                  onClick={() => navigate('/login')}
+                  className="text-blue-600 hover:underline"
+                >
+                  login
+                </button>{' '}
+                to make a booking.
+              </p>
+            )}
+
+            {bookingError && (
+              <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
+                {bookingError}
+              </div>
+            )}
+
+            {bookingSuccess && (
+              <div className="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded mb-4">
+                {bookingSuccess}
+              </div>
+            )}
+
+            <form onSubmit={handleBook} className="space-y-4">
+              <div>
+                <label className="block text-sm font-medium mb-1">Start Time</label>
+                <select
+                  value={bookingStart}
+                  onChange={(e) => setBookingStart(e.target.value)}
+                  className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
+                  required
+                  disabled={!user}
+                >
+                  <option value="">Select start time</option>
+                  {HOURS.map((hour) => (
+                    <option key={hour} value={`${hour.toString().padStart(2, '0')}:00`}>
+                      {formatTime(hour)}
+                    </option>
+                  ))}
+                </select>
+              </div>
+
+              <div>
+                <label className="block text-sm font-medium mb-1">End Time</label>
+                <select
+                  value={bookingEnd}
+                  onChange={(e) => setBookingEnd(e.target.value)}
+                  className="w-full border rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
+                  required
+                  disabled={!user}
+                >
+                  <option value="">Select end time</option>
+                  {HOURS.slice(1).map((hour) => (
+                    <option key={hour} value={`${hour.toString().padStart(2, '0')}:00`}>
+                      {formatTime(hour)}
+                    </option>
+                  ))}
+                  <option value="18:00">6:00 PM</option>
+                </select>
+              </div>
+
+              <div className="text-sm text-gray-500">
+                <p>• Minimum booking: 15 minutes</p>
+                <p>• Maximum booking: 4 hours</p>
+                <p>• Operating hours: 9:00 AM - 6:00 PM</p>
+              </div>
+
+              <button
+                type="submit"
+                disabled={submitting || !user}
+                className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50"
+              >
+                {submitting ? 'Booking...' : 'Book Room'}
+              </button>
+            </form>
+          </div>
+        )}
+
+        {isPastDate && (
+          <div className="bg-gray-100 rounded-lg p-4">
+            <p className="text-gray-600">
+              This is a past date. Bookings are read-only.
+            </p>
+          </div>
+        )}
+      </div>
+    </div>
+  );
+}
diff --git repository_after/client/src/pages/Rooms.jsx repository_after/client/src/pages/Rooms.jsx
new file mode 100644
index 0000000..6742822
--- /dev/null
+++ repository_after/client/src/pages/Rooms.jsx
@@ -0,0 +1,69 @@
+import { useState, useEffect } from 'react';
+import { Link } from 'react-router-dom';
+import { api } from '../api/client';
+
+export default function Rooms() {
+  const [rooms, setRooms] = useState([]);
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState('');
+
+  useEffect(() => {
+    loadRooms();
+  }, []);
+
+  const loadRooms = async () => {
+    try {
+      const data = await api.getRooms();
+      setRooms(data.rooms);
+    } catch (err) {
+      setError(err.message);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  if (loading) {
+    return <div className="text-center py-8">Loading rooms...</div>;
+  }
+
+  if (error) {
+    return (
+      <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
+        {error}
+      </div>
+    );
+  }
+
+  return (
+    <div>
+      <h1 className="text-2xl font-bold mb-6">Meeting Rooms</h1>
+
+      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
+        {rooms.map((room) => (
+          <Link
+            key={room.id}
+            to={`/rooms/${room.id}`}
+            className="block bg-white rounded-lg shadow hover:shadow-md transition-shadow"
+          >
+            <div className="p-6">
+              <div className="flex justify-between items-start mb-2">
+                <h2 className="text-xl font-semibold">{room.name}</h2>
+                <span
+                  className={`px-2 py-1 text-xs font-medium rounded ${
+                    room.status === 'available'
+                      ? 'bg-green-100 text-green-800'
+                      : 'bg-red-100 text-red-800'
+                  }`}
+                >
+                  {room.status}
+                </span>
+              </div>
+              <p className="text-gray-600">Capacity: {room.capacity} people</p>
+              <p className="text-blue-600 text-sm mt-4">View schedule →</p>
+            </div>
+          </Link>
+        ))}
+      </div>
+    </div>
+  );
+}
diff --git repository_after/client/tailwind.config.js repository_after/client/tailwind.config.js
new file mode 100644
index 0000000..dca8ba0
--- /dev/null
+++ repository_after/client/tailwind.config.js
@@ -0,0 +1,11 @@
+/** @type {import('tailwindcss').Config} */
+export default {
+  content: [
+    "./index.html",
+    "./src/**/*.{js,ts,jsx,tsx}",
+  ],
+  theme: {
+    extend: {},
+  },
+  plugins: [],
+}
diff --git repository_after/client/vite.config.js repository_after/client/vite.config.js
new file mode 100644
index 0000000..71b1df7
--- /dev/null
+++ repository_after/client/vite.config.js
@@ -0,0 +1,16 @@
+import { defineConfig } from 'vite';
+import react from '@vitejs/plugin-react';
+
+export default defineConfig({
+  plugins: [react()],
+  server: {
+    port: 5173,
+    host: true,
+    proxy: {
+      '/api': {
+        target: process.env.API_URL || 'http://localhost:3001',
+        changeOrigin: true,
+      },
+    },
+  },
+});
diff --git repository_after/server/Dockerfile repository_after/server/Dockerfile
new file mode 100644
index 0000000..084e8ec
--- /dev/null
+++ repository_after/server/Dockerfile
@@ -0,0 +1,12 @@
+FROM node:20-alpine
+
+WORKDIR /app
+
+COPY package*.json ./
+RUN npm install
+
+COPY . .
+
+EXPOSE 3001
+
+CMD ["npm", "start"]
diff --git repository_after/server/db.js repository_after/server/db.js
new file mode 100644
index 0000000..d08a248
--- /dev/null
+++ repository_after/server/db.js
@@ -0,0 +1,54 @@
+import pg from 'pg';
+
+const pool = new pg.Pool({
+  host: process.env.DB_HOST || 'localhost',
+  port: parseInt(process.env.DB_PORT || '5432'),
+  database: process.env.DB_NAME || 'booking_system',
+  user: process.env.DB_USER || 'postgres',
+  password: process.env.DB_PASSWORD || 'postgres',
+});
+
+export async function initDb() {
+  const client = await pool.connect();
+  try {
+    await client.query(`
+      CREATE EXTENSION IF NOT EXISTS btree_gist;
+
+      CREATE TABLE IF NOT EXISTS users (
+        id SERIAL PRIMARY KEY,
+        email VARCHAR(255) UNIQUE NOT NULL,
+        password_hash VARCHAR(255) NOT NULL,
+        name VARCHAR(255) NOT NULL,
+        created_at TIMESTAMP DEFAULT NOW()
+      );
+
+      CREATE TABLE IF NOT EXISTS rooms (
+        id SERIAL PRIMARY KEY,
+        name VARCHAR(255) NOT NULL,
+        capacity INTEGER NOT NULL
+      );
+
+      CREATE TABLE IF NOT EXISTS bookings (
+        id SERIAL PRIMARY KEY,
+        room_id INTEGER REFERENCES rooms(id) ON DELETE CASCADE,
+        user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
+        start_time TIMESTAMP NOT NULL,
+        end_time TIMESTAMP NOT NULL,
+        status VARCHAR(50) DEFAULT 'confirmed',
+        created_at TIMESTAMP DEFAULT NOW(),
+        CONSTRAINT no_overlap EXCLUDE USING gist (
+          room_id WITH =,
+          tsrange(start_time, end_time, '[)') WITH &&
+        ) WHERE (status = 'confirmed')
+      );
+
+      CREATE INDEX IF NOT EXISTS idx_bookings_room_time ON bookings(room_id, start_time, end_time);
+      CREATE INDEX IF NOT EXISTS idx_bookings_user ON bookings(user_id);
+    `);
+    console.log('Database initialized');
+  } finally {
+    client.release();
+  }
+}
+
+export default pool;
diff --git repository_after/server/index.js repository_after/server/index.js
new file mode 100644
index 0000000..b1d1746
--- /dev/null
+++ repository_after/server/index.js
@@ -0,0 +1,44 @@
+import express from 'express';
+import cors from 'cors';
+import { initDb } from './db.js';
+import authRoutes from './routes/auth.js';
+import roomRoutes from './routes/rooms.js';
+import bookingRoutes from './routes/bookings.js';
+
+const app = express();
+const PORT = process.env.PORT || 3001;
+
+// Middleware
+app.use(cors());
+app.use(express.json());
+
+// Health check
+app.get('/api/health', (req, res) => {
+  res.json({ status: 'ok', timestamp: new Date().toISOString() });
+});
+
+// Routes
+app.use('/api/auth', authRoutes);
+app.use('/api/rooms', roomRoutes);
+app.use('/api/bookings', bookingRoutes);
+
+// Error handler
+app.use((err, req, res, next) => {
+  console.error('Unhandled error:', err);
+  res.status(500).json({ error: 'Internal server error' });
+});
+
+// Start server
+async function start() {
+  try {
+    await initDb();
+    app.listen(PORT, () => {
+      console.log(`Server running on port ${PORT}`);
+    });
+  } catch (error) {
+    console.error('Failed to start server:', error);
+    process.exit(1);
+  }
+}
+
+start();
diff --git repository_after/server/init.sql repository_after/server/init.sql
new file mode 100644
index 0000000..b242213
--- /dev/null
+++ repository_after/server/init.sql
@@ -0,0 +1,2 @@
+-- Enable btree_gist extension for exclusion constraints
+CREATE EXTENSION IF NOT EXISTS btree_gist;
diff --git repository_after/server/jest.config.js repository_after/server/jest.config.js
new file mode 100644
index 0000000..2ef5d03
--- /dev/null
+++ repository_after/server/jest.config.js
@@ -0,0 +1,5 @@
+export default {
+  testEnvironment: 'node',
+  transform: {},
+  testTimeout: 30000,
+};
diff --git repository_after/server/middleware/auth.js repository_after/server/middleware/auth.js
new file mode 100644
index 0000000..d7ff797
--- /dev/null
+++ repository_after/server/middleware/auth.js
@@ -0,0 +1,41 @@
+import jwt from 'jsonwebtoken';
+import pool from '../db.js';
+
+const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';
+
+export function generateToken(user) {
+  return jwt.sign(
+    { id: user.id, email: user.email },
+    JWT_SECRET,
+    { expiresIn: '24h' }
+  );
+}
+
+export async function authenticate(req, res, next) {
+  const authHeader = req.headers.authorization;
+  
+  if (!authHeader || !authHeader.startsWith('Bearer ')) {
+    return res.status(401).json({ error: 'Authentication required' });
+  }
+
+  const token = authHeader.split(' ')[1];
+  
+  try {
+    const decoded = jwt.verify(token, JWT_SECRET);
+    const result = await pool.query(
+      'SELECT id, email, name, created_at FROM users WHERE id = $1',
+      [decoded.id]
+    );
+    
+    if (result.rows.length === 0) {
+      return res.status(401).json({ error: 'User not found' });
+    }
+    
+    req.user = result.rows[0];
+    next();
+  } catch (error) {
+    return res.status(401).json({ error: 'Invalid token' });
+  }
+}
+
+export { JWT_SECRET };
diff --git repository_after/server/package.json repository_after/server/package.json
new file mode 100644
index 0000000..03597bc
--- /dev/null
+++ repository_after/server/package.json
@@ -0,0 +1,22 @@
+{
+  "name": "booking-system-server",
+  "version": "1.0.0",
+  "type": "module",
+  "scripts": {
+    "start": "node index.js",
+    "dev": "node --watch index.js",
+    "seed": "node seed.js",
+    "test": "NODE_OPTIONS=--experimental-vm-modules jest --runInBand"
+  },
+  "dependencies": {
+    "bcryptjs": "^2.4.3",
+    "cors": "^2.8.5",
+    "express": "^4.18.2",
+    "jsonwebtoken": "^9.0.2",
+    "pg": "^8.11.3"
+  },
+  "devDependencies": {
+    "jest": "^29.7.0",
+    "supertest": "^6.3.3"
+  }
+}
diff --git repository_after/server/routes/auth.js repository_after/server/routes/auth.js
new file mode 100644
index 0000000..c8275a7
--- /dev/null
+++ repository_after/server/routes/auth.js
@@ -0,0 +1,90 @@
+import { Router } from "express";
+import bcrypt from "bcryptjs";
+import pool from "../db.js";
+import { generateToken, authenticate } from "../middleware/auth.js";
+
+const router = Router();
+
+router.post("/register", async (req, res) => {
+  try {
+    const { email, password, name } = req.body;
+
+    if (!email || !password || !name) {
+      return res
+        .status(400)
+        .json({ error: "Email, password, and name are required" });
+    }
+
+    if (password.length < 6) {
+      return res
+        .status(400)
+        .json({ error: "Password must be at least 6 characters" });
+    }
+
+    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+    if (!emailRegex.test(email)) {
+      return res.status(400).json({ error: "Invalid email format" });
+    }
+
+    const existing = await pool.query("SELECT id FROM users WHERE email = $1", [
+      email.toLowerCase(),
+    ]);
+    if (existing.rows.length > 0) {
+      return res.status(409).json({ error: "Email already registered" });
+    }
+
+    const passwordHash = await bcrypt.hash(password, 10);
+    const result = await pool.query(
+      "INSERT INTO users (email, password_hash, name) VALUES ($1, $2, $3) RETURNING id, email, name, created_at",
+      [email.toLowerCase(), passwordHash, name],
+    );
+
+    const user = result.rows[0];
+    const token = generateToken(user);
+
+    res.status(201).json({ user, token });
+  } catch (error) {
+    console.error("Registration error:", error);
+    res.status(500).json({ error: "Registration failed" });
+  }
+});
+
+router.post("/login", async (req, res) => {
+  try {
+    const { email, password } = req.body;
+
+    if (!email || !password) {
+      return res.status(400).json({ error: "Email and password are required" });
+    }
+
+    const result = await pool.query(
+      "SELECT id, email, name, password_hash, created_at FROM users WHERE email = $1",
+      [email.toLowerCase()],
+    );
+
+    if (result.rows.length === 0) {
+      return res.status(401).json({ error: "Invalid email or password" });
+    }
+
+    const user = result.rows[0];
+    const validPassword = await bcrypt.compare(password, user.password_hash);
+
+    if (!validPassword) {
+      return res.status(401).json({ error: "Invalid email or password" });
+    }
+
+    const token = generateToken(user);
+    const { password_hash, ...userWithoutPassword } = user;
+
+    res.json({ user: userWithoutPassword, token });
+  } catch (error) {
+    console.error("Login error:", error);
+    res.status(500).json({ error: "Login failed" });
+  }
+});
+
+router.get("/me", authenticate, (req, res) => {
+  res.json({ user: req.user });
+});
+
+export default router;
diff --git repository_after/server/routes/bookings.js repository_after/server/routes/bookings.js
new file mode 100644
index 0000000..c0d1926
--- /dev/null
+++ repository_after/server/routes/bookings.js
@@ -0,0 +1,249 @@
+import { Router } from "express";
+import pool from "../db.js";
+import { authenticate } from "../middleware/auth.js";
+
+const router = Router();
+
+const OPERATING_HOURS = { start: 9, end: 18 }; // 9 AM - 6 PM
+const MIN_DURATION_MINUTES = 15;
+const MAX_DURATION_HOURS = 4;
+
+function isWeekday(date) {
+  const day = date.getUTCDay();
+  return day >= 1 && day <= 5;
+}
+
+function isWithinOperatingHours(startTime, endTime) {
+  const startHour = startTime.getUTCHours() + startTime.getUTCMinutes() / 60;
+  const endHour = endTime.getUTCHours() + endTime.getUTCMinutes() / 60;
+
+  // Handle midnight case - endHour of 0 means it ends at midnight, not allowed
+  if (
+    endHour === 0 &&
+    endTime.getUTCMinutes() === 0 &&
+    startTime.getUTCDate() !== endTime.getUTCDate()
+  ) {
+    return false;
+  }
+
+  return startHour >= OPERATING_HOURS.start && endHour <= OPERATING_HOURS.end;
+}
+
+function isSameDay(date1, date2) {
+  return (
+    date1.getUTCFullYear() === date2.getUTCFullYear() &&
+    date1.getUTCMonth() === date2.getUTCMonth() &&
+    date1.getUTCDate() === date2.getUTCDate()
+  );
+}
+
+router.post("/", authenticate, async (req, res) => {
+  const client = await pool.connect();
+
+  try {
+    const { roomId, startTime, endTime } = req.body;
+    const userId = req.user.id;
+
+    if (!roomId || !startTime || !endTime) {
+      return res
+        .status(400)
+        .json({ error: "roomId, startTime, and endTime are required" });
+    }
+
+    const start = new Date(startTime);
+    const end = new Date(endTime);
+    const now = new Date();
+
+    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
+      return res.status(400).json({ error: "Invalid date format" });
+    }
+
+    if (start < now) {
+      return res.status(400).json({ error: "Cannot book in the past" });
+    }
+
+    if (end <= start) {
+      return res
+        .status(400)
+        .json({ error: "End time must be after start time" });
+    }
+
+    if (!isSameDay(start, end)) {
+      return res.status(400).json({ error: "Bookings cannot cross midnight" });
+    }
+
+    if (!isWeekday(start)) {
+      return res
+        .status(400)
+        .json({ error: "Bookings are only allowed Monday through Friday" });
+    }
+
+    if (!isWithinOperatingHours(start, end)) {
+      return res.status(400).json({
+        error: "Bookings must be within operating hours (9:00 AM - 6:00 PM)",
+      });
+    }
+
+    // Check duration
+    const durationMinutes = (end - start) / (1000 * 60);
+    if (durationMinutes < MIN_DURATION_MINUTES) {
+      return res.status(400).json({
+        error: `Minimum booking duration is ${MIN_DURATION_MINUTES} minutes`,
+      });
+    }
+
+    const durationHours = durationMinutes / 60;
+    if (durationHours > MAX_DURATION_HOURS) {
+      return res.status(400).json({
+        error: `Maximum booking duration is ${MAX_DURATION_HOURS} hours`,
+      });
+    }
+
+    // Verify room exists
+    const roomResult = await client.query(
+      "SELECT id, name FROM rooms WHERE id = $1",
+      [roomId],
+    );
+    if (roomResult.rows.length === 0) {
+      return res.status(404).json({ error: "Room not found" });
+    }
+
+    // Start transaction for booking
+    await client.query("BEGIN");
+
+    // Check for overlapping bookings (using range overlap: [) means start inclusive, end exclusive)
+    // This allows back-to-back bookings like 10:00-11:00 and 11:00-12:00
+    const overlapResult = await client.query(
+      `
+      SELECT id, start_time, end_time 
+      FROM bookings 
+      WHERE room_id = $1 
+        AND status = 'confirmed'
+        AND start_time < $3 
+        AND end_time > $2
+      FOR UPDATE
+    `,
+      [roomId, start, end],
+    );
+
+    if (overlapResult.rows.length > 0) {
+      await client.query("ROLLBACK");
+      return res.status(409).json({
+        error: "Time slot conflicts with an existing booking",
+      });
+    }
+
+    // Create the booking
+    const bookingResult = await client.query(
+      `
+      INSERT INTO bookings (room_id, user_id, start_time, end_time, status)
+      VALUES ($1, $2, $3, $4, 'confirmed')
+      RETURNING id, room_id, start_time, end_time, status, created_at
+    `,
+      [roomId, userId, start, end],
+    );
+
+    await client.query("COMMIT");
+
+    const booking = bookingResult.rows[0];
+    booking.room_name = roomResult.rows[0].name;
+
+    res.status(201).json({
+      message: "Booking confirmed successfully",
+      booking,
+    });
+  } catch (error) {
+    await client.query("ROLLBACK");
+
+    // Handle unique constraint violation (race condition catch)
+    if (error.code === "23P01") {
+      return res.status(409).json({
+        error: "Time slot conflicts with an existing booking",
+      });
+    }
+
+    console.error("Booking error:", error);
+    res.status(500).json({ error: "Failed to create booking" });
+  } finally {
+    client.release();
+  }
+});
+
+// GET /api/bookings/mine - Get current user's bookings
+router.get("/mine", authenticate, async (req, res) => {
+  try {
+    const userId = req.user.id;
+
+    const result = await pool.query(
+      `
+      SELECT 
+        b.id,
+        b.room_id,
+        r.name as room_name,
+        b.start_time,
+        b.end_time,
+        b.status,
+        b.created_at
+      FROM bookings b
+      JOIN rooms r ON b.room_id = r.id
+      WHERE b.user_id = $1
+      ORDER BY b.start_time DESC
+    `,
+      [userId],
+    );
+
+    res.json({ bookings: result.rows });
+  } catch (error) {
+    console.error("Error fetching user bookings:", error);
+    res.status(500).json({ error: "Failed to fetch bookings" });
+  }
+});
+
+// DELETE /api/bookings/:id - Cancel a booking
+router.delete("/:id", authenticate, async (req, res) => {
+  try {
+    const bookingId = parseInt(req.params.id);
+    const userId = req.user.id;
+
+    // Get the booking
+    const bookingResult = await pool.query(
+      "SELECT id, user_id, start_time, status FROM bookings WHERE id = $1",
+      [bookingId],
+    );
+
+    if (bookingResult.rows.length === 0) {
+      return res.status(404).json({ error: "Booking not found" });
+    }
+
+    const booking = bookingResult.rows[0];
+
+    // Check ownership
+    if (booking.user_id !== userId) {
+      return res
+        .status(403)
+        .json({ error: "You can only cancel your own bookings" });
+    }
+
+    // Check if already cancelled
+    if (booking.status === "cancelled") {
+      return res.status(400).json({ error: "Booking is already cancelled" });
+    }
+
+    // Cannot cancel past bookings
+    if (new Date(booking.start_time) < new Date()) {
+      return res.status(400).json({ error: "Cannot cancel past bookings" });
+    }
+
+    // Cancel the booking
+    await pool.query("UPDATE bookings SET status = 'cancelled' WHERE id = $1", [
+      bookingId,
+    ]);
+
+    res.json({ message: "Booking cancelled successfully" });
+  } catch (error) {
+    console.error("Error cancelling booking:", error);
+    res.status(500).json({ error: "Failed to cancel booking" });
+  }
+});
+
+export default router;
diff --git repository_after/server/routes/rooms.js repository_after/server/routes/rooms.js
new file mode 100644
index 0000000..ae0a679
--- /dev/null
+++ repository_after/server/routes/rooms.js
@@ -0,0 +1,89 @@
+import { Router } from 'express';
+import pool from '../db.js';
+
+const router = Router();
+
+// GET /api/rooms - List all rooms with current availability
+router.get('/', async (req, res) => {
+  try {
+    const now = new Date();
+    
+    const result = await pool.query(`
+      SELECT 
+        r.id,
+        r.name,
+        r.capacity,
+        CASE 
+          WHEN EXISTS (
+            SELECT 1 FROM bookings b 
+            WHERE b.room_id = r.id 
+              AND b.status = 'confirmed'
+              AND b.start_time <= $1 
+              AND b.end_time > $1
+          ) THEN 'occupied'
+          ELSE 'available'
+        END as status
+      FROM rooms r
+      ORDER BY r.id
+    `, [now]);
+
+    res.json({ rooms: result.rows });
+  } catch (error) {
+    console.error('Error fetching rooms:', error);
+    res.status(500).json({ error: 'Failed to fetch rooms' });
+  }
+});
+
+// GET /api/rooms/:id/bookings?date=YYYY-MM-DD - Get bookings for a room on a specific date
+router.get('/:id/bookings', async (req, res) => {
+  try {
+    const roomId = parseInt(req.params.id);
+    const { date } = req.query;
+
+    if (!date) {
+      return res.status(400).json({ error: 'Date parameter is required (YYYY-MM-DD)' });
+    }
+
+    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
+    if (!dateRegex.test(date)) {
+      return res.status(400).json({ error: 'Invalid date format. Use YYYY-MM-DD' });
+    }
+
+    // Verify room exists
+    const roomResult = await pool.query('SELECT id, name, capacity FROM rooms WHERE id = $1', [roomId]);
+    if (roomResult.rows.length === 0) {
+      return res.status(404).json({ error: 'Room not found' });
+    }
+
+    // Get bookings for the specified date
+    const startOfDay = `${date}T00:00:00`;
+    const endOfDay = `${date}T23:59:59`;
+
+    const bookingsResult = await pool.query(`
+      SELECT 
+        b.id,
+        b.start_time,
+        b.end_time,
+        b.status,
+        u.name as booker_name
+      FROM bookings b
+      JOIN users u ON b.user_id = u.id
+      WHERE b.room_id = $1
+        AND b.status = 'confirmed'
+        AND b.start_time >= $2
+        AND b.start_time < $3
+      ORDER BY b.start_time
+    `, [roomId, startOfDay, endOfDay]);
+
+    res.json({
+      room: roomResult.rows[0],
+      date,
+      bookings: bookingsResult.rows
+    });
+  } catch (error) {
+    console.error('Error fetching room bookings:', error);
+    res.status(500).json({ error: 'Failed to fetch room bookings' });
+  }
+});
+
+export default router;
diff --git repository_after/server/seed.js repository_after/server/seed.js
new file mode 100644
index 0000000..50f15a5
--- /dev/null
+++ repository_after/server/seed.js
@@ -0,0 +1,44 @@
+import bcrypt from 'bcryptjs';
+import pool, { initDb } from './db.js';
+
+async function seed() {
+  await initDb();
+  
+  const client = await pool.connect();
+  try {
+    // Clear existing data
+    await client.query('DELETE FROM bookings');
+    await client.query('DELETE FROM users');
+    await client.query('DELETE FROM rooms');
+    
+    // Reset sequences
+    await client.query('ALTER SEQUENCE users_id_seq RESTART WITH 1');
+    await client.query('ALTER SEQUENCE rooms_id_seq RESTART WITH 1');
+    await client.query('ALTER SEQUENCE bookings_id_seq RESTART WITH 1');
+
+    // Insert rooms
+    await client.query(`
+      INSERT INTO rooms (name, capacity) VALUES
+        ('Boardroom', 10),
+        ('Focus Room', 4),
+        ('Phone Booth', 2)
+    `);
+    console.log('Rooms seeded');
+
+    // Insert test users
+    const passwordHash = await bcrypt.hash('password123', 10);
+    await client.query(`
+      INSERT INTO users (email, password_hash, name) VALUES
+        ('alice@test.com', $1, 'Alice Johnson'),
+        ('bob@test.com', $1, 'Bob Smith')
+    `, [passwordHash]);
+    console.log('Users seeded');
+
+    console.log('Seed completed successfully');
+  } finally {
+    client.release();
+    await pool.end();
+  }
+}
+
+seed().catch(console.error);
diff --git repository_after/server/tests/bookings.test.js repository_after/server/tests/bookings.test.js
new file mode 100644
index 0000000..51c1891
--- /dev/null
+++ repository_after/server/tests/bookings.test.js
@@ -0,0 +1,577 @@
+import request from "supertest";
+import express from "express";
+import cors from "cors";
+import bcrypt from "bcryptjs";
+import fs from "fs";
+import pool, { initDb } from "../db.js";
+import authRoutes from "../routes/auth.js";
+import roomRoutes from "../routes/rooms.js";
+import bookingRoutes from "../routes/bookings.js";
+
+let app;
+let testUsers = {};
+
+// Helper function to get next weekday in UTC
+function getNextWeekday(daysAhead = 1) {
+  const now = new Date();
+  let date = new Date(
+    Date.UTC(
+      now.getUTCFullYear(),
+      now.getUTCMonth(),
+      now.getUTCDate() + daysAhead,
+      0,
+      0,
+      0,
+      0,
+    ),
+  );
+
+  // If weekend, move to Monday
+  while (date.getUTCDay() === 0 || date.getUTCDay() === 6) {
+    date = new Date(date.getTime() + 24 * 60 * 60 * 1000);
+  }
+
+  return date;
+}
+
+beforeAll(async () => {
+  // Initialize app
+  app = express();
+  app.use(cors());
+  app.use(express.json());
+  app.use("/api/auth", authRoutes);
+  app.use("/api/rooms", roomRoutes);
+  app.use("/api/bookings", bookingRoutes);
+
+  // Initialize database
+  await initDb();
+
+  // Clear and seed test data
+  await pool.query("DELETE FROM bookings");
+  await pool.query("DELETE FROM users");
+  await pool.query("DELETE FROM rooms");
+  await pool.query("ALTER SEQUENCE users_id_seq RESTART WITH 1");
+  await pool.query("ALTER SEQUENCE rooms_id_seq RESTART WITH 1");
+  await pool.query("ALTER SEQUENCE bookings_id_seq RESTART WITH 1");
+
+  // Insert rooms
+  await pool.query(`
+    INSERT INTO rooms (name, capacity) VALUES
+      ('Boardroom', 10),
+      ('Focus Room', 4),
+      ('Phone Booth', 2)
+  `);
+
+  // Insert test users
+  const passwordHash = await bcrypt.hash("password123", 10);
+  const userResult = await pool.query(
+    `
+    INSERT INTO users (email, password_hash, name) VALUES
+      ('alice@test.com', $1, 'Alice Johnson'),
+      ('bob@test.com', $1, 'Bob Smith')
+    RETURNING id, email
+  `,
+    [passwordHash],
+  );
+
+  const aliceLogin = await request(app)
+    .post("/api/auth/login")
+    .send({ email: "alice@test.com", password: "password123" });
+
+  const bobLogin = await request(app)
+    .post("/api/auth/login")
+    .send({ email: "bob@test.com", password: "password123" });
+
+  testUsers.alice = { id: userResult.rows[0].id, token: aliceLogin.body.token };
+  testUsers.bob = { id: userResult.rows[1].id, token: bobLogin.body.token };
+});
+
+afterAll(async () => {
+  await pool.end();
+});
+
+beforeEach(async () => {
+  await pool.query("DELETE FROM bookings");
+});
+
+describe("Requirement 1: Overlapping bookings must be rejected atomically", () => {
+  test("30 concurrent booking attempts should result in exactly 1 success", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(9, 0, 0, 0);
+    const startTime = tomorrow.toISOString();
+    const endTime = new Date(tomorrow.getTime() + 60 * 60 * 1000).toISOString();
+
+    fs.writeFileSync(
+      "/tmp/test-debug.txt",
+      `Test date: ${startTime}, UTC Day: ${tomorrow.getUTCDay()}\n`,
+    );
+
+    const promises = Array(30)
+      .fill(null)
+      .map(() =>
+        request(app)
+          .post("/api/bookings")
+          .set("Authorization", `Bearer ${testUsers.alice.token}`)
+          .send({ roomId: 1, startTime, endTime }),
+      );
+
+    const results = await Promise.all(promises);
+    const successes = results.filter((r) => r.status === 201);
+    const conflicts = results.filter((r) => r.status === 409);
+    const errors = results.filter((r) => r.status === 400);
+
+    fs.appendFileSync(
+      "/tmp/test-debug.txt",
+      `Results - Successes: ${successes.length}, Conflicts: ${conflicts.length}, Errors: ${errors.length}\n`,
+    );
+    if (errors.length > 0) {
+      fs.appendFileSync(
+        "/tmp/test-debug.txt",
+        `Sample error: ${JSON.stringify(errors[0].body)}\n`,
+      );
+    }
+
+    expect(successes.length).toBe(1);
+    expect(conflicts.length).toBe(29);
+
+    const dbResult = await pool.query(
+      "SELECT COUNT(*) FROM bookings WHERE status = $1",
+      ["confirmed"],
+    );
+    expect(parseInt(dbResult.rows[0].count)).toBe(1);
+  });
+});
+
+describe("Back-to-back bookings must be allowed", () => {
+  test("Booking 10:00-11:00 after 9:00-10:00 should succeed", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(9, 0, 0, 0);
+
+    const booking1Start = tomorrow.toISOString();
+    const booking1End = new Date(
+      tomorrow.getTime() + 60 * 60 * 1000,
+    ).toISOString();
+    const booking2Start = booking1End;
+    const booking2End = new Date(
+      tomorrow.getTime() + 2 * 60 * 60 * 1000,
+    ).toISOString();
+
+    const res1 = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({ roomId: 1, startTime: booking1Start, endTime: booking1End });
+
+    if (res1.status !== 201) {
+      console.log("First booking failed:", res1.status, res1.body);
+      console.log(
+        "Date:",
+        tomorrow.toISOString(),
+        "UTC Day:",
+        tomorrow.getUTCDay(),
+      );
+    }
+
+    expect(res1.status).toBe(201);
+
+    const res2 = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.bob.token}`)
+      .send({ roomId: 1, startTime: booking2Start, endTime: booking2End });
+
+    expect(res2.status).toBe(201);
+  });
+
+  test("Overlapping booking should be rejected", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(9, 0, 0, 0);
+
+    const booking1Start = tomorrow.toISOString();
+    const booking1End = new Date(
+      tomorrow.getTime() + 60 * 60 * 1000,
+    ).toISOString();
+    const booking2Start = new Date(
+      tomorrow.getTime() + 30 * 60 * 1000,
+    ).toISOString();
+    const booking2End = new Date(
+      tomorrow.getTime() + 90 * 60 * 1000,
+    ).toISOString();
+
+    await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({ roomId: 1, startTime: booking1Start, endTime: booking1End });
+
+    const res2 = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.bob.token}`)
+      .send({ roomId: 1, startTime: booking2Start, endTime: booking2End });
+
+    expect(res2.status).toBe(409);
+  });
+});
+
+describe("Boundary bookings must be handled correctly", () => {
+  test("Booking starting at exactly 9:00 AM should be accepted", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(9, 0, 0, 0);
+
+    const res = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(tomorrow.getTime() + 60 * 60 * 1000).toISOString(),
+      });
+
+    expect(res.status).toBe(201);
+  });
+
+  test("Booking ending at exactly 6:00 PM should be accepted", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(17, 0, 0, 0);
+
+    const res = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(tomorrow.getTime() + 60 * 60 * 1000).toISOString(),
+      });
+
+    expect(res.status).toBe(201);
+  });
+
+  test("Booking from 5:30 PM to 6:30 PM should be rejected", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(17, 30, 0, 0);
+
+    const res = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(tomorrow.getTime() + 60 * 60 * 1000).toISOString(),
+      });
+
+    expect(res.status).toBe(400);
+    expect(res.body.error).toMatch(/operating hours/i);
+  });
+});
+
+describe("Past bookings must be rejected", () => {
+  test("Booking in the past should return 400", async () => {
+    const past = new Date();
+    past.setUTCHours(past.getUTCHours() - 2);
+
+    const res = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: past.toISOString(),
+        endTime: new Date(past.getTime() + 60 * 60 * 1000).toISOString(),
+      });
+
+    expect(res.status).toBe(400);
+    expect(res.body.error).toMatch(/past/i);
+  });
+});
+
+describe("Duration constraints must be enforced", () => {
+  test("Booking shorter than 15 minutes should be rejected", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(10, 0, 0, 0);
+
+    const res = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(tomorrow.getTime() + 10 * 60 * 1000).toISOString(),
+      });
+
+    expect(res.status).toBe(400);
+    expect(res.body.error).toMatch(/15 minutes/i);
+  });
+
+  test("Booking longer than 4 hours should be rejected", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(9, 0, 0, 0);
+
+    const res = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(
+          tomorrow.getTime() + 5 * 60 * 60 * 1000,
+        ).toISOString(),
+      });
+
+    expect(res.status).toBe(400);
+    expect(res.body.error).toMatch(/4 hours/i);
+  });
+
+  test("Booking of exactly 15 minutes should be accepted", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(10, 0, 0, 0);
+
+    const res = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(tomorrow.getTime() + 15 * 60 * 1000).toISOString(),
+      });
+
+    expect(res.status).toBe(201);
+  });
+});
+
+describe("Midnight crossing must be prevented", () => {
+  test("Booking crossing midnight should be rejected", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(23, 0, 0, 0);
+
+    const res = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(
+          tomorrow.getTime() + 2 * 60 * 60 * 1000,
+        ).toISOString(),
+      });
+
+    expect(res.status).toBe(400);
+    expect(res.body.error).toMatch(/midnight/i);
+  });
+});
+
+describe("User ownership must be enforced for cancellation", () => {
+  test("User B cannot cancel User A booking", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(10, 0, 0, 0);
+
+    const createRes = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(tomorrow.getTime() + 60 * 60 * 1000).toISOString(),
+      });
+
+    const bookingId = createRes.body.booking.id;
+
+    const deleteRes = await request(app)
+      .delete(`/api/bookings/${bookingId}`)
+      .set("Authorization", `Bearer ${testUsers.bob.token}`);
+
+    expect(deleteRes.status).toBe(403);
+  });
+
+  test("User A can cancel their own booking", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(10, 0, 0, 0);
+
+    const createRes = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(tomorrow.getTime() + 60 * 60 * 1000).toISOString(),
+      });
+
+    const bookingId = createRes.body.booking.id;
+
+    const deleteRes = await request(app)
+      .delete(`/api/bookings/${bookingId}`)
+      .set("Authorization", `Bearer ${testUsers.alice.token}`);
+
+    expect(deleteRes.status).toBe(200);
+  });
+});
+
+describe("Past booking cancellation must be prevented", () => {
+  test("Cannot cancel booking that has already started", async () => {
+    // Create a booking that starts in the past
+    const past = new Date();
+    past.setUTCHours(past.getUTCHours() - 1);
+
+    const bookingResult = await pool.query(
+      `
+      INSERT INTO bookings (room_id, user_id, start_time, end_time, status)
+      VALUES (1, $1, $2, $3, 'confirmed')
+      RETURNING id
+    `,
+      [
+        testUsers.alice.id,
+        past.toISOString(),
+        new Date(past.getTime() + 60 * 60 * 1000).toISOString(),
+      ],
+    );
+
+    const bookingId = bookingResult.rows[0].id;
+
+    const deleteRes = await request(app)
+      .delete(`/api/bookings/${bookingId}`)
+      .set("Authorization", `Bearer ${testUsers.alice.token}`);
+
+    expect(deleteRes.status).toBe(400);
+    expect(deleteRes.body.error).toMatch(/past/i);
+  });
+});
+
+describe("Double cancellation must be handled safely", () => {
+  test("Second cancellation should return 400", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(10, 0, 0, 0);
+
+    const createRes = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(tomorrow.getTime() + 60 * 60 * 1000).toISOString(),
+      });
+
+    const bookingId = createRes.body.booking.id;
+
+    // First cancellation
+    const deleteRes1 = await request(app)
+      .delete(`/api/bookings/${bookingId}`)
+      .set("Authorization", `Bearer ${testUsers.alice.token}`);
+
+    expect(deleteRes1.status).toBe(200);
+
+    // Second cancellation
+    const deleteRes2 = await request(app)
+      .delete(`/api/bookings/${bookingId}`)
+      .set("Authorization", `Bearer ${testUsers.alice.token}`);
+
+    expect(deleteRes2.status).toBe(400);
+    expect(deleteRes2.body.error).toMatch(/already cancelled/i);
+  });
+});
+
+describe("Invalid room booking must be rejected", () => {
+  test("Booking non-existent room should return 404", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(10, 0, 0, 0);
+
+    const res = await request(app)
+      .post("/api/bookings")
+      .set("Authorization", `Bearer ${testUsers.alice.token}`)
+      .send({
+        roomId: 999,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(tomorrow.getTime() + 60 * 60 * 1000).toISOString(),
+      });
+
+    expect(res.status).toBe(404);
+    expect(res.body.error).toMatch(/room not found/i);
+
+    const dbResult = await pool.query("SELECT COUNT(*) FROM bookings");
+    expect(parseInt(dbResult.rows[0].count)).toBe(0);
+  });
+});
+
+describe("Authentication must be required", () => {
+  test("POST /api/bookings without token should return 401", async () => {
+    const tomorrow = new Date();
+    tomorrow.setDate(tomorrow.getDate() + 1);
+    tomorrow.setUTCHours(10, 0, 0, 0);
+
+    const res = await request(app)
+      .post("/api/bookings")
+      .send({
+        roomId: 1,
+        startTime: tomorrow.toISOString(),
+        endTime: new Date(tomorrow.getTime() + 60 * 60 * 1000).toISOString(),
+      });
+
+    expect(res.status).toBe(401);
+  });
+
+  test("GET /api/bookings/mine without token should return 401", async () => {
+    const res = await request(app).get("/api/bookings/mine");
+    expect(res.status).toBe(401);
+  });
+
+  test("DELETE /api/bookings/:id without token should return 401", async () => {
+    const res = await request(app).delete("/api/bookings/1");
+    expect(res.status).toBe(401);
+  });
+});
+
+describe("Database seeding", () => {
+  test("3 rooms should exist", async () => {
+    const res = await request(app).get("/api/rooms");
+    expect(res.status).toBe(200);
+    expect(res.body.rooms).toHaveLength(3);
+    expect(res.body.rooms[0].name).toBe("Boardroom");
+    expect(res.body.rooms[0].capacity).toBe(10);
+    expect(res.body.rooms[1].name).toBe("Focus Room");
+    expect(res.body.rooms[1].capacity).toBe(4);
+    expect(res.body.rooms[2].name).toBe("Phone Booth");
+    expect(res.body.rooms[2].capacity).toBe(2);
+  });
+
+  test("Test users should be able to login", async () => {
+    const aliceRes = await request(app)
+      .post("/api/auth/login")
+      .send({ email: "alice@test.com", password: "password123" });
+
+    expect(aliceRes.status).toBe(200);
+    expect(aliceRes.body.token).toBeDefined();
+
+    const bobRes = await request(app)
+      .post("/api/auth/login")
+      .send({ email: "bob@test.com", password: "password123" });
+
+    expect(bobRes.status).toBe(200);
+    expect(bobRes.body.token).toBeDefined();
+  });
+});
+
+describe("Concurrent booking stress test", () => {
+  test("10 simultaneous requests should result in exactly 1 booking", async () => {
+    const tomorrow = getNextWeekday(1);
+    tomorrow.setUTCHours(14, 0, 0, 0);
+    const startTime = tomorrow.toISOString();
+    const endTime = new Date(tomorrow.getTime() + 60 * 60 * 1000).toISOString();
+
+    const promises = Array(10)
+      .fill(null)
+      .map(() =>
+        request(app)
+          .post("/api/bookings")
+          .set("Authorization", `Bearer ${testUsers.alice.token}`)
+          .send({ roomId: 1, startTime, endTime }),
+      );
+
+    const results = await Promise.all(promises);
+    const successes = results.filter((r) => r.status === 201);
+    const conflicts = results.filter((r) => r.status === 409);
+
+    expect(successes.length).toBe(1);
+    expect(conflicts.length).toBe(9);
+
+    // Verify database has exactly 1 booking
+    const dbResult = await pool.query(
+      "SELECT COUNT(*) FROM bookings WHERE status = $1",
+      ["confirmed"],
+    );
+    expect(parseInt(dbResult.rows[0].count)).toBe(1);
+  });
+});
