diff --git a/repository_before/__init__.py b/repository_before/__init__.py
deleted file mode 100644
index e69de29b..00000000
diff --git a/repository_after/app/actions.ts b/repository_after/app/actions.ts
new file mode 100644
index 00000000..4c0de22e
--- /dev/null
+++ b/repository_after/app/actions.ts
@@ -0,0 +1,13 @@
+"use server";
+
+import { revalidatePath } from "next/cache";
+import { prisma } from "../lib/prisma";
+import { assignPendingPackageToCourier } from "../lib/core";
+
+export async function assignPackageAction(input: {
+  courierId: string;
+  packageId: string;
+}) {
+  await assignPendingPackageToCourier(prisma, input);
+  revalidatePath("/dashboard");
+}
diff --git a/repository_after/app/dashboard/AssignPanel.tsx b/repository_after/app/dashboard/AssignPanel.tsx
new file mode 100644
index 00000000..fbf70a29
--- /dev/null
+++ b/repository_after/app/dashboard/AssignPanel.tsx
@@ -0,0 +1,93 @@
+"use client";
+
+import { useMemo, useState, useTransition } from "react";
+import { assignPackageAction } from "../actions";
+
+type CourierRow = {
+  id: string;
+  name: string;
+  isActive: boolean;
+  remainingCapacityKg: number;
+};
+
+type PendingPackageRow = {
+  id: string;
+  description: string;
+  weightKg: number;
+};
+
+export default function AssignPanel(props: {
+  couriers: CourierRow[];
+  pendingPackages: PendingPackageRow[];
+}) {
+  const [selectedPackageId, setSelectedPackageId] = useState<string>("");
+  const [isPending, startTransition] = useTransition();
+
+  const selectedPackage = useMemo(() => {
+    return (
+      props.pendingPackages.find((p) => p.id === selectedPackageId) ?? null
+    );
+  }, [props.pendingPackages, selectedPackageId]);
+
+  return (
+    <section style={{ display: "grid", gap: 12 }}>
+      <label>
+        Pending Package
+        <select
+          value={selectedPackageId}
+          onChange={(e) => setSelectedPackageId(e.target.value)}
+          style={{ marginLeft: 8 }}
+        >
+          <option value="">Select a package</option>
+          {props.pendingPackages.map((p) => (
+            <option key={p.id} value={p.id}>
+              {p.description} ({p.weightKg}kg)
+            </option>
+          ))}
+        </select>
+      </label>
+
+      <div style={{ display: "grid", gap: 8 }}>
+        {props.couriers.map((c) => {
+          const tooHeavy = selectedPackage
+            ? selectedPackage.weightKg > c.remainingCapacityKg
+            : true;
+          const disabled =
+            isPending || !c.isActive || !selectedPackage || tooHeavy;
+
+          return (
+            <div key={c.id} style={{ border: "1px solid #ddd", padding: 12 }}>
+              <div
+                style={{
+                  display: "flex",
+                  justifyContent: "space-between",
+                  gap: 8,
+                }}
+              >
+                <div>
+                  <div>{c.name}</div>
+                  <div>Remaining Capacity: {c.remainingCapacityKg}kg</div>
+                  {!c.isActive && <div>Inactive</div>}
+                </div>
+                <button
+                  disabled={disabled}
+                  onClick={() => {
+                    if (!selectedPackage) return;
+                    startTransition(async () => {
+                      await assignPackageAction({
+                        courierId: c.id,
+                        packageId: selectedPackage.id,
+                      });
+                    });
+                  }}
+                >
+                  Assign
+                </button>
+              </div>
+            </div>
+          );
+        })}
+      </div>
+    </section>
+  );
+}
diff --git a/repository_after/app/dashboard/page.tsx b/repository_after/app/dashboard/page.tsx
new file mode 100644
index 00000000..23e1b6b0
--- /dev/null
+++ b/repository_after/app/dashboard/page.tsx
@@ -0,0 +1,20 @@
+import { prisma } from "../../lib/prisma";
+import {
+  listCouriersWithRemainingCapacity,
+  listPendingPackages,
+} from "../../lib/queries";
+import AssignPanel from "./AssignPanel";
+
+export default async function DashboardPage() {
+  const [couriers, pendingPackages] = await Promise.all([
+    listCouriersWithRemainingCapacity(prisma),
+    listPendingPackages(prisma),
+  ]);
+
+  return (
+    <main style={{ padding: 16, display: "grid", gap: 16 }}>
+      <h1>UrbanCargo Dispatcher</h1>
+      <AssignPanel couriers={couriers} pendingPackages={pendingPackages} />
+    </main>
+  );
+}
diff --git a/repository_after/app/layout.tsx b/repository_after/app/layout.tsx
new file mode 100644
index 00000000..225b6038
--- /dev/null
+++ b/repository_after/app/layout.tsx
@@ -0,0 +1,11 @@
+export default function RootLayout({
+  children,
+}: {
+  children: React.ReactNode;
+}) {
+  return (
+    <html lang="en">
+      <body>{children}</body>
+    </html>
+  );
+}
diff --git a/repository_after/app/page.tsx b/repository_after/app/page.tsx
new file mode 100644
index 00000000..e6359374
--- /dev/null
+++ b/repository_after/app/page.tsx
@@ -0,0 +1,3 @@
+import DashboardPage from "./dashboard/page";
+
+export default DashboardPage;
diff --git a/repository_after/lib/core.ts b/repository_after/lib/core.ts
new file mode 100644
index 00000000..c274d8cd
--- /dev/null
+++ b/repository_after/lib/core.ts
@@ -0,0 +1,122 @@
+import type { PrismaClient } from "@prisma/client";
+
+export const CAPACITY_LIMIT_KG = 25;
+
+export class CapacityExceededError extends Error {
+  readonly code = "CAPACITY_EXCEEDED";
+  constructor() {
+    super("Capacity Exceeded");
+  }
+}
+
+export class PackageAlreadyAssignedError extends Error {
+  readonly code = "PACKAGE_ALREADY_ASSIGNED";
+  constructor() {
+    super("Package Already Assigned");
+  }
+}
+
+export class NegativeWeightError extends Error {
+  readonly code = "NEGATIVE_WEIGHT";
+  constructor() {
+    super("Negative Package Weight");
+  }
+}
+
+export class InactiveCourierError extends Error {
+  readonly code = "INACTIVE_COURIER";
+  constructor() {
+    super("Courier Inactive");
+  }
+}
+
+export async function createPackage(
+  prisma: PrismaClient,
+  input: { description: string; weightKg: number }
+) {
+  if (input.weightKg < 0) {
+    throw new NegativeWeightError();
+  }
+  return prisma.package.create({
+    data: {
+      description: input.description,
+      weightKg: input.weightKg,
+      status: "PENDING",
+    },
+  });
+}
+
+export async function getCourierRemainingCapacityKg(
+  prisma: PrismaClient,
+  courierId: string
+) {
+  const agg = await prisma.package.aggregate({
+    where: { courierId, status: "ASSIGNED" },
+    _sum: { weightKg: true },
+  });
+
+  const currentLoad = agg._sum.weightKg ?? 0;
+  return Math.max(0, CAPACITY_LIMIT_KG - currentLoad);
+}
+
+export async function assignPendingPackageToCourier(
+  prisma: PrismaClient,
+  params: { courierId: string; packageId: string }
+) {
+  const { courierId, packageId } = params;
+
+  return prisma.$transaction(async (tx) => {
+    const courier = await tx.courier.findUnique({ where: { id: courierId } });
+    if (!courier) {
+      throw new Error("Courier Not Found");
+    }
+    if (!courier.isActive) {
+      throw new InactiveCourierError();
+    }
+
+    // Acquire a write lock early so concurrent assignments serialize.
+    await tx.courier.update({
+      where: { id: courierId },
+      data: { lockVersion: { increment: 1 } },
+    });
+
+    const pkg = await tx.package.findUnique({ where: { id: packageId } });
+    if (!pkg) {
+      throw new Error("Package Not Found");
+    }
+    if (pkg.weightKg < 0) {
+      throw new NegativeWeightError();
+    }
+    if (pkg.status !== "PENDING" || pkg.courierId) {
+      throw new PackageAlreadyAssignedError();
+    }
+
+    const agg = await tx.package.aggregate({
+      where: { courierId, status: "ASSIGNED" },
+      _sum: { weightKg: true },
+    });
+    const currentLoad = agg._sum.weightKg ?? 0;
+
+    if (currentLoad + pkg.weightKg > CAPACITY_LIMIT_KG) {
+      throw new CapacityExceededError();
+    }
+
+    const updated = await tx.package.updateMany({
+      where: { id: packageId, status: "PENDING", courierId: null },
+      data: { status: "ASSIGNED", courierId },
+    });
+    if (updated.count !== 1) {
+      throw new PackageAlreadyAssignedError();
+    }
+
+    try {
+      await tx.assignment.create({
+        data: { courierId, packageId },
+      });
+    } catch {
+      throw new PackageAlreadyAssignedError();
+    }
+
+    return { courierId, packageId };
+  });
+}
diff --git a/repository_after/lib/prisma.ts b/repository_after/lib/prisma.ts
new file mode 100644
index 00000000..b4b56822
--- /dev/null
+++ b/repository_after/lib/prisma.ts
@@ -0,0 +1,15 @@
+import { PrismaClient } from "@prisma/client";
+
+declare global {
+  // eslint-disable-next-line no-var
+  var __urbancargo_prisma: PrismaClient | undefined;
+}
+
+export function createPrismaClient() {
+  return new PrismaClient();
+}
+
+export const prisma = globalThis.__urbancargo_prisma ?? createPrismaClient();
+if (process.env.NODE_ENV !== "production") {
+  globalThis.__urbancargo_prisma = prisma;
+}
diff --git a/repository_after/lib/queries.ts b/repository_after/lib/queries.ts
new file mode 100644
index 00000000..2691fef8
--- /dev/null
+++ b/repository_after/lib/queries.ts
@@ -0,0 +1,36 @@
+import type { PrismaClient } from "@prisma/client";
+import { CAPACITY_LIMIT_KG } from "./core";
+
+export async function listCouriersWithRemainingCapacity(prisma: PrismaClient) {
+  const couriers = await prisma.courier.findMany({
+    orderBy: { name: "asc" },
+    select: { id: true, name: true, isActive: true },
+  });
+
+  const loads = await prisma.package.groupBy({
+    by: ["courierId"],
+    where: { status: "ASSIGNED", courierId: { not: null } },
+    _sum: { weightKg: true },
+  });
+
+  const loadByCourier = new Map<string, number>();
+  for (const row of loads) {
+    if (row.courierId) {
+      loadByCourier.set(row.courierId, row._sum.weightKg ?? 0);
+    }
+  }
+
+  return couriers.map((c) => {
+    const currentLoad = loadByCourier.get(c.id) ?? 0;
+    const remainingCapacityKg = Math.max(0, CAPACITY_LIMIT_KG - currentLoad);
+    return { ...c, remainingCapacityKg };
+  });
+}
+
+export async function listPendingPackages(prisma: PrismaClient) {
+  return prisma.package.findMany({
+    where: { status: "PENDING", courierId: null },
+    orderBy: { createdAt: "asc" },
+    select: { id: true, description: true, weightKg: true },
+  });
+}
diff --git a/repository_after/package.json b/repository_after/package.json
new file mode 100644
index 00000000..2423be63
--- /dev/null
+++ b/repository_after/package.json
@@ -0,0 +1,20 @@
+{
+  "name": "urbancargo",
+  "private": true,
+  "type": "module",
+  "scripts": {
+    "dev": "next dev",
+    "build": "next build",
+    "start": "next start"
+  },
+  "dependencies": {
+    "@prisma/client": "^6.2.1",
+    "next": "^15.1.4",
+    "react": "^19.0.0",
+    "react-dom": "^19.0.0"
+  },
+  "devDependencies": {
+    "prisma": "^6.2.1",
+    "typescript": "^5.7.3"
+  }
+}
diff --git a/repository_after/prisma/schema.prisma b/repository_after/prisma/schema.prisma
new file mode 100644
index 00000000..d76f195f
--- /dev/null
+++ b/repository_after/prisma/schema.prisma
@@ -0,0 +1,53 @@
+generator client {
+  provider = "prisma-client-js"
+}
+
+datasource db {
+  provider = "sqlite"
+  url      = env("DATABASE_URL")
+}
+
+enum PackageStatus {
+  PENDING
+  ASSIGNED
+  DELIVERED
+}
+
+model Courier {
+  id          String   @id @default(cuid())
+  name        String
+  isActive    Boolean  @default(true)
+  lockVersion Int      @default(0)
+  createdAt   DateTime @default(now())
+  updatedAt   DateTime @updatedAt
+
+  packages    Package[]
+  assignments Assignment[]
+}
+
+model Package {
+  id          String        @id @default(cuid())
+  description String
+  weightKg    Float
+  status      PackageStatus @default(PENDING)
+  courierId   String?
+  courier     Courier?      @relation(fields: [courierId], references: [id])
+  createdAt   DateTime      @default(now())
+  updatedAt   DateTime      @updatedAt
+
+  assignment  Assignment?
+
+  @@index([courierId, status])
+}
+
+model Assignment {
+  id        String   @id @default(cuid())
+  courierId String
+  packageId String   @unique
+  createdAt DateTime @default(now())
+
+  courier   Courier  @relation(fields: [courierId], references: [id])
+  pkg       Package  @relation(fields: [packageId], references: [id])
+
+  @@index([courierId])
+}
diff --git a/repository_after/tsconfig.json b/repository_after/tsconfig.json
new file mode 100644
index 00000000..1717a75a
--- /dev/null
+++ b/repository_after/tsconfig.json
@@ -0,0 +1,18 @@
+{
+  "compilerOptions": {
+    "target": "ES2022",
+    "lib": ["dom", "dom.iterable", "es2022"],
+    "allowJs": false,
+    "skipLibCheck": true,
+    "strict": true,
+    "noEmit": true,
+    "esModuleInterop": true,
+    "module": "esnext",
+    "moduleResolution": "bundler",
+    "resolveJsonModule": true,
+    "isolatedModules": true,
+    "jsx": "preserve"
+  },
+  "include": ["next-env.d.ts", "app/**/*", "lib/**/*"],
+  "exclude": ["node_modules"]
+}
