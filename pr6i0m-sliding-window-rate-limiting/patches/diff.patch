diff --git a/repository_before/RateLimiter.java b/repository_after/RateLimiter.java
new file mode 100644
index 00000000..d9e26fa6
--- /dev/null
+++ b/repository_after/RateLimiter.java
@@ -0,0 +1,185 @@
+package com.example.ratelimiter;
+
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * A thread-safe sliding window rate limiter that enforces per-client request limits.
+ * 
+ * This implementation uses a circular buffer approach to efficiently track requests
+ * within a sliding time window without unbounded memory growth.
+ */
+public class RateLimiter {
+    private final int maxRequests;
+    private final long windowSizeMillis;
+    private final ConcurrentHashMap<String, ClientWindow> clientWindows;
+    private final AtomicInteger operationCounter;
+    
+    // Cleanup old client windows every N operations to bound memory
+    private static final int CLEANUP_INTERVAL = 1000;
+    // Remove client windows that haven't been accessed in 2x the window size
+    private static final long CLIENT_EXPIRY_MULTIPLIER = 2;
+    
+    /**
+     * Creates a new RateLimiter instance.
+     * 
+     * @param maxRequests Maximum number of requests allowed per client within the time window
+     * @param windowSizeMillis Size of the sliding time window in milliseconds
+     */
+    public RateLimiter(int maxRequests, long windowSizeMillis) {
+        if (maxRequests <= 0) {
+            throw new IllegalArgumentException("maxRequests must be positive");
+        }
+        if (windowSizeMillis <= 0) {
+            throw new IllegalArgumentException("windowSizeMillis must be positive");
+        }
+        this.maxRequests = maxRequests;
+        this.windowSizeMillis = windowSizeMillis;
+        this.clientWindows = new ConcurrentHashMap<>();
+        this.operationCounter = new AtomicInteger(0);
+    }
+    
+    /**
+     * Determines whether a request from the given client should be allowed.
+     * 
+     * @param clientId Unique identifier for the client
+     * @return true if the request should be allowed, false if it should be rate-limited
+     */
+    public boolean isAllowed(String clientId) {
+        if (clientId == null) {
+            throw new IllegalArgumentException("clientId cannot be null");
+        }
+        
+        long currentTime = System.currentTimeMillis();
+        
+        // Periodically cleanup old client windows to bound memory
+        int ops = operationCounter.incrementAndGet();
+        if (ops % CLEANUP_INTERVAL == 0) {
+            cleanupOldClients(currentTime);
+        }
+        
+        ClientWindow window = clientWindows.computeIfAbsent(
+            clientId, 
+            k -> new ClientWindow(maxRequests, windowSizeMillis, currentTime)
+        );
+        
+        boolean allowed = window.isAllowed(currentTime);
+        window.updateLastAccess(currentTime);
+        return allowed;
+    }
+    
+    /**
+     * Removes client windows that haven't been accessed recently to bound memory usage.
+     * This method is thread-safe and uses ConcurrentHashMap's atomic operations.
+     */
+    private void cleanupOldClients(long currentTime) {
+        long expiryTime = currentTime - (windowSizeMillis * CLIENT_EXPIRY_MULTIPLIER);
+        
+        clientWindows.entrySet().removeIf(entry -> {
+            ClientWindow window = entry.getValue();
+            return window.getLastAccessTime() < expiryTime;
+        });
+    }
+    
+    /**
+     * Per-client sliding window tracker.
+     * Uses a circular buffer to efficiently track request timestamps within the window.
+     */
+    private class ClientWindow {
+        private final int maxRequests;
+        private final long windowSizeMillis;
+        private final long[] requestTimes;
+        private final AtomicInteger writeIndex;
+        private final AtomicLong lastCleanupTime;
+        private final AtomicLong lastAccessTime;
+        private final ReentrantReadWriteLock lock;
+        private final int bufferSize;
+        
+        // Calculate buffer size to be at least maxRequests, rounded up to next power of 2
+        // This ensures we can accurately track all requests within the window
+        private int calculateBufferSize(int maxRequests) {
+            // Minimum buffer size
+            int minSize = 64;
+            // Need at least maxRequests entries, with some headroom
+            int requiredSize = Math.max(minSize, maxRequests * 2);
+            // Round up to next power of 2 for efficient modulo
+            int size = 1;
+            while (size < requiredSize) {
+                size <<= 1;
+            }
+            return size;
+        }
+        
+        ClientWindow(int maxRequests, long windowSizeMillis, long initialTime) {
+            this.maxRequests = maxRequests;
+            this.windowSizeMillis = windowSizeMillis;
+            this.bufferSize = calculateBufferSize(maxRequests);
+            this.requestTimes = new long[bufferSize];
+            this.writeIndex = new AtomicInteger(0);
+            this.lastCleanupTime = new AtomicLong(initialTime);
+            this.lastAccessTime = new AtomicLong(initialTime);
+            this.lock = new ReentrantReadWriteLock();
+        }
+        
+        long getLastAccessTime() {
+            return lastAccessTime.get();
+        }
+        
+        void updateLastAccess(long currentTime) {
+            lastAccessTime.set(currentTime);
+        }
+        
+        boolean isAllowed(long currentTime) {
+            lock.writeLock().lock();
+            try {
+                // Cleanup old entries periodically to bound memory
+                long lastCleanup = lastCleanupTime.get();
+                if (currentTime - lastCleanup > windowSizeMillis) {
+                    cleanupOldEntries(currentTime);
+                    lastCleanupTime.set(currentTime);
+                }
+                
+                // Count valid requests within the window
+                int validCount = countValidRequests(currentTime);
+                
+                if (validCount >= maxRequests) {
+                    return false;
+                }
+                
+                // Record this request
+                int index = writeIndex.getAndIncrement() & (bufferSize - 1);
+                requestTimes[index] = currentTime;
+                
+                return true;
+            } finally {
+                lock.writeLock().unlock();
+            }
+        }
+        
+        private int countValidRequests(long currentTime) {
+            long windowStart = currentTime - windowSizeMillis;
+            int count = 0;
+            
+            for (int i = 0; i < bufferSize; i++) {
+                long requestTime = requestTimes[i];
+                if (requestTime > 0 && requestTime > windowStart) {
+                    count++;
+                }
+            }
+            
+            return count;
+        }
+        
+        private void cleanupOldEntries(long currentTime) {
+            long windowStart = currentTime - windowSizeMillis;
+            
+            for (int i = 0; i < bufferSize; i++) {
+                if (requestTimes[i] > 0 && requestTimes[i] <= windowStart) {
+                    requestTimes[i] = 0;
+                }
+            }
+        }
+    }
+}
