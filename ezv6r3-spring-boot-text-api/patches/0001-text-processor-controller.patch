diff --git a/repository_before/TextProcessingController.java b/repository_after/TextProcessingController.java
index afb525b..c7f0906 100644
--- a/repository_before/TextProcessingController.java
+++ b/repository_after/TextProcessingController.java
@@ -1,67 +1,101 @@
 package com.example.textapi;
 
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+import org.springframework.validation.annotation.Validated;
+import org.springframework.web.bind.MethodArgumentNotValidException;
 import org.springframework.web.bind.annotation.*;
-import java.util.*;
+
+import jakarta.validation.Valid;
+import jakarta.validation.constraints.NotBlank;
+import java.util.HashMap;
+import java.util.Map;
 
 @RestController
 @RequestMapping("/api/text")
+@Validated
 public class TextProcessingController {
 
-    private String lastProcessedText;
-
     @PostMapping("/process")
-    public Map<String, Object> processText(@RequestBody Map<String, String> body) {
-
-        Map<String, Object> response = new HashMap<>();
+    public TextResponse processText(@Valid @RequestBody TextRequest request) {
+        String originalText = request.getText();
 
-        String text = body.get("text");
+        String trimmedText = originalText.trim();
 
-        lastProcessedText = text.trim();
+        String reversed = new StringBuilder(trimmedText).reverse().toString();
 
-        int length = text.length();
+        String[] words = trimmedText.split("\\s+");
+        int wordCount = (trimmedText.isEmpty()) ? 0 : words.length;
 
-        char firstChar = text.charAt(0);
+        String lastProcessed = trimmedText.toUpperCase();
 
-        String reversed = reverseText(text);
-
-        String[] words = text.split(" ");
-        int wordCount = 0;
-        for (int i = 0; i <= words.length; i++) {
-            if (!words[i].isEmpty()) {
-                wordCount++;
-            }
-        }
+        return new TextResponse(
+            originalText,
+            trimmedText.length(),
+            trimmedText.charAt(0),
+            reversed,
+            wordCount,
+            lastProcessed
+        );
+    }
+}
 
-        lastProcessedText = lastProcessedText.toUpperCase();
+class TextRequest {
+    @NotBlank(message = "Text must not be null, empty, or whitespace only")
+    private String text;
 
-        response.put("original", text);
-        response.put("length", length);
-        response.put("firstCharacter", firstChar);
-        response.put("reversed", reversed);
-        response.put("wordCount", wordCount);
-        response.put("lastProcessed", lastProcessedText);
+    public String getText() {
+        return text;
+    }
 
-        return response;
+    public void setText(String text) {
+        this.text = text;
     }
+}
 
-    private String reverseText(String input) {
+class TextResponse {
+    private final String original;
+    private final int length;
+    private final char firstCharacter;
+    private final String reversed;
+    private final int wordCount;
+    private final String lastProcessed;
+
+    public TextResponse(String original, int length, char firstCharacter, String reversed, int wordCount, String lastProcessed) {
+        this.original = original;
+        this.length = length;
+        this.firstCharacter = firstCharacter;
+        this.reversed = reversed;
+        this.wordCount = wordCount;
+        this.lastProcessed = lastProcessed;
+    }
 
-        String result = "";
+    public String getOriginal() { return original; }
+    public int getLength() { return length; }
+    public char getFirstCharacter() { return firstCharacter; }
+    public String getReversed() { return reversed; }
+    public int getWordCount() { return wordCount; }
+    public String getLastProcessed() { return lastProcessed; }
+}
 
-        for (int i = input.length() - 2; i >= 0; i--) {
-            result = result + input.charAt(i);
-        }
+@RestControllerAdvice
+class GlobalExceptionHandler {
 
-        return result;
+    @ExceptionHandler(MethodArgumentNotValidException.class)
+    public ResponseEntity<Map<String, Object>> handleValidationExceptions(MethodArgumentNotValidException ex) {
+        Map<String, Object> errorResponse = new HashMap<>();
+        errorResponse.put("error", "Bad Request");
+        errorResponse.put("message", "Validation failed: Input text cannot be null, empty, or whitespace only.");
+        errorResponse.put("status", HttpStatus.BAD_REQUEST.value());
+        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
     }
 
-    private boolean isTextValid(String text) {
-        if (text == null) {
-            return false;
-        }
-        if (text.length() < 0) {
-            return false;
-        }
-        return true;
+    @ExceptionHandler(Exception.class)
+    public ResponseEntity<Map<String, Object>> handleGeneralExceptions(Exception ex) {
+        Map<String, Object> errorResponse = new HashMap<>();
+        errorResponse.put("error", "Internal Server Error");
+        errorResponse.put("message", "An unexpected error occurred processing the request.");
+        errorResponse.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
+        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
     }
-}
+}
\ No newline at end of file
