diff --git a/repository_before/__pycache__/__init__.cpython-311.pyc b/repository_after/__pycache__/__init__.cpython-311.pyc
index 84f0df1..1a0f605 100644
Binary files a/repository_before/__pycache__/__init__.cpython-311.pyc and b/repository_after/__pycache__/__init__.cpython-311.pyc differ
diff --git a/repository_after/__pycache__/graph_entities.cpython-311.pyc b/repository_after/__pycache__/graph_entities.cpython-311.pyc
new file mode 100644
index 0000000..27c2d8a
Binary files /dev/null and b/repository_after/__pycache__/graph_entities.cpython-311.pyc differ
diff --git a/repository_after/__pycache__/graph_entities.cpython-312.pyc b/repository_after/__pycache__/graph_entities.cpython-312.pyc
new file mode 100644
index 0000000..d29714f
Binary files /dev/null and b/repository_after/__pycache__/graph_entities.cpython-312.pyc differ
diff --git a/repository_after/__pycache__/graph_manager.cpython-311.pyc b/repository_after/__pycache__/graph_manager.cpython-311.pyc
new file mode 100644
index 0000000..e5ab13c
Binary files /dev/null and b/repository_after/__pycache__/graph_manager.cpython-311.pyc differ
diff --git a/repository_after/__pycache__/graph_manager.cpython-312.pyc b/repository_after/__pycache__/graph_manager.cpython-312.pyc
new file mode 100644
index 0000000..48dad3f
Binary files /dev/null and b/repository_after/__pycache__/graph_manager.cpython-312.pyc differ
diff --git a/repository_after/__pycache__/knowledge_base.cpython-312.pyc b/repository_after/__pycache__/knowledge_base.cpython-312.pyc
new file mode 100644
index 0000000..d307153
Binary files /dev/null and b/repository_after/__pycache__/knowledge_base.cpython-312.pyc differ
diff --git a/repository_after/__pycache__/knowledge_graph.cpython-311.pyc b/repository_after/__pycache__/knowledge_graph.cpython-311.pyc
new file mode 100644
index 0000000..7f9c1d9
Binary files /dev/null and b/repository_after/__pycache__/knowledge_graph.cpython-311.pyc differ
diff --git a/repository_after/__pycache__/models.cpython-312.pyc b/repository_after/__pycache__/models.cpython-312.pyc
new file mode 100644
index 0000000..15e9558
Binary files /dev/null and b/repository_after/__pycache__/models.cpython-312.pyc differ
diff --git a/repository_after/graph_entities.py b/repository_after/graph_entities.py
new file mode 100644
index 0000000..f35db40
--- /dev/null
+++ b/repository_after/graph_entities.py
@@ -0,0 +1,13 @@
+from dataclasses import dataclass
+
+@dataclass
+class Node:
+    id: str
+    label: str
+    description: str = ""
+
+@dataclass
+class Edge:
+    source: str
+    target: str
+    relationship: str
diff --git a/repository_after/graph_manager.py b/repository_after/graph_manager.py
new file mode 100644
index 0000000..1ad2c9e
--- /dev/null
+++ b/repository_after/graph_manager.py
@@ -0,0 +1,99 @@
+import json
+from collections import defaultdict
+from typing import List, Dict, Tuple
+from graph_entities import Node, Edge
+
+class KnowledgeGraph:
+    """
+    Manages the graph data structure, relationships, and persistence.
+    Uses an Adjacency List approach for performance O(1).
+    """
+    def __init__(self):
+        # Format: {node_id: Node}
+        self.nodes: Dict[str, Node] = {}
+        # Format: {node_id: [Edge]}
+        self.edges: Dict[str, List[Edge]] = defaultdict(list)
+
+    def add_node(self, node_id: str, label: str, description: str = ""):
+        self.nodes[node_id] = Node(id=node_id, label=label, description=description)
+        if node_id not in self.edges:
+            self.edges[node_id] = []
+
+    def remove_node(self, node_id: str):
+        if node_id in self.nodes:
+            del self.nodes[node_id]
+        if node_id in self.edges:
+            del self.edges[node_id]
+        # Remove incoming edges from other nodes
+        for nid in self.edges:
+            self.edges[nid] = [e for e in self.edges[nid] if e.target != node_id]
+
+    def add_edge(self, source: str, target: str, relationship: str):
+        if source in self.nodes and target in self.nodes:
+            # Avoid duplicates
+            for edge in self.edges[source]:
+                if edge.target == target and edge.relationship == relationship:
+                    return
+            self.edges[source].append(Edge(source=source, target=target, relationship=relationship))
+
+    def remove_edge(self, source: str, target: str):
+        if source in self.edges:
+            self.edges[source] = [e for e in self.edges[source] if e.target != target]
+
+    def get_neighbors(self, node_id: str) -> List[Edge]:
+        """Returns list of Edge objects"""
+        return self.edges.get(node_id, [])
+
+    def search_nodes(self, query: str) -> List[str]:
+        """Returns node_ids matching the query (case-insensitive)"""
+        query = query.lower()
+        results = []
+        for nid, node in self.nodes.items():
+            if query in nid.lower() or query in node.label.lower():
+                results.append(nid)
+        return results
+
+    def to_json(self) -> str:
+        data = {
+            "nodes": {nid: {"label": n.label, "desc": n.description} for nid, n in self.nodes.items()},
+            "edges": {k: [[e.target, e.relationship] for e in v] for k, v in self.edges.items() if v}
+        }
+        return json.dumps(data, indent=2)
+
+    def from_json(self, json_str: str):
+        try:
+            data = json.loads(json_str)
+            raw_nodes = data.get("nodes", {})
+            self.nodes = {}
+            for nid, attrs in raw_nodes.items():
+                self.nodes[nid] = Node(id=nid, label=attrs.get("label", ""), description=attrs.get("desc", ""))
+            
+            raw_edges = data.get("edges", {})
+            self.edges = defaultdict(list)
+            
+            # Ensure every node has an entry in edges
+            for nid in self.nodes:
+                self.edges[nid] = []
+
+            for k, v in raw_edges.items():
+                # raw_edges format is {source: [[target, rel], ...]}
+                for item in v:
+                    if len(item) >= 2:
+                        target, rel = item[0], item[1]
+                        self.edges[k].append(Edge(source=k, target=target, relationship=rel))
+        except json.JSONDecodeError:
+            pass # Handle gracefully in UI
+
+    def populate_demo_data(self):
+        """Creates a sample graph for testing"""
+        self.add_node("AI", "Artificial Intelligence", "Simulation of human intelligence.")
+        self.add_node("ML", "Machine Learning", "Subset of AI focused on data.")
+        self.add_node("DL", "Deep Learning", "Neural networks with many layers.")
+        self.add_node("NN", "Neural Network", "Computing system inspired by biological brains.")
+        self.add_node("PY", "Python", "A popular programming language.")
+        
+        self.add_edge("AI", "ML", "includes")
+        self.add_edge("ML", "DL", "includes")
+        self.add_edge("DL", "NN", "relies_on")
+        self.add_edge("ML", "PY", "uses")
+        self.add_edge("PY", "AI", "implements")
diff --git a/repository_after/knowledge_graph.py b/repository_after/knowledge_graph.py
new file mode 100644
index 0000000..9111019
--- /dev/null
+++ b/repository_after/knowledge_graph.py
@@ -0,0 +1,9 @@
+import curses
+from terminal_ui import GraphExplorerApp
+
+def main():
+    # Initialize Curses Wrapper to handle cleanup automatically
+    curses.wrapper(lambda stdscr: GraphExplorerApp(stdscr).run())
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
diff --git a/repository_after/terminal_ui.py b/repository_after/terminal_ui.py
new file mode 100644
index 0000000..35a9d69
--- /dev/null
+++ b/repository_after/terminal_ui.py
@@ -0,0 +1,194 @@
+import curses
+import textwrap
+import os
+from typing import Optional, List
+from graph_manager import KnowledgeGraph
+
+class GraphExplorerApp:
+    def __init__(self, stdscr):
+        self.stdscr = stdscr
+        self.graph = KnowledgeGraph()
+        self.graph.populate_demo_data()
+        
+        # Navigation State
+        self.current_node_id: Optional[str] = "AI"
+        self.history: List[str] = [] # For 'Back' functionality
+        self.selection_index = 0
+        self.scroll_offset = 0
+        
+        # UI Colors
+        curses.start_color()
+        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLACK) # Default
+        curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_CYAN)  # Highlight
+        curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK) # Headers
+        curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK) # Relationships
+
+    def run(self):
+        while True:
+            self.draw_screen()
+            key = self.stdscr.getch()
+            if not self.handle_input(key):
+                break
+
+    def draw_screen(self):
+        self.stdscr.clear()
+        h, w = self.stdscr.getmaxyx()
+
+        # 1. Header
+        title = " KNOWLEDGE GRAPH EXPLORER "
+        self.stdscr.addstr(0, 0, title.center(w, "="), curses.color_pair(3) | curses.A_BOLD)
+
+        if not self.current_node_id or self.current_node_id not in self.graph.nodes:
+            self.stdscr.addstr(2, 2, "No node selected or Graph Empty. Press 'S' to search/select.", curses.color_pair(1))
+            self.draw_footer(h, w)
+            return
+
+        # 2. Current Node Details
+        # node_data is now a Node object
+        node_data = self.graph.nodes[self.current_node_id]
+        self.stdscr.addstr(2, 2, f"NODE: {node_data.label} (ID: {self.current_node_id})", curses.color_pair(3) | curses.A_BOLD)
+        
+        desc_lines = textwrap.wrap(node_data.description, w - 4)
+        for i, line in enumerate(desc_lines[:3]): # Limit description to 3 lines
+            self.stdscr.addstr(3 + i, 4, line, curses.color_pair(1))
+
+        # 3. Neighbors (The Interactive List)
+        # neighbors is a list of Edge objects
+        neighbors = self.graph.get_neighbors(self.current_node_id)
+        self.stdscr.addstr(7, 2, f"CONNECTIONS ({len(neighbors)}):", curses.color_pair(3))
+        
+        max_display_lines = h - 14 
+        start_y = 9
+
+        if not neighbors:
+            self.stdscr.addstr(start_y, 4, "[No outgoing connections]", curses.color_pair(1))
+        else:
+            # Bounds check selection
+            if self.selection_index >= len(neighbors):
+                self.selection_index = len(neighbors) - 1
+            if self.selection_index < 0:
+                self.selection_index = 0
+            
+            # Scrolling logic
+            if self.selection_index < self.scroll_offset:
+                self.scroll_offset = self.selection_index
+            elif self.selection_index >= self.scroll_offset + max_display_lines:
+                self.scroll_offset = self.selection_index - max_display_lines + 1
+
+            # Render List
+            for i in range(max_display_lines):
+                idx = i + self.scroll_offset
+                if idx >= len(neighbors):
+                    break
+                
+                edge = neighbors[idx]
+                target_node = self.graph.nodes.get(edge.target)
+                target_label = target_node.label if target_node else 'Unknown'
+                
+                display_str = f" --[{edge.relationship}]--> {target_label} "
+                
+                # Highlight if selected
+                if idx == self.selection_index:
+                    self.stdscr.addstr(start_y + i, 4, display_str.ljust(w-10), curses.color_pair(2))
+                else:
+                    self.stdscr.addstr(start_y + i, 4, display_str, curses.color_pair(1))
+                    self.stdscr.addstr(start_y + i, 4 + 3, f"[{edge.relationship}]", curses.color_pair(4)) # Colorize edge label
+
+        self.draw_footer(h, w)
+        self.stdscr.refresh()
+
+    def draw_footer(self, h, w):
+        help_text = "[UP/DOWN] Nav  [ENTER] Visit  [B] Back  [S] Search  [+] Add Node  [-] Del Node  [E] Export  [I] Import  [Q] Quit"
+        self.stdscr.addstr(h - 2, 0, help_text[:w-1], curses.color_pair(1) | curses.A_REVERSE)
+
+    def prompt_input(self, prompt_text: str):
+        """Helper to get text input from user at bottom of screen"""
+        h, w = self.stdscr.getmaxyx()
+        curses.echo()
+        curses.curs_set(1)
+        self.stdscr.addstr(h - 1, 0, (prompt_text + ": ").ljust(w-1), curses.color_pair(3))
+        # Clear the rest of the line
+        self.stdscr.clrtoeol()
+        self.stdscr.refresh()
+        inp = self.stdscr.getstr(h - 1, len(prompt_text) + 2).decode('utf-8')
+        curses.noecho()
+        curses.curs_set(0)
+        return inp.strip()
+
+    def handle_input(self, key):
+        neighbors = self.graph.get_neighbors(self.current_node_id) if self.current_node_id else []
+
+        if key == ord('q'):
+            return False # Exit
+
+        # --- Navigation ---
+        elif key == curses.KEY_UP:
+            if neighbors: self.selection_index = max(0, self.selection_index - 1)
+        
+        elif key == curses.KEY_DOWN:
+            if neighbors: self.selection_index = min(len(neighbors) - 1, self.selection_index + 1)
+        
+        elif key == 10: # Enter Key
+            if neighbors and self.selection_index < len(neighbors):
+                edge = neighbors[self.selection_index]
+                self.history.append(self.current_node_id)
+                self.current_node_id = edge.target
+                self.selection_index = 0
+                self.scroll_offset = 0
+
+        elif key == ord('b') or key == ord('B'):
+            if self.history:
+                self.current_node_id = self.history.pop()
+                self.selection_index = 0
+
+        # --- Search ---
+        elif key == ord('s') or key == ord('S'):
+            query = self.prompt_input("Search Node ID or Label")
+            results = self.graph.search_nodes(query)
+            if results:
+                # If match found, jump to first result
+                if self.current_node_id:
+                     self.history.append(self.current_node_id) 
+                self.current_node_id = results[0]
+                self.selection_index = 0
+
+        # --- Adding Nodes/Edges ---
+        elif key == ord('+'):
+            choice = self.prompt_input("Add (N)ode or (E)dge?").lower()
+            if choice == 'n':
+                nid = self.prompt_input("New ID")
+                lbl = self.prompt_input("Label")
+                desc = self.prompt_input("Description")
+                if nid: 
+                    self.graph.add_node(nid, lbl, desc)
+                    self.current_node_id = nid # Jump to new node
+            elif choice == 'e':
+                tgt = self.prompt_input("Target Node ID")
+                rel = self.prompt_input("Relationship Type")
+                if self.current_node_id and tgt and rel:
+                    self.graph.add_edge(self.current_node_id, tgt, rel)
+
+        # --- Removing ---
+        elif key == ord('-'):
+            confirm = self.prompt_input(f"Delete Node {self.current_node_id}? (y/n)")
+            if confirm.lower() == 'y':
+                self.graph.remove_node(self.current_node_id)
+                self.current_node_id = list(self.graph.nodes.keys())[0] if self.graph.nodes else None
+        
+        # --- Import/Export ---
+        elif key == ord('e') or key == ord('E'):
+            fname = self.prompt_input("Export Filename (e.g. graph.json)")
+            if fname:
+                with open(fname, 'w') as f:
+                    f.write(self.graph.to_json())
+
+        elif key == ord('i') or key == ord('I'):
+            fname = self.prompt_input("Import Filename")
+            if fname and os.path.exists(fname):
+                with open(fname, 'r') as f:
+                    self.graph.from_json(f.read())
+                # Reset view to first available node
+                keys = list(self.graph.nodes.keys())
+                if keys: self.current_node_id = keys[0]
+
+        return True
